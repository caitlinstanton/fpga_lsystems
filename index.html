<!DOCTYPE HTML>
<!--
	Directive by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>

<head>
	<title>FPGA L-Systems</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<link rel="stylesheet" href="assets/css/main.css" />
</head>

<body class="is-preload">

	<!-- Header -->
	<div id="header">
		<span class="logo icon fa-paper-plane"></span>
		<h1>Graphing L-Systems on the FPGA</h1>
		<p><i>a project by</i></p>
		<h3>Priya Kattapurath, Michael Rivera, & Caitlin Stanton</h3>
		<p><i>for ECE 5760 (Advanced Microcontrollers) at Cornell University</i></p>
		<p></a>.
		</p>
	</div>

	<!-- Main -->
	<div id="main">

		<section id="sidebar">
			<div class="inner">
				<nav>
					<ul>
						<li><a href="#intro">Introduction</a></li>
						<li><a href="#high-level">High-Level</a></li>
						<li><a href="#baseline">Baseline</a></li>
						<li><a href="#full-system">Full System</a></li>
						<li><a href="#testing">Testing</a></li>
						<li><a href="#results">Results</a></li>
						<li><a href="#conclusion">Conclusion</a></li>
						<li><a href="#appendices">Appendices</a></li>
					</ul>
				</nav>
			</div>
		</section>

		<header class="major container medium">
			<p>We implemented naturally recursive Lindenmayer systems (commonly known as fractals) on an Intel Altera board to
				graph on a VGA screen. Our system proved to be faster than pure software programs written in both Python and
				C.</p>
		</header>

		<!-- <div class="box alt container">

			<section class="feature left">
				<a href="#" class="image icon solid fa-signal"><img src="images/pic01.jpg" alt="" /></a>
				<div class="content">
					<h3>The First Thing</h3>
					<p>Vitae natoque dictum etiam semper magnis enim feugiat amet curabitur tempor orci penatibus. Tellus erat
						mauris ipsum fermentum etiam vivamus eget. Nunc nibh morbi quis fusce lacus.</p>
				</div>
			</section>
			<section class="feature right">
				<a href="#" class="image icon solid fa-code"><img src="images/pic02.jpg" alt="" /></a>
				<div class="content">
					<h3>The Second Thing</h3>
					<p>Vitae natoque dictum etiam semper magnis enim feugiat amet curabitur tempor orci penatibus. Tellus erat
						mauris ipsum fermentum etiam vivamus eget. Nunc nibh morbi quis fusce lacus.</p>
				</div>
			</section>
			<section class="feature left">
				<a href="#" class="image icon solid fa-mobile-alt"><img src="images/pic03.jpg" alt="" /></a>
				<div class="content">
					<h3>The Third Thing</h3>
					<p>Vitae natoque dictum etiam semper magnis enim feugiat amet curabitur tempor orci penatibus. Tellus erat
						mauris ipsum fermentum etiam vivamus eget. Nunc nibh morbi quis fusce lacus.</p>
				</div>
			</section>
		</div> -->

		<br id="intro">
		<div class="box container">
			<section>
				<header>
					<h2>Introduction</h2>
				</header>
				<p>There are dozens of L-Systems in existence, and for this project we implemented seven. Each was configurable
					via the number of iterations the system performed, the axiom to begin with, the size and color of the lines,
					and the starting coordinates of the system.
				</p>
				<ul>
					<li>Dragon curve</li>
					<li>Two versions of the Sierpinski arrowhead</li>
					<li>Two versions of the Koch curve</li>
					<li>Cross</li>
					<li>Tessellated triangles</li>
				</ul>
				<p>This project was composed of two subsystems: Verilog code for the FPGA to calculate the L-Systems and graph
					the result, and the C code for the HPS to interface with the user. The FPGA has a faster system clock
					frequency and, considering the generation of L-Systems is computationally intensive, it made sense to offload
					that onto the faster, hardware-based part of the Altera board. Graphing on the VGA screen isn’t something
					that’s limited to the FPGA itself, but bandwidth would’ve been a limiting factor when transmitting large
					chunks of data from the FPGA to the HPS. With this in mind, graphing was kept to the FPGA, where the results
					were already being calculated. The HPS was instead utilized for its terminal interface, where the user was
					able to configure the L-System to be graphed. Any system settings were communicated to the FPGA via PIO ports
					to use in its computations. </p>
			</section>
		</div>
		<br id="high-level">
		<div class="box container">
			<section>
				<header>
					<h2>High-Level Design</h2>
				</header>
				<p>The formal definition of a Lindenmayer System (or L-System) is “a parallel rewriting system and a type of
					formal grammar.” In simpler terms, L-Systems generate fractals, which are never-ending complex patterns that
					are self similar at different scales such that zooming in or out will still show the same fractal pattern.
				</p>
				<p>There are three main components to every L-System: an alphabet, an axiom, and rules. These configure and
					manipulate the strings of characters that define how the visualization should act, such as moving forward,
					turning 90 degrees to the right, or branching out from a previous state. The alphabet is the set of valid
					symbols that can be included in these strings; for example, an alphabet of {A, B} restricts any valid sentence
					to only contain A and B. The axiom sets the initial value for the system’s string; working within the system
					with alphabet {A, B}, an axiom could be “A.” Rules change the string recursively, generating new strings
					repeatedly and providing actions to control the movements of the growing visualization. They’re structured to
					take in a predecessor and a successor—the former is the input and the latter is the output after having the
					rule applied to it. A rule to our {A, B} system with axiom A could be “A → AB”; this would take our initial
					state and create the string “AB” for the next state.
				</p>
				<p>The alphabet for every phase of our design, no matter the coding language, consists of the following symbols,
					as shown in Table 1. Each symbol corresponds to a specific action, from graphing (which are consistent across
					L-Systems) to buffer characters for rule generation (specific to each L-System).</p>
				<img src="images/alphabet.png" style="display:block;margin: 0 auto;">
				<p style="text-align: center;"><i>Table 1: Examples of actions associated with L-System symbols.</i></p>
				<br>
				<p>Though there is an infinite number of combinations of axioms and rules within the given alphabet, the seven
					L-Systems we developed have preset values for each. We followed these so as to ensure the graphed results
					would match what was expected. Table 2 shows the axioms and rules for each L-System.</p>
				<img src="images/lsystems.png" style="display:block;margin: 0 auto;">
				<p style="text-align: center;"><i>Table 2: Parameters for the L-Systems in our implementation.</i></p>
				<br>
			</section>
		</div>
		<br id="baseline">
		<div class="box container">
			<section>
				<h2>Baseline Design</h2>
				<p>Considering L-Systems have multiple moving parts, the most straightforward way to understand their inner
					mechanisms comes from our baseline designs.
				</p>
				<h3>Python</h3>
				<p>This Python code is an off-the-shelf implementation that we extended to incorporate the axioms and rules for
					our specific L-Systems. It uses a dictionary of rules—key-value pairs where the key is the character to apply
					to rule to and the value is the output string for that character—and locally declared <code>axiom</code>,
					<code>iterations</code>,
					<code>angle</code>, and <code>step</code> variables to iterate over a starting axiom and graph the resulting
					L-System using pygame. This
					is accomplished with several functions, each of which helped build the foundations for our C code and
					eventually our Verilog design.
				</p>
				<p><code>applyRule</code> is responsible for taking in a single character and converting it to the output string
					as specified
					in the <code>rules</code> dictionary. It uses a for loop through every entry in <code>rules</code> to see if
					any key matches the <code>input</code>
					character. If a rule exists for this specific character, the result string is set to that rule’s value,
					otherwise the result string is the original character. This exemplifies how not every character will be
					expanded through a rule—at the very least it’ll just be copied into the resulting output string.</p>
				<!-- HTML generated using hilite.me -->
				<div
					style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
					<pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">def</span> applyRule(input):
   output = <span style="font-style: italic">&quot;&quot;</span>
   <span style="font-weight: bold">for</span> rule, result <span style="font-weight: bold">in</span> rules.items(
   ):  <span style="font-style: italic"># applying the rule by checking the current char against it</span>
       <span style="font-weight: bold">if</span> (input == rule):
           output = result  <span style="font-style: italic"># Rule 1</span>
           <span style="font-weight: bold">break</span>
       <span style="font-weight: bold">else</span>:
           output = input  <span style="font-style: italic"># else ( no rule set ) output = the current char -&gt; no rule was applied</span>
   <span style="font-weight: bold">return</span> output
</pre>
				</div>
				<br>
				<p>The next function is <code>processString</code>. Rather than take an individual character as input, it
					receives an entire
					string to process. Every character must be handled in order to see if a rule can apply to it, so a for loop
					runs over every character and sends each to <code>applyRule</code>. The new string is built up with each call
					to <code>applyRule</code>,
					creating a string that will have grown in length from the original.</p>
				<!-- HTML generated using hilite.me -->
				<div
					style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
					<pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">def</span> processString(oldStr):
   newstr = <span style="font-style: italic">&quot;&quot;</span>
   <span style="font-weight: bold">for</span> character <span style="font-weight: bold">in</span> oldStr:
       newstr = newstr + applyRule(character)  <span style="font-style: italic"># build the new string</span>
   <span style="font-weight: bold">return</span> newstr
</pre>
				</div>
				<br>
				<p><code>createSystem</code> puts the previous two functions together to bring iterations into the mix. It takes
					in <code>axiom</code> and
					<code>numIters</code> as inputs, where the former is the starting string for the L-System and the latter is
					the specified
					number of iterations to process the string by. While <code>processString</code> does grow the string as it
					loops over every
					character, <code>createSystem</code> is responsible for repeating this process multiple times from iteration
					number zero to
					iteration number <code>numIters</code>-1. With each iteration, it takes the string from the previous iteration
					and puts it
					into <code>processString</code>, storing the result so that the next iteration can use it.
				</p>
				<!-- HTML generated using hilite.me -->
				<div
					style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
					<pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">def</span> createSystem(numIters, axiom):
   startString = axiom
   endString = <span style="font-style: italic">&quot;&quot;</span>
   <span style="font-weight: bold">for</span> i <span style="font-weight: bold">in</span> range(numIters):  <span style="font-style: italic"># iterate with applying the rules</span>
       print(<span style="font-style: italic">&quot;Iteration: {0}&quot;</span>.format(i))
       endString = processString(startString)
       startString = endString
   <span style="font-weight: bold">return</span> endString
</pre>
				</div>
				<br>
				<p>With the L-System string built through <code>createSystem</code>, <code>drawTree</code> is able to graph the
					L-System using pygame. It
					takes in the L-System string and the starting coordinates from which to graph. It then uses a loop to look at
					every character in the string to determine what (if any) graphing functionality it needs to provide. If it
					sees an ‘A’ or ‘F’ it draws forward by the length determined by <code>step</code>. If it sees a ‘+’ it
					increments the
					orientation of the system by <code>angle</code>, and similarly decrements the orientation of the system by
					<code>angle</code> if it sees
					a ‘-’. ‘X’ and ‘Y’ aren’t graphing characters so they, and any other characters not equal to ‘A’, ‘F’, ‘+’, or
					‘-’, are skipped over.
				</p>
				<!-- HTML generated using hilite.me -->
				<div
					style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
					<pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">def</span> drawTree(input, oldpos):
   a = 0  <span style="font-style: italic"># angle</span>
   i = 0  <span style="font-style: italic"># counter for process calculation</span>
   processOld = 0  <span style="font-style: italic"># old process</span>
   newpos = oldpos
   color = (255, 255, 255)
   linesize = 1
   <span style="font-weight: bold">for</span> character <span style="font-weight: bold">in</span> input:  <span style="font-style: italic"># process for drawing the l-system by writing the string to the screen</span>
 
       i += 1  <span style="font-style: italic"># print process in percent</span>
       process = i * 100 / len(input)
       <span style="font-weight: bold">if</span> <span style="font-weight: bold">not</span> process == processOld:
           <span style="font-style: italic"># print(process, &quot;%&quot;)</span>
           processOld = process
 
       <span style="font-weight: bold">if</span> character == <span style="font-style: italic">&#39;A&#39;</span>:  <span style="font-style: italic"># magic happens here</span>
           newpos = polar_to_cart(a + angleoffset, step, *oldpos)
           pygame.draw.line(screen, color, oldpos, newpos, linesize)
           oldpos = newpos
       <span style="font-weight: bold">elif</span> character == <span style="font-style: italic">&#39;F&#39;</span>:
           newpos = polar_to_cart(a + angleoffset, step, *oldpos)
           pygame.draw.line(screen, color, oldpos, newpos, linesize)
           oldpos = newpos
       <span style="font-weight: bold">elif</span> character == <span style="font-style: italic">&#39;+&#39;</span>:
           a += angle
       <span style="font-weight: bold">elif</span> character == <span style="font-style: italic">&#39;-&#39;</span>:
           a -= angle
</pre>
				</div>
				<br>
				<h3>C</h3>
				<p>Since Python is an interpreted, high-level language, our next step was to synthesize and graph L-Systems in C
					code to be run on the FPGA. This did require a Quartus project to be compiled and loaded onto the board, but
					it wasn’t something that we changed at all. Specifically, we used the “GPU with FAST display from SRAM”
					project from the ECE 5760 Avalon Bus Master page.
				</p>
				<p>The program layout of the Python code corresponds almost entirely with that of the C program, though it only
					focuses on the dragon curve, not all seven L-Systems. First there is the <code>applyRule_DragonCurve</code>
					function, which
					is responsible for receiving a single character and outputting a character pointer to a string. This string is
					built by putting the input character through a switch-case statement and seeing which condition it matches.
				</p>
				<!-- HTML generated using hilite.me -->
				<div
					style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
					<pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">char</span>* applyRule_DragonCurve(<span style="font-weight: bold">char</span> input) {
 <span style="font-weight: bold">char</span> tmp[1000000];
 <span style="font-weight: bold">switch</span>(input) {
   <span style="font-weight: bold">case</span> <span style="font-style: italic">&#39;X&#39;</span>: {
     strcpy(tmp,<span style="font-style: italic">&quot;X+YF+&quot;</span>);
     <span style="font-weight: bold">break</span>;
   }
   <span style="font-weight: bold">case</span> <span style="font-style: italic">&#39;Y&#39;</span>: {
     strcpy(tmp,<span style="font-style: italic">&quot;-FX-Y&quot;</span>);
     <span style="font-weight: bold">break</span>;
   }
   default: {
     strcpy(tmp, (<span style="font-weight: bold">char</span>[2]) { (<span style="font-weight: bold">char</span>) input, <span style="font-style: italic">&#39;\0&#39;</span> } );
     <span style="font-weight: bold">break</span>;
   }
 }
 <span style="font-weight: bold">return</span> tmp;
}
</pre>
				</div>
				<br>
				<p><code>processString_DragonCurve</code> follows the same logic as <code>processString</code> in the Python. It
					takes in a
					character
					pointer to a string and then iterates on every character to put it through <code>applyRule_DragonCurve</code>.
					The result
					string from each call to <code>applyRule_DragonCurve</code> is concatenated together in memory.
				</p>
				<!-- HTML generated using hilite.me -->
				<div
					style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
					<pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">char</span>* processString_DragonCurve(<span style="font-weight: bold">char</span>* prev) {
	<span style="font-weight: bold">int</span> i = 0;
	<span style="font-weight: bold">char</span> *tmp;
	<span style="font-weight: bold">char</span> *check;
	<span style="font-weight: bold">int</span> length = strlen(prev);
	<span style="font-weight: bold">for</span> (i = 0; i &lt; length; i++) {
		check = prev;
		tmp = applyRule_DragonCurve(prev[i]);
		strcat(prev, tmp);
	}
	<span style="font-weight: bold">return</span> prev;
 }
 </pre>
				</div>
				<br>
				<p><code>createSystem_DragonCurve</code> needs the number of iterations and the starting axiom to function. For
					every number
					in the range [0, <code>numIters</code>-1] it calls <code>processString_DragonCurve</code> on the string from
					the previous
					iteration.</p>
				<!-- HTML generated using hilite.me -->
				<div
					style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
					<pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">char</span>* createSystem_DragonCurve(<span style="font-weight: bold">int</span> numIters, <span style="font-weight: bold">char</span>* axiom) {
 <span style="font-weight: bold">char</span> start[1000000];
 strcpy(start, axiom);
 <span style="font-weight: bold">char</span> end[1000000];
 *end = <span style="font-style: italic">&quot;&quot;</span>;
 <span style="font-weight: bold">int</span> i = 0;
 <span style="font-weight: bold">char</span> *check;
 <span style="font-weight: bold">for</span> (i = 0; i &lt; numIters; i++) {
   check = processString_DragonCurve(start);
   *start = end;
 }
 <span style="font-weight: bold">return</span> start;
}
</pre>
				</div>
				<br>
				<p>Finally, the dragon curve is drawn through the aptly named function <code>draw_DragonCurve</code>. It loops
					through each
					character in the character pointer of the L-System string and checks to see what graphing functionality that
					character possesses. This leans on VGA drawing functions written by Bruce Land.</p>
			</section>
			<!-- HTML generated using hilite.me -->
			<div
				style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
				<pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">void</span> draw_DragonCurve(<span style="font-weight: bold">char</span>* input, <span style="font-weight: bold">int</span> old_x, <span style="font-weight: bold">int</span> old_y) {
 <span style="font-weight: bold">int</span> a = 0; <span style="font-style: italic">// 0 degrees is straight up vertically</span>
 <span style="font-weight: bold">int</span> length = 10;
 <span style="font-weight: bold">int</span> new_x = old_x;
 <span style="font-weight: bold">int</span> new_y = old_y;
 <span style="font-weight: bold">int</span> i = 0;
 <span style="font-weight: bold">char</span> *check = input;
 printf(<span style="font-style: italic">&quot;GRAPHING STRING: &quot;</span>);
 <span style="font-weight: bold">while</span>(*check!=<span style="font-style: italic">&#39;\0&#39;</span>)
     printf(<span style="font-style: italic">&quot;%c&quot;</span>,*check++);
   printf(<span style="font-style: italic">&quot;</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
 <span style="font-weight: bold">for</span> (i = 0; i &lt; strlen(input); i++) {
   <span style="font-weight: bold">if</span>(input[i] == <span style="font-style: italic">&#39;X&#39;</span>) {
     <span style="font-weight: bold">continue</span>;
   } <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (input[i] == <span style="font-style: italic">&#39;Y&#39;</span>) {
     <span style="font-weight: bold">continue</span>;
   } <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (input[i] == <span style="font-style: italic">&#39;F&#39;</span>) {
     <span style="font-weight: bold">if</span> (a % 360 == 0) {
       VGA_line(new_x, new_y, new_x, new_y - length, red);
       new_x = new_x;
       new_y = new_y - length;
     } <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (a % 270 == 0) {
       VGA_line(new_x, new_y, new_x - length, new_y, yellow);
       new_x = new_x - length;
       new_y = new_y;
     } <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (a % 180 == 0) {
       VGA_line(new_x, new_y, new_x, new_y + length, red);
       new_x = new_x;
       new_y = new_y + length;
     } <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (a % 90 == 0) {
       VGA_line(new_x, new_y, new_x + length, new_y, yellow);
       new_x = new_x + length;
       new_y = new_y;
     }
   } <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (input[i] == <span style="font-style: italic">&#39;+&#39;</span>) {
     a = a + 90;
   } <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (input[i] == <span style="font-style: italic">&#39;-&#39;</span>) {
     a = a - 90;
   }
 }
}
</pre>
			</div>

		</div>
		<br id="full-system">
		<div class="box container">
			<section>
				<h2>Full-System Design</h2>
				<h3>Structure</h3>
				<p>Boasting a faster internal clock and configurable hardware, the FPGA is the core computational power for the
					system. This power is directed towards two main functionalities: calculating the L-System and graphing the
					L-System. The former relies on string manipulation, while the latter uses enable and address signals to write
					to the VGA screen. Since this system serves two distinct purposes, it was useful to split each into a separate
					Verilog file: <code>rules.v</code> for the calculations and <code>DE1_SoC_Computer.v</code> for the graphing.
					This modular approach not
					only made it simpler to visualize how each module connects, but it also made the testing process easier to
					take step by step.</p>
				<p>The C code running on the ARM side establishes the serial input control for the L-System’s settings, such as
					the L-System in question and the starting coordinates for graphing. There was the opportunity to use this for
					graphing as well, but the bandwidth and PIO port size limitations would’ve hindered our speedup. There was the
					additional thought of housing the L-System calculations on the ARM side, but this was also scrapped due to the
					FPGA’s faster clock frequency and opportunity for large amounts of data to be stored through M10Ks.</p>
				<p>Bridging the gap between the ARM and FPGA is the Avalon bus, visualized and configured using QSYS. The ARM
					takes in settings from the user and outputs them to the FPGA through output PIO ports, while the FPGA sends
					over timing information through an input PIO port. These ports have to be programmed on both ends; the ARM
					code memory maps their address spans, and the FPGA instantiates wires to connect the ports of the ARM module
					(called <code>Computer_System</code> in the Verilog) to relevant inputs/outputs in Verilog modules.</p>
				<p>The interweaving of these two technologies and the emphasis on each system’s strengths led to the development
					of responsive, visualizable L-Systems. Figure XX below shows how each connects via input and output signals
					and wires.</p>
				<img src="images/signalblockdiagram.png" style="display:block;margin: 0 auto; width:70%; height:70%">
				<p style="text-align: center;"><i>Figure 1: Block Diagram of signal flow between modules.</i></p>
				<br>
				<h3>Computation</h3>
				<p>The bulk of the code used to create these L-Systems is found in <code>rules.v</code> across four modules:
					<code>dual_clock_ram</code>,
					<code>signed_mult</code>, <code>rules</code>, and <code>create_system</code>.
				</p>
				<h4>dual_clock_ram</h4>
				<p><code>dual_clock_ram</code> is the memory unit of our system that allows our system to be recursive. Each
					instantiation of
					the module is composed of eight M10k blocks in a 8-bit by 8K configuration, with each block holding one of the
					eight blocks. The module performs one cycle writes and two cycle reads. Thus, in the cycle that a memory
					operation is called, a write would finish the following cycle, and a read would finish after the second
					positive edge of the clock. However, it is possible for these memops to still take the same amount of time
					because the read and write operations are processed on different clocks, both of which are taken as inputs
					(<code>clk1</code>, <code>clk2</code>). The other inputs are write enable (<code>we</code>),
					<code>read_address</code>, <code>write_address</code>, and write data (<code>d</code>). The
					sole output is read data (<code>q</code>). When graphing, this module is the limiting factor for the number of
					iterations
					which can be performed. With a fixed memory size, at some point, we will run out of space to write a new
					iteration. We settled on 8K memory locations because we calibrated our system to fit a 10-11 iteration dragon
					curve.
				</p>
				<h4>signed_mult</h4>
				<p>This module performs 11.21 fixed point signed multiplication. This means that there are 11 bits of integer
					and 21 bits of decimal in the inputs and output. Our reasoning behind 11.21 for the fixed point representation
					was that there were ample integer bits, so as to avoid overflowing during computation. For the purposes of
					this project, we felt the ranges of integer and floating point provided good resolution. This module is
					instantiated in our top level code for use in calculating the necessary vertical distances for diagonal lines.
				</p>
				<h4>rules</h4>
				<p><code>rules</code> is a clocked module which applies a specific update rule to an input character.
					Specifically it takes
					in an 8-bit character, and, depending on the specified L-system, will convert the input to an up to ten
					character output string. To interpret the character inputs properly, the alphabet of all valid characters for
					the available L-systems is defined with local parameters. The module operates by sitting in an initial wait
					state until a valid signal is asserted, indicating that the input is valid. The module then transitions to the
					appropriate update state depending on the input L-system signal. Within the specified state, only the rules of
					that system are available. If there exists a rule for that character, the corresponding conversion will be
					written to the result. If not, then the character is written to the result with 72 zeros appended to the end
					to fit the ten character buffer size.
				</p>
				<img src="images/rules_fsm.png" style="display:block;margin: 0 auto; width:95%; height:95%">
				<p style="text-align: center;"><i>Figure 2: Diagram of the Finite State Machine used to apply rules to each
						character.</i></p>
				<p>This scheme makes it fairly easy to add new L-Systems. We merely have to expand the alphabet and add an extra
					state to handle this new case. Below are examples of some of the systems we generated. We currently have 7
					systems encoded. They are the dragon curve, two versions of the Sierpinski arrowhead, Koch curve, Koch
					snowflake, cross, and tessellated triangle.</p>
				<img src="images/dragon_11iter_4length,300,300.png" style="display:block;margin: 0 auto; width:70%; height:70%">
				<p style="text-align: center;"><i>Figure 3: The Dragon Curve with 11 iterations (the largest possible in our
						implementation), with a length of 4, graphed in the center of the screen (300,300).</i></p>
				<br>
				<img src="images/arrow2_6iter_7length,300,300.png" style="display:block;margin: 0 auto; width:70%; height:70%">
				<p style="text-align: center;"><i>Figure 4: Sierpinski Arrowhead (2), with 6 iterations, a length of 7, graphed
						in the center of the screen (300,300).</i></p>
				<br>
				<h4>create_system</h4>
				<p><code>create_system</code> in particular does the heavy lifting, instantiating two
					<code>dual_clock_ram</code> modules and
					one <code>rules</code>
					module in order to receive a 32-bit axiom, perform the calculations necessary to convert that starting string
					into a set of characters representing a fractal of that requested L-System, and output the entire result
					string byte by byte to the top level.
				</p>
				<p><code>create_system</code> requires a plethora of input and output values in order to function. The typical
					one bit <code>clk</code>
					and <code>reset</code> signals are inputs to the system, dictating when the internal FSM is allowed to restart
					and at what
					frequency it can run. <code>system_input_string</code> is the starting axiom, limited to 32 bits due to the
					maximum width
					of the PIO ports sending over this string from the HPS. A three bit signal <code>lsystem</code> chooses which
					of the seven
					L-Systems to calculate and graph, and four bit value <code>iterations</code> provides the number of recursive
					iterations
					the L-System will be required to make. As the module hops from state to state,
					<code>system_output_string</code> is set to
					a byte of the outputted result in order to somewhat parallelize the math being performed with the graphing
					being done. <code>iterations_counter</code> is another output, this time four bits; it’s updated to be equal
					to the
					iteration <code>create_system</code> is on so as to let the top level know when it’s appropriate to graph.
				</p>
				<p>The handshake interface between <code>create_system</code> and the top level FSM for graphing worked with
					four signals:
					<code>top_rdy</code>, <code>top_graphing</code>, <code>system_val</code>, and <code>system_done</code>. Those
					outputted by the top level—<code>top_rdy</code> and
					<code>top_graphing</code>—were received as inputs, indicating that the top level was ready for the next byte
					to be graphed
					and in what stage of graphing the top level was in, respectively. <code>system_val</code> and
					<code>system_done</code> are outputs, set
					appropriately to show that there’s a new valid output from <code>create_system</code> and that
					<code>create_system</code> has completed
					its L-System entirely.
				</p>
				<p>Two <code>dual_clock_ram</code> modules are instantiated to hold the L-System as it passes through every
					iteration. The
					first loop through the L-System string is performed on the axiom, which is a hard-coded value set by the user
					through the HPS. The expanded result string, created by running each character through the <code>rules</code>
					module, is
					then stored in an M10K block connected to one of the <code>dual_clock_ram</code> modules (let’s call it A).
					The next
					iteration takes this processed result string from A, runs each character through the <code>rules</code>
					module, and stores
					the new result in an M10K block created by the other <code>dual_clock_ram</code> module (designated as B).
					From then on,
					every iteration of <code>create_system</code> will read the previous iteration’s result from one
					<code>dual_clock_ram</code> and write
					the result to the other, alternating between A being read and B being written to B being read and A being
					written. Considering that <code>iterations_counter</code>—the register used to keep track of the
					iterations—starts at zero,
					here’s a simple rule of thumb: every even iteration writes to A and reads from B (except in the case of the
					zeroth iteration, which reads from axiom), and every odd iteration writes to B and reads from A. The
					<code>dual_clock_ram</code> modules will be referred to as A and B from now on.
				</p>
				<p>Aptly named <code>rule</code>, an instance of the <code>rules</code> module is connected to the appropriate
					inputs and internal
					registers. It needs the <code>lsystem</code> input to choose the correct L-System rules to apply to each
					character of the
					L-System string, the character in question (stored in <code>input_char</code>), and a valid signal
					<code>rule_val</code> to
					indicate the
					next character is ready to be processed. It outputs a maximum 80 bit value to <code>rule_result</code> after
					applying the
					relevant L-System rules to <code>input_char</code>, and a done signal <code>rule_done</code> used to
					acknowledge that it’s
					done
					processing.
				</p>
				<p>The mechanism propelling the creation of the requested L-System is composed of 13 states, as seen in the FSM
					below. The state logic and transitions are handled within an always block clocked on the positive triggering
					edge of the <code>clk</code> signal.</p>
				<img src="images/create_system_fsm.png" style="display:block;margin: 0 auto; width:95%; height:95%">
				<p style="text-align: center;"><i>Figure 5: Diagram of the create_system Finite State Machine.</i></p>
				<br>
				<p>The <code>reset</code> signal is active high and is sent across the PIO ports from the HPS once the user has
					configured
					all of the desired characteristics of the L-System. On reset, all of the internal registers (most notably the
					read/write addresses and write enables of both A and B, and the <code>system_done</code> signal) are cleared
					and
					<code>system_input_string</code> is loaded into the <code>axiom</code> register. The defined
					<code>RESET_SYSTEM</code> does this as well. The
					difference between the actions triggered by the <code>reset</code> signal and the <code>RESET_SYSTEM</code>
					state is that
					the former
					only occurs once at the very beginning of the program, and the latter is what the FSM returns to after
					completing an L-System and waiting for the next request from the user.
				</p>
				<p>Both the <code>reset</code> signal condition and <code>RESET_SYSTEM</code> transition to
					<code>CLEAR_M10KS</code> (though the latter
					waits until
					reset is high again, indicating the new L-System characteristics have been sent from the HPS). Since the
					L-System strings during and between iterations are stored in M10K blocks, it’s necessary to clear them before
					embarking on the next L-System. Until the write address values for A and B have reached the last possible
					memory address 0h1FFF (8191 in decimal), both write enable signals are set to one and the data values set to
					zero. This will result in every byte of the M10Ks being set to 8’b0. The state stays within itself until this
					process is complete, then moves on to <code>GET_CHAR</code>.
				</p>
				<p><code>GET_CHAR</code> is responsible for grabbing the next character in the string to pass into the
					<code>rule</code>
					module. However,
					it must wait until the top level is ready (equivalent to the top level finishing graphing the previous
					character sent over from <code>create_system</code>) so it doesn’t set the value of <code>input_char</code>
					for the <code>rules</code>
					module until
					the <code>top_rdy</code> signal is set to one. When this condition is met, how the state proceeds depends on
					what iteration
					the system is on, shown in <code>iterations_counter</code>. If the system is on the zeroth iteration, the
					hardcoded <code>axiom</code>
					is being processed so <code>input_char</code> is the least significant (rightmost) byte of <code>axiom</code>
					and the FSM can
					immediately transition to <code>COMPUTE_DRAGON</code>. If the system hasn’t reached the inputted value of
					iterations, it
					proceeds to <code>READ_M10K</code> to read a byte from the string written to either A or B’s M10K memory. If
					the system has
					performed the required number of iterations, the FSM goes to <code>DONE</code>.
				</p>
				<p><code>READ_M10K</code> chooses which set of M10Ks to read from based on whether
					<code>iterations_counter</code> is even or odd. Based
					on the setup of the <code>dual_clock_ram</code>, there’s no read enable signal; instead it takes three cycles
					to read the
					requested address in the M10K. Originally, we thought this meant our FSM would require some number of buffer
					states to ensure three clock cycles passed before the value was ready to be used, but the fact that our FSM is
					13 states means that enough time passes between individual characters being processed to absorb those three
					clock cycles. We take advantage of this by incrementing the read address for the appropriate
					<code>dual_clock_ram</code>
					module within <code>READ_M10K</code> based on whether <code>iterations_counter</code> is even or odd. Since
					this is the
					only state to
					change the value of the read addresses, A and B will read at their corresponding incremented address and the
					value at that address will be ready to grab the next time the FSM goes to <code>READ_M10K</code>.
				</p>
				<p>Whether from <code>GET_CHAR</code> directly or <code>READ_M10K</code>, the next state of the FSM is
					<code>COMPUTE_DRAGON</code>. Don’t
					let the name
					fool you, as this state is responsible for getting the resulting output from applying any of the seven
					L-System rule configurations, not just that of the dragon curve. The <code>rule_val</code> signal is set to
					tell <code>rule</code> that
					another character is on its way, and <code>rule_result</code> is stored in another register to be shifted in
					future states
					of the FSM. While the done signal <code>rule_done</code> is equal to zero, the FSM stays in
					<code>COMPUTE_DRAGON</code>,
					waiting for the
					<code>rule</code> module to finish processing the character. When this isn’t the case, it’s time to write the
					result to the
					M10Ks: A through state <code>WRITE_M10K_A</code> if <code>iterations_counter</code> is even, or B through
					state
					<code>WRITE_M10K_B</code> if
					<code>iterations_counter</code> is odd.
				</p>
				<p><code>WRITE_M10K_A</code> and <code>WRITE_M10K_B</code> are identical, save for the fact that they’re dealing
					with two different
					<code>dual_clock_ram</code> modules. As each memory location in the M10Ks is a byte wide, we take the most
					significant
					(leftmost) byte of <code>rule_result_reg</code> (note that this is not <code>rule_result</code>) and load it
					into either A or B’s data
					register as well as <code>system_output_string</code>. Every rule applied to the characters can output a
					maximum of ten
					bytes from a single byte input, so it takes multiple cycles to write the entirety of
					<code>rule_result_reg</code> to the
					M10Ks. The simplest way to keep track of which bytes had been written back and which ones hadn’t is by
					shifting out each byte of <code>rule_result_reg</code> after it’s written to its appropriate location in the
					M10Ks. Hence,
					we know the entirety of the output from rule is stored in memory once <code>rule_result_reg</code> equals 80
					bit zero; in
					this case, the write enable is set low so as to not accidentally write to any extra memory locations,
					<code>system_val</code> is set low to indicate that there isn’t a character to be graphed by the top level,
					and the FSM
					transitions to <code>NEXT_BYTE</code>. If there are more bytes in <code>rule_result_reg</code> to write to the
					M10Ks, the
					write enable
					is set high and the <code>top_rdy</code> is checked. <code>top_rdy</code> lets <code>create_system</code> know
					when the top
					level has
					finished
					handling the previous character sent to it and is ready for the next. When <code>top_rdy</code> is high,
					<code>system_val</code> is set
					high in response to say “Hey, we have a new character ready for you!” and the FSM transitions to
					<code>INCREMENT_WRITE_A</code> (or <code>INCREMENT_WRITE_B</code> when in <code>WRITE_M10K_B</code>, writing
					to the B <code>dual_clock_ram</code>).
					Otherwise,
					<code>system_val</code> is kept low and the FSM stays within <code>WRITE_M10K_A</code>.
				</p>
				<p>The goal for this val/rdy handshake is to not let one part of the system get ahead of the other. We don’t
					want <code>create_system</code> to continue chugging along with processing and storing the result string
					before the top
					level is done with the previous character. We also don’t want the top level to graph a character that isn’t
					ready yet, lest it mess up the final design of the L-System.</p>
				<p>Much like <code>WRITE_M10K_A</code> and <code>WRITE_M10K_B</code>, <code>INCREMENT_WRITE_A</code> and
					<code>INCREMENT_WRITE_B</code> are the same except for what
					<code>dual_clock_ram</code> they’re interfacing with. This state is responsible for incrementing either A or
					B’s write
					address so that the next time the FSM is in <code>WRITE_M10K_A</code> or <code>WRITE_M10K_B</code> it knows to
					write to the next
					available location in memory. It’s also responsible for shifting <code>rule_result_reg</code>. Since the
					baseline Python
					code looped across each string from left to right, so does this Verilog implementation by shifting the
					leftmost byte out. The FSM immediately transitions back to <code>WRITE_M10K_A</code> or
					<code>WRITE_M10K_B</code>.
				</p>
				<p>After the entirety of <code>rule_result_reg</code> has been stored in the appropriate
					<code>dual_clock_ram</code> module,
					<code>NEXT_BYTE</code> is
					responsible for shifting <code>axiom</code> in a similar fashion to <code>rule_result_reg</code>. As described
					earlier,
					<code>axiom</code> holds the
					32 bit hardcoded axiom for the L-System and is the starting point for the zeroth iteration of
					<code>create_system</code>.
					Once every character of <code>axiom</code> has gone through the <code>rules</code> module, it can be shifted
					out because
					there is no use
					for it anymore—its result is all the system needs to remember about it, and that’s already been written to the
					M10Ks. In any iteration besides the zeroth, this acts more like a buffer state than anything else, but it also
					serves to hold the <code>system_val</code> and <code>system_done</code> signals low, which are easy to lose
					track of.
				</p>
				<p>The next state is <code>INCREMENT_ITER</code>; as the name implies, it’s responsible for incrementing the
					value of
					<code>iterations_counter</code> once the entirety of the string has been processed. There are many checks that
					must be done
					before this simple task can happen, since there are multiple cycles within the FSM and the iterations
					themselves are cycles. First, <code>system_output_string</code> must be zero, <code>axiom</code> must be zero,
					and
					<code>top_graphing</code> must be
					two. <code>system_output_string</code> being zero means that the last value of <code>rule_result_reg</code> is
					zero and the
					entirety of
					the string has been processed and shifted out, with <code>system_output_string</code> lagging and grabbing an
					extra byte of
					<code>rule_result_reg</code> in <code>WRITE_M10K_A/B</code> while waiting to go to <code>NEXT_BYTE</code>.
					<code>axiom</code> is zero once the zeroth
					iteration
					has reached its end, so this check makes sure that the system has at least gotten through that.
					<code>top_graphing</code>
					is an input from the top level showing what state of graphing the top level is in: 0 before a character is
					graphed, 1 during graphing, and 2 post-graphing. A value of 2 means that the last character sent over by
					<code>create_system</code> has been fully graphed. The next check depends on <code>iterations_counter</code>:
					if it’s zero,
					no
					additional logic is needed; if it’s even, B needs to be reading a value of zero; and if it’s odd, A needs to
					be reading a value of zero. This is a check to see if there are more bytes to be read and processed from the
					M10Ks (hence why on the zeroth iteration this doesn’t require any logic) since all bytes in the M10Ks
					following the last byte of the processed string will be zero (as promised by <code>CLEAR_M10KS</code>). If
					those hurdles
					are cleared, it’s time for <code>iterations_counter</code> to be incremented and the write addresses for both
					<code>dual_clock_ram</code> modules to be zeroed out. This ensures that the next iteration will write the
					result from the
					top of the M10Ks, overwriting the previous iteration and even going past that (since every iteration grows the
					string in length). The next state will be <code>ZERO_READ</code> if all of the conditionals are true,
					otherwise no logic is
					performed at all and the FSM heads back to <code>GET_CHAR</code> to start the processing and storing of the
					next character
					in the string.
				</p>
				<p><code>ZERO_READ</code> is also self-explanatory: it zeroes the read addresses for the
					<code>dual_clock_ram</code> modules.
					The read
					address for B is only set to zero if the system is on an even-numbered iteration, otherwise the read address
					for A is set to zero. This state transitions to <code>GET_CHAR</code>.
				</p>
				<p>The last state of the FSM is <code>DONE</code>. Its primary function is to set the <code>system_done</code>
					signal to one
					in order to
					let the top level know not to expect any more characters from <code>create_system</code> as it has completed
					the requested
					number of iterations over the L-System string. The read/write addresses for A and B are set to zero to prepare
					to handle the next L-System after heading back to <code>RESET_SYSTEM</code>.</p>
				<h3>Graphing</h3>
				<p>Our top level, <code>DE1_SoC_Computer.v</code>, serves as the bridge between the user inputs and the
					<code>create_system</code> module.
					In addition, it holds the graphing finite state machine.
				</p>
				<p>Writing to the VGA screen utilizes three signals: <code>vga_sram_write</code>, <code>vga_sram_address</code>,
					and <code>vga_sram_write</code>
					is a one bit write enable signal—if it’s 1, the VGA will be written to. <code>vga_sram_address</code> is a
					32 bit value attributed to an address in the space of the screen, where the base address is 32’b0.
					<code>vga_sram_writedata</code> is an eight bit value corresponding to the data to be written at
					<code>vga_sram_address</code>,
					specifically the color of the pixel located at that address.
				</p>
				<p>The output PIO ports (from the ARM to the FPGA) allow for user interaction through the terminal to change the
					<code>lsystem</code>, <code>axiom</code>, number of iterations, length and color of lines, as well as the
					initial coordinates, <code>start_x</code>
					and <code>start_y</code>. There is also an output PIO port that sends the <code>reset</code> signal, driven by
					the HPS. In
					addition, an
					input PIO port sends <code>timer_counter</code> from the FPGA to the ARM in order to calculate the timing
					information of
					the system.
				</p>
				<p>We instantiate a module of <code>create_system</code> to send over required values. Particularly, the
					<code>top_rdy</code>
					and
					<code>system_val</code> wires allow for a handshake between the modules, so that the top level FSM does not
					start graphing
					too early.
				</p>
				<img src="images/trig_sketch.png" style="display:block;margin: 0 auto;">
				<p style="text-align: center;"><i>Figure 6: Annotated diagram of an equilateral triangle, to demonstrate our
						calculations for 60° diagonal lines.</i></p>
				<p>There is also an instantiation of <code>signed_mult</code>, called <code>triangle_mult</code>, which
					calculates the target pixel
					required for the 60° based diagonal lines. Remembering trigonometry, we know that the horizontal step size is
					<code>length</code>/2, which can be calculated by shifting <code>length</code> by 1. However, the vertical
					step size is
					sqrt(3)<code>length</code>/2,
					which cannot be so easily calculated with bitwise operations. Thus, we use 11.21 fixed point multiplication.
					The inputs to this module are <code>root_three</code> (sqrt(3) represented in 11.21 fixed point), and
					<code>x_triangle_length</code>,
					the 11.21 fixed point version of <code>length</code> >> 1. The output is <code>y_triangle_length</code>. For
					use in
					graphing to pixels,
					the integer bits [30:21], are used in calculations. These bits omit the signed bit in the fixed point integer,
					which causes a limitation in calculation values off off the screen in the negative direction.
				</p>
				<img src="images/top_level_fsm.png" style="display:block;margin: 0 auto; width:95%; height: 95%">
				<p style="text-align: center;"><i>Figure 7: Diagram of the top level (graphing) Finite State Machine.</i></p>
				<br>
				<p>The 10 state top level FSM is triggered on the positive rising edge of the 50MHz clock. We consider this FSM
					to be modular—as in, some states are chosen based on which L-System is being graphed.
					<code>timer_counter_reg</code> is
					incremented in every state except for <code>TOP_RESET</code> and <code>TOP_DONE</code>, to provide timing
					information for the whole
					system.
				</p>
				<p>The first state is <code>TOP_RESET</code>, which is entered at the <code>reset</code> signal from the HPS. In
					this state,
					<code>angle_increment</code> is set based on what is required for the <code>lsystem</code> entered. If the
					<code>reset</code> signal is
					sent again,
					the FSM will stay in this state. Otherwise, it will move onto <code>TOP_WAIT</code>.
				</p>
				<p>In <code>TOP_WAIT</code>, the <code>system_done</code> wire from <code>create_system</code> is checked. If it
					is high, the
					FSM moves
					into the
					<code>TOP_DONE</code> state. If not, there are two conditions. If the <code>system_val</code> wire is low, the
					<code>top_rdy_reg</code>
					is set high,
					and the FSM stays in <code>TOP_WAIT</code>. If <code>system_val</code> is high, <code>top_rdy_reg</code> is
					set low,
					<code>system_output_string_reg</code> is set
					based on the <code>system_output_string</code> wire from <code>create_system</code>, and the FSM moves into
					<code>TOP_SETUP</code>.
				</p>
				<p>
					The <code>TOP_SETUP</code> state is used to make sure all relevant registers have the most updated values. In
					particular,
					<code>top_char_reg</code> is set to <code>system_output_string_reg</code>, so that graphing rules can be
					applied to this character in
					the following state. The FSM then moves on to <code>TOP_TARGET</code>.
				</p>
				<p>In <code>TOP_TARGET</code>, either the target pixels (<code>targetx_reg</code> and <code>targety_reg</code>)
					or the
					direction of drawing (<code>angle_reg</code>)
					are set based on what <code>top_char_reg</code> is. For the drawing characters (F and A),
					<code>targetx_reg</code> and
					<code>targety_reg</code> are
					set based on <code>angle_reg</code>; If <code>angle_reg</code> is 0 or 180 (vertical) or 90 or 270
					(horizontal), either <code>targetx_reg</code> or
					<code>targety_reg</code> are incremented by <code>length</code>. If <code>angle_reg</code> is 60, 120, 240, or
					300, a
					diagonal line is needed, and
					the target coordinates are instead incremented using the step sizes calculated using the
					<code>signed_mult</code> module
					(<code>x_triangle_length</code> and <code>y_triangle_length</code>). If <code>top_char_reg</code> is either +
					or -, <code>angle_reg</code> is incremented or
					decremented by the <code>angle_increment</code> value set in <code>TOP_RESET</code>. In cases where the
					resulting angle would be set to
					360, it is reset to 0 for ease in future calculations. Next, the FSM goes into <code>TOP_BOUND_CHECK</code>.
				</p>
				<p><code>TOP_BOUND_CHECK</code> chooses which graphing state to go to based on what <code>lsystem</code> is. It
					also chooses
					to skip the
					graphing states if the target coordinates are outside of the screen, and go directly to
					<code>TOP_SHIFT</code>.
				</p>
				<p>
					All three graphing states do an additional check on the bounds, and set the write enable,
					<code>vga_sram_write</code> low
					in the case of an offscreen pixel. This allows for a line with target coordinates outside the graphing region
					to draw up until the edges of the screen.
				</p>
				<p><code>TOP_GRAPH_DRAGON</code> is named after our first successfully implemented <code>lsystem</code>, the
					dragon curve,
					and is the
					graphing state for purely horizontal and vertical lines. In this state, either <code>x_reg</code> or
					<code>y_reg</code> is
					incremented
					in each cycle until the graphed coordinates match the target coordinates. To graph to the screen,
					<code>vga_sram_address</code> is set to the desired coordinates, <code>vga_sram_writedata</code> is set to the
					color chosen
					by the user,
					and <code>vga_sram_write</code> is set high. Once the coordinates match, the FSM will move on to
					<code>TOP_SHIFT</code>.
					However, if
					either the <code>x_reg</code> or <code>y_reg</code> value exceeds (2^32)-1 (the maximum value that can be held
					in the 32 bit addresses),
					the FSM will immediately enter <code>TOP_DONE</code>.
				</p>
				<p><code>TOP_GRAPH_TRIANGLE_X</code> and <code>TOP_GRAPH_TRIANGLE_Y</code> are the graphing states used for
					L-Systems that require
					diagonal lines. These states cycle between each other to graph 2 pixels horizontally and 5 pixels vertically,
					and move on to <code>TOP_SHIFT</code> once the graphed coordinates has passed or is equal to the target
					coordinates. This
					is a limiting way to graph diagonal lines, as it requires that the minimum side length is at least 7 to result
					in a line that is reasonably diagonal. However, constrained by the pixels on the screen, we found this to be a
					fairly accurate way to draw lines with our desired slope.</p>
				<p>The <code>TOP_SHIFT</code> state sets the <code>top_graphing_reg</code> to 2. This is a wire checked by
					<code>create_system</code> before
					incrementing <code>iterations_counter_reg</code>. After this state, the FSM returns to <code>TOP_WAIT</code>.
				</p>
				<p>The final state in the top level graphing FSM is <code>TOP_DONE</code>. At this point, all graphing for the
					inputted
					L-System has been completed, and the final value of <code>timer_counter_reg</code> is used for the timing
					calculations. The
					FSM will stay in this state until the <code>reset</code> signal is sent by the HPS to bring the FSM back to
					<code>TOP_RESET</code>.
				</p>
				<h3>User Interface</h3>
				<p>As previously mentioned, the HPS handles user inputs as well as printing valuable information to the terminal
					window. This code can be found in <code>graphics.c</code>. Here is an overview of the PIO ports and the
					associated actions
					done by the HPS.</p>
				<p><code>lsystem</code>: before asking for a user input for this 3-bit output PIO port, the HPS prints out the
					available
					L-Systems and the numbers associated with them. If the user enters an invalid character, the prompt is
					replayed.</p>
				<p><code>axiom</code>: Once a valid L-System has been chosen, the HPS asks for a user input for the 32-bit
					output PIO port,
					axiom. Before asking for it, however, the HPS prints some key information to enhance usability, including: the
					default axiom for the chosen L-System, the rule-making characters in that L-System, which characters enable
					drawing for that L-System, and finally, all available characters for use in the axiom. This information allows
					the user to either input the default axiom (without having to look it up), or create their own unique axiom.
				</p>
				<p><code>iterations</code>: This 4-bit output PIO port holds the user inputted value for the number of
					iterations. Table 3
					shows our results for the largest number of iterations for each curve that can be supported by our design.</p>
				<img src="images/max_iterations.png" style="display:block;margin: 0 auto;">
				<p style="text-align: center;"><i>Table 3: Largest number of iterations for each curve that can be drawn in our
						implementation.</i></p>
				<br>
				<p><code>length</code>: This 5-bit output PIO port holds the user inputted value for the length of each line.
					This value’s
					bounds are checked before moving on to the next user input. The maximum value of length is limited by the size
					of the PIO port, so it must be less than 31. While that is the maximum allowed, the user must be cognizant
					that lower values are often needed to project the curve within the graphable region of the screen. The minimum
					length varies based on the chosen <code>lsystem</code>. For L-Systems that rely on purely horizontal and
					vertical lines,
					the minimum length is 3, in order to properly visualize squares. For L-Systems that contain diagonal lines,
					the minimum length is 7, in order to properly visualize the slope of the diagonals.</p>
				<p><code>color</code>: This 8-bit output PIO port holds the user inputted value for the color of the L-System.
					The HPS prints
					out the available 8-colors that have been hardcoded. If the user input does not match any of the options, the
					system defaults to white (0xff).</p>
				<p><code>start_x</code> and <code>start_y</code>: These are 10-bit output PIO ports that hold the initial
					coordinates for graphing.
					<code>start_x</code> is the horizontal coordinate, and is bounded by the left and right sides of the screen (1
					to 638).
					<code>start_y</code> is the vertical coordinate, and is bounded by the top and bottom of the screen (1 to
					478).
				</p>
				<p><code>reset</code>: this 1-bit output PIO port allows the <code>reset</code> signal to be sent to the ARM.
					Once the screen
					is cleared,
					the user can press any key to toggle this signal and begin the graphing process.</p>
				<p><code>timer_counter</code>: This 32-bit input PIO Port receives this value, which was incremented during
					every cycle of
					the top level FSM (except during the states <code>TOP_WAIT</code> and <code>TOP_DONE</code>). This value is
					then scaled from the number
					of cycles of the 50MHz clock to a recognizable time in seconds, which is printed to the terminal screen.</p>
				<p>Once the L-System has been graphed, the user is given the option to either zoom in, zoom out, pan to new
					coordinates, or begin a new L-System. The first three options modify either the <code>length</code> or the
					starting
					coordinates on the C-side of the program, and send the new values to the ARM, where the modified curve is
					re-calculated and graphed again.</p>
			</section>
		</div>
		<br id="testing">
		<div class="box container">
			<section>
				<h2>Testing</h2>
				<p>In the past we’ve suffered from biting off more than what we can chew, aka building a large chunk of the
					project before testing. This wasn’t a trap we’d be able to fall into this time, especially considering that
					this project is our own ideation—there’s no reference code to rely on when debugging. With this in mind, we
					worked through every module carefully and tested thoroughly along the way. We also initially focused our
					efforts on solely the dragon curve, as the 90 degree increments made for more straightforward graphing.
				</p>
				<p>The first hurdle was the <code>rules</code> module. There were multiple ways to structure it: one module per
					L-System to house
					all of its specific rules, one module per character that would select between rules for each L-System, one
					all-encompassing module with every single rule for every single L-System. Ultimately we chose the last design,
					as we realized that it only required a single input wire to be able to toggle between rule implementations for
					different L-Systems. Once that had been decided, we implemented the module as a case statement outputting to a
					statically-sized register. Though we knew we wanted to utilize M10Ks for their storage capabilities, we’ve had
					bad experiences with them in the past and therefore wanted to hammer down our core functionality before
					complicating it with reading/writing to memory.</p>
				<p>We used ModelSim to verify the outputs and intermediate values. The output register was simple to verify as
					it simply needed to be compared to the expected output string of the L-System rule. This result wasn’t being
					sent byte-by-byte either, so there were no timing issues to consider. We did run into the issue of the
					characters not being accepted by the case conditions and instead falling into the default case, a behavior we
					noted through displaying the <code>rule_done</code> signal (which, rather than being a single bit value to
					toggle between
					zero and one, was a two bit signal that was set to a different value in every case). This was solved by
					defining the ASCII codes for each character as strict eight-bit localparams and constraining the module to
					only accept a single character byte at a time.</p>
				<p><code>create_system</code> was originally broken into two modules: <code>create_system</code> and
					<code>process_string</code>. Much
					like the
					baseline code, these separate modules iterated over a string and performed multiple iterations on a string,
					respectively. We decided to combine them into a single module once we began to tackle the issue of graphing
					via the top level. It wouldn’t be feasible to send over the entire result string from
					<code>process_string</code> to the
					top level because we wouldn’t know how large it was. Sending the result string byte by byte, with the top
					level graphing at the same time as the computations, was a viable option, but it would be redundant for both
					<code>create_system</code> and <code>process_string</code> to be handling strings byte by byte. Even more
					critically, we needed to be
					reading and writing to the M10Ks with every iteration, but we weren’t sure about how to have multiple modules
					safely interact with the same M10Ks in parallel. Therefore, we combined the two, resulting in a rat’s nest of
					FSM states and signal wires that we had to debug in ModelSim.
				</p>
				<p>Before the M10Ks were in use, the result string of the overall system was limited to two bytes, hardly enough
					to graph a robust L-System. While our code was operational with those limitations, there was no telling what
					could happen once we allowed it to perform multiple iterations on a larger axiom. Writing to the M10Ks takes
					multiple cycles per character since we have to write each byte to its own individual address, and reading from
					the M10Ks requires at least three clock cycles as a buffer. ModelSim was extremely useful when debugging the
					<code>WRITE_M10K_A/B</code>, <code>INCREMENT_A/B</code>, and <code>READ_M10K</code> states because we could
					not only see what data was being
					read/written but also the address at which this was occurring. Being able to see these signals informed us
					that we didn’t need a separate buffer state for reading, as well as what logic should go into the transitions
					out of <code>WRITE_M10K_A/B</code>.
				</p>
				<p>Initially the axiom was hardcoded in the Verilog to not have to worry about how the terminal serial input was
					being sent over the PIO ports to the FPGA. After we began to connect the C code with the Verilog, a few
					confusing bugs arose. First was the issue of the order of characters in the axiom: when hardcoded, we treated
					the axiom as a normal English string and processed it from left to right, but when looking at the output
					signals in ModelSim we realized that they were flipped with respect to our expected values. Somehow the 32
					bits of the axiom are reversed before the FPGA starts its calculations (we’re still unsure as to why this
					happens, but attribute it potentially to the way memory mapping happens in the C code). In the interest of
					time, we didn’t dig into the root of this problem but instead patched it by grabbing the least significant
					byte of the axiom and shifting each byte out to the right, effectively reading the character string from right
					to left. Another fun behavior to debug was the appearance of unexpected ones in our <code>axiom</code>
					register as we
					shifted out bytes. At first we thought it could be the way we were shifting, so we concatenated a zero byte to
					a substring of the register, but that didn’t fix it. Upon closer inspection of the binary values, we realized
					that the ENTER presses needed to send the serial input was being included in any input string shorter than
					four bytes (the maximum length, as dictated by the PIO ports), and these enter presses didn’t have an ASCII
					code of zero. Our solution was to initialize the character pointer for the axiom to four bytes of ASCII code
					zero (equivalent to four spaces) so that if a byte wasn’t overwritten by the serial input, it wouldn’t affect
					the register’s overall ability to be equal to zero (key in most of our transitions).
				</p>
				<p>At the start of development, the modular nature of our system made it conducive to testing since all of the
					signals were separated from each other and provided a good deal of information gain on their own. The
					introduction of the val/rdy interface between the top level and <code>rules.v</code> complicated our ability
					to use
					ModelSim for debugging purposes since the wire values were held for too long. In the context of our full
					system, ModelSim was useful for debugging the small issues that arose in individual modules but wasn’t a
					viable tool when the system required more than one iteration on the string.</p>
				<p>This is when we pivoted to SignalTap as our primary debugging tool. Though it was disadvantaged in the sense
					that a full compile of the Verilog was needed before SIgnalTap would read the corresponding signals, it was
					able to show the waveform behavior of the real system, including the Verilog and the C code. A caveat with
					this is the space required to store all of the hardware signals. Our design uses a good deal of memory through
					the M10Ks, so there’s a limit to how many data samples SignalTap can acquire. This was a detriment when
					testing multiple iterations, so we had to use shorter axioms and a smaller number of iterations. The
					discrepancies in string generation ended up stemming from smaller issues within the modules (such as the ASCII
					code problem) but not being able to see all of the clock cycles for more than four or five iterations made
					debugging more difficult.</p>
				<p>This was especially relevant for M10K debugging, as there was a time when it seemed as though the string
					being written to memory was much longer than the expected string, a problem that was exacerbated in higher
					iterations. We weren't sure if it was a problem with our M10K states or M10K memory being cleared. After
					noticing that this appeared on L-Systems after the first one (so not immediately after the entire board was
					reset), we moved our <code>CLEAR_M10KS</code> state from the end of the FSM (after the <code>DONE</code>
					state) to the beginning.
					Additionally, we realized that as we grew the M10Ks we didn’t adjust the last address to which the M10K needed
					to be cleared, so <code>CLEAR_M10KS</code> was only clearing part of memory (a pretty big problem since the
					number of
					iterations is incremented when an address holding a zero is reached in the M10Ks). This is a problem we had
					throughout our usage of the M10Ks, as originally they were coded to have 256 memory address (meaning each
					address needed eight bits) and when we expanded them to 512, 1024, and eventually 8192 we didn’t always adjust
					the bit widths of the read/write memory addresses.</p>
				<p>In regard to the top level, we were able to use the printouts to the VGA screen to debug our graphing;
					particularly, this was helpful as we began to implement diagonal lines. We had decided that we would use
					fixed-point signed multiplication to calculate our target pixel, and use incremented horizontal and vertical
					pixels in an approximate ratio to draw lines that would appear diagonal. Our setup included separate states
					for horizontal and vertical drawing, and they would alternate between each other based on a counter variable
					(<code>xcounter</code> and <code>ycounter</code>). Other than a brief stint where we were accidently assigning
					50-bits to one of our
					32-bit fixed point variables (which caused diagonal lines to wrap all across the screen), this was mostly
					smooth sailing. Eventually, we realized that our lines were not exactly the right slope for a 60° line, and
					determined that we had swapped the bound check for <code>xcounter</code> and <code>ycounter</code>. </p>
				<p>Overall, the focus on developing modular functionality made debugging a more approachable task. ModelSim and
					SignalTap also made looking closely at every single input, output, and intermediate value only slightly
					frustrating.</p>
			</section>
		</div>
		<br id="future">
		<div class="box container">
			<section>
				<h2>Future Work</h2>
				<p>There are several things that could be improved or expanded upon in future implementations of this project.
					First and foremost, we would refactor the top level coordinate calculations to include signed rather than
					unsigned variables. While graphing to the screen only requires positive pixel values, we found that
					calculations outside of the range of the screen would increase graphing robustness, as it would allow for the
					fractal to return to the screen if it curves back into the graphable region. Currently, our implementation
					supports calculations involving positive pixels outside the graphable region (i.e. the bottom and right side
					of the screen), but we encounter overflow for pixels in the negative direction (i.e. the left side and top of
					the screen).</p>
				<p>Furthermore, in order to graph more robust diagonal lines, Bresenham’s line algorithm could be implemented.
					This algorithm would create smooth diagonal lines, and allow us to explore more L-systems based on different
					angle turns (such as 45° or 36°). </p>
				<img src="images/levy.png" style="display:block;margin: 0 auto; width: 60%;height: 60%;">
				<br>
				<img src="images/pentaplexity.png" style="display:block;margin: 0 auto;width: 60%;height: 60%;">
				<br>
				<p style="text-align: center;"><i>Figure 8: (A, top) Levy Curve, based on 45° angle turns. (B, bottom)
						Pentaplexity, based on 36°angle turns.</i></p>
				<p>We would also be interested in exploring further user-customization of L-Systems. While the current system
					allows for customizable axioms, this could be expanded to allow users to create unique L-Systems with custom
					rules and customizable angle turns. This would provide ease for researchers (or other people interested in
					fractals) to develop new L-Systems.</p>
			</section>
		</div>
		<br id="results">
		<div class="box container">
			<section>
				<h2>Results</h2>
				<p>The following are some of the performance metrics of our system. Across the board, the FPGA exhibits a faster
					computation time than the baseline Python script. For the maximum number of iterations on each of our 6
					L-systems, the worst speedup was 5.1x, and the best was 77.8x with an average of about 20.04x. This is due to
					a number of factors including the line length and growth rate.</p>

				<img src="images/Tessellated Triangle (2).png" style="display:block;margin: 0 auto;">
				<p style="text-align: center;"><i>Figure 9: Execution time per character vs. Number of Iterations. Comparing the
						performance between the Python and FPGA when graphing the Tessellated Triangle.</i></p>
				<br>
				<p>Let’s take a <a href="images/look_at_this_graph.gif">look at this graph</a> above. This chart shows the
					execution time per character for the Python and
					FPGA calculating the tessellated triangle. It appears that for the FPGA, there is some initial overhead with
					the first few iterations. This overhead is nullified by the law of large numbers at higher iterations,
					allowing the FPGA to settle to around 200 us per character for both the length 7 and length 10 versions.
					However, this does not appear to be the case for the Python code. The length 7 code takes about 3.6 ms per
					character, while the length 10 code takes 17ms. Additionally, although this is merely an observation,
					generally, the less iterations it takes to fill up the M10K blocks, i.e. a higher growth rate, the larger the
					disparity between the Python and FPGA.
				</p>
				<img src="images/dragon_11iter_4length,300,300.png" style="display:block;margin: 0 auto;">
				<p style="text-align: center;"><i>Figure 10: The Dragon Curve with 11 iterations (the largest possible in our
						implementation), with a length of 4, graphed in the center of the screen (300,300).</i></p>
				<img src="images/Dragon Curve.png" style="display:block;margin: 0 auto;">
				<p style="text-align: center;"><i>Figure 11: Execution time per character vs. Number of Iterations. Comparing
						the performance between the
						Python and FPGA when graphing the Dragon Curve</i></p>
				<br>
				<img src="images/arrow1_5iter_10length,300,450.png" style="display:block;margin: 0 auto;">
				<p style="text-align: center;"><i>Figure 12: Sierpinski Arrowhead (1) with 5 iterations with a length of 10,
						graphed starting at (300,450).</i></p>
				<img src="images/Sierpinski Arrowhead (1).png" style="display:block;margin: 0 auto;">
				<p style="text-align: center;"><i>Figure 13: Execution time per character vs. Number of Iterations. Comparing
						the performance between the Python and FPGA when graphing Sierpinski Arrowhead (1).</i></p>
				<br>

				<img src="images/cross_4iter_10length,200,100.png" style="display:block;margin: 0 auto;">
				<p style="text-align: center;"><i>Figure 14: Cross with
						4 iterations with a length of 10, graphed starting at (200,100).</i></p>

				<img src="images/Cross.png" style="display:block;margin: 0 auto;">
				<p style="text-align: center;"><i>Figure 15: Execution time per character vs. Number of Iterations. Comparing
						the performance between the Python and FPGA when graphing Cross.
					</i></p>
				<br>
				<img src="images/snowflake_6iter_7length,600,400.png" style="display:block;margin: 0 auto;">
				<p style="text-align: center;"><i>Figure 16: Koch
						Snowflake with 6 iterations with a length of 7, graphed starting at (600,400).</i></p>
				<img src="images/Koch Snowflake.png" style="display:block;margin: 0 auto;">
				<p style="text-align: center;"><i>Figure 17: Execution time per character vs. Number of Iterations. Comparing
						the performance between the
						Python and FPGA when graphing the Koch Snowflake.</i></p>




				<img src="images/koch_6iter_7length,100,450.png" style="display:block;margin: 0 auto;">
				<p style="text-align: center;"><i>Figure 18: Koch Curve with 6 iterations with a length of 7, graphed starting
						at (100,450).</i></p>
				<img src="images/Koch Curve.png" style="display:block;margin: 0 auto;">
				<p style="text-align: center;"><i>Figure 19: Execution time per character
						vs. Number of Iterations. Comparing the performance
						between the Python and FPGA when graphing the Koch Curve.</i></p>

				<img src="images/tesselated_6iter_30length,300,300.png" style="display:block;margin: 0 auto;">
				<p style="text-align: center;"><i>Figure 20: Tessellated Triangle with 6 iterations (the largest possible in our
						implementation), with a
						length of 30, graphed in the center of the screen (300,300).</i></p>
				<img src="images/Tessellated Triangle.png" style="display:block;margin: 0 auto;">
				<p><i>Figure 21: Execution time per
						character vs. Number of Iterations. Comparing the
						performance between the Python and FPGA when graphing the Tessellated Triangle.</i></p>


				<p>The M10K blocks are a limiting factor in our generation of L-Systems. As shown in these graphs, not all
					L-Systems are equal in terms of how fast they grow. The maximum number of characters is 8192. However, due
					to
					exponential growth, some of the largest systems we can generate are significantly less than this threshold.
					Additionally, we are sometimes inhibited by the negative value computation difficulty mentioned earlier.
					Below
					is a chart of the L-Systems and their maximum size on our system. Generally, there are few differences
					between
					the FPGA for edges of length 7 and length 10. For the python, it takes longer to generate the length 10
					versus
					length 7 images. Within the results, there is only one instance of the negative values causing the FPGA to
					have a lower number of iterations for the length 10 graph than the length 7 graph. In all other cases, the
					max
					number of iterations is set by the M10K blocks.
				</p>
				<img src="images/compute_times.png" style="display:block;margin: 0 auto;">
				<br>
				<p>A full working demo of our entire system can be found below: </p>
				<iframe style="display:block;margin: 0 auto;" width="560" height="315"
					src="https://www.youtube.com/embed/NIYnzu1di3o" frameborder="0"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
					allowfullscreen></iframe>
			</section>
		</div>
		<br id="conclusion">
		<div class="box container">
			<section>
				<h2>Conclusion</h2>
				<p>Our original idea was to be able to animate the drawing of a fractal to the VGA screen. The user would be
					able to input the number of iterations and the length of the step size. They would then choose between
					generating a dragon curve and a fractal plant. We also envisioned adding randomness to the L-system
					generation. This would have been done by selecting a random rule for the given character out of a set of
					applicable rules, or choosing no rule and passing the character. Finally, we wanted to be able to generate
					multiple L-Systems simultaneously. We thought it would be interesting to have a group of trees on the screen
					with their own unique attributes.
				</p>
				<p>Our final system is a more user driven experience. The user is allowed to select from a variety of different
					L-Systems, input a desired axiom, the number of iterations, the line length, line color, and the starting
					position on the screen. These values are then passed to the FPGA. The <code>rules</code> module is called on
					the axiom,
					transforming it one character at a time based on the desired L-System. This is then fed into one of the
					<code>dual_clock_ram</code> modules. The <code>create_system</code> module will then ping-pong between the
					<code>dual_clock_ram</code>
					modules until
					the iteration threshold is reached. The values in the M10K are then passed to the top level for graphing.
					Based on the L-System, the top-level will determine the angle and coordinates of every line segment, write the
					pixels to the VGA. Once this is complete, the system will be ready to accept another user input.
				</p>
				<p>Unfortunately, the system is not perfect. We encountered limits on graphing in terms of the number of
					characters we could hold and the appearance of lines on the screen. Specifically, the M10K blocks have a
					finite size we cannot exceed. If we were to do this project again, we would more thoroughly investigate the
					size of the M10K blocks we could use in relation to access time. On the graphing end, we would implement
					signed registers rather than unsigned registers to mitigate the negative value issue. We would also experiment
					with different diagonal line drawing algorithms, at high iterations, some lines do not perfectly connect with
					one another. Additionally, as a feature we wish we had implemented, we would want to attempt user defined
					rules. This would allow a user the creative freedom to explore any L-system they desired within the character
					limit for rules.
				</p>
				<p>In terms of safety, this project was done entirely remotely. The boards were stored in a safe, grounded
					environment. Students connected to them through a remote desktop to assigned computers. This was done for the
					health and safety of everyone involved, but also reduced the likelihood of physical damage to the boards and
					computers. Regarding intellectual property, the initial python code is an open source program we found. We
					translated this into C for our proof of concept running on the HPS. Furthermore, the base computer system
					module we wrote our L-system accelerator around is not ours. The base system was taken from Bruce Land’s ECE
					5760 website. We modified the base as necessary for the accelerator.</p>
			</section>
		</div>
		<br id="appendices">
		<div class="box container">
			<section>
				<h2>Appendices</h2>

				<h3>Team</h3>
				<a href="images/baby_yoda_drinking_tea.gif"><img src="images/priya_headshot.JPG"
						style="display:block;margin: 0 auto; width:30%; height: 30%;"></a>
				<h4>Priya Kattapurath</h4>
				<p style="text-align: center;"><i>ECE '20, MEng '21</i></p>
				<br>

				<a href="images/sleepy_duck.gif"><img src="images/michael.JPG"
						style="display:block;margin: 0 auto; width:30%; height: 30%;"></a>
				<h4>Michael Rivera</h4>
				<p style="text-align: center;"><i>ECE '20, MEng '20</i></p>
				<br>

				<a href="images/eggdog.gif"><img src="images/caitlin.jpg"
						style="display:block;margin: 0 auto; width:30%; height: 30%;"></a>
				<h4>Caitlin Stanton</h4>
				<p style="text-align: center;"><i>ECE '20, MEng '21</i></p>
				<br>

				<h3>Appendix A: Permissions</h3>
				<p>The group approves this report for inclusion on the course website.
					The group approves the video for inclusion on the course YouTube channel.
				</p>
				<h3>Appendix B: Work Distribution</h3>
				<p>All members contributed to the development, debugging, and demoing of the baseline and full-system designs.
				</p>
				<ul>

					<li>Introduction - Caitlin</li>
					<li>High-Level Design - Caitlin</li>
					<li>Baseline Design - Caitlin</li>
					<li>Full System Design - Priya, Caitlin, Michael</li>
					<li>Testing - Caitlin, Priya</li>
					<li>Future Work - Priya</li>
					<li>Results - Michael</li>
					<li>Conclusion - Michael</li>
					<li>Commented Code - Caitlin</li>
					<li>Diagrams - Priya</li>
					<li>Graphs - Caitlin, Michael</li>
				</ul>
				<h3>Appendix C: References</h3>
				<ul>
					<li><a href="https://en.wikipedia.org/wiki/L-system">Wikipedia: L-System</a></li>
					<li><a href="https://mathworld.wolfram.com/LindenmayerSystem.html">Wolfram Alpha: Lindenmayer Systems</a></li>
					<li><a href="https://fractalfoundation.org/resources/what-are-fractals/">What are Fractals?</a></li>
					<li><a href="https://breaksome.tech/coding-a-dragon-curve-in-p5js/">Coding a Dragon Curve</a></li>
					<li><a href="https://breaksome.tech/coding-a-fractal-plant-in-p5js-using-l-systems/">Coding a Fractal
							Plant</a></li>
					<li><a href="https://en.wikipedia.org/wiki/Dragon_curve">Wikipedia: Dragon curve</a></li>
					<li><a href="https://medium.com/@hhtun21/l-systems-draw-your-first-fractals-139ed0bfcac2">Drawing nice
							L-Systems</a></li>
					<li><a href="https://medium.com/@hhtun21/l-systems-draw-a-stochastic-plant-ii-f322df2ea3c5">Drawing nice
							stochastic plants</a></li>
					<li><a href="https://people.ece.cornell.edu/land/courses/ece5760/DE2/indexVGA.html">ECE 5760: VGA examples</a>
					</li>
					<li><a href="https://www.beyond-circuits.com/wordpress/2009/01/recursive-modules/">Recursive Modules</a></li>
					<li><a
							href="https://people.ece.cornell.edu/land/courses/ece5760/DE1_SOC/HPS_peripherials/Bus_master_slave_index.html">Avalon
							Bus Master</a></li>
					<li></li>
					<li></li>
				</ul>
				<h3>Appendix D: Code</h3>
				<p>Here are the major files referenced in this lab report. The entirety of our code repository can be found in
					<a href="https://github.com/priyakatt/FPGA_L-Systems">this Github repository</a>.
				</p>
				<h4>rules.v</h4>
				<!-- HTML generated using hilite.me -->
				<div
					style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
					<pre style="margin: 0; line-height: 125%"><span style="font-style: italic">////////////////////////////////////////////////////////////////////////</span>
<span style="font-style: italic">// RULES.V</span>
<span style="font-style: italic">//		Responsible for computing and storing the L-System</span>
<span style="font-style: italic">// (Priya Kattappurath, Michael Rivera, Caitlin Stanton)</span>
<span style="font-style: italic">////////////////////////////////////////////////////////////////////////</span>

<span style="font-style: italic">// Dual Clock RAM</span>
<span style="font-style: italic">//		Equivalent to instantiating ~8 M10Ks</span>
<span style="font-weight: bold">module</span> dual_clock_ram(q, d, write_address, read_address, we, clk1, clk2);
 	<span style="font-weight: bold">output</span> <span style="font-weight: bold">reg</span> [7:0] q;
 	<span style="font-weight: bold">input</span> [7:0] d;
 	<span style="font-weight: bold">input</span> [12:0] write_address, read_address;
 	<span style="font-weight: bold">input</span> we, clk1, clk2;

 	<span style="font-weight: bold">reg</span> [12:0] read_address_reg;
 	<span style="font-weight: bold">reg</span> [7:0] mem [8191:0];	<span style="font-style: italic">//8192 memory locations</span>

 	<span style="font-weight: bold">always</span> @ (<span style="font-weight: bold">posedge</span> clk1) <span style="font-weight: bold">begin</span>
 		<span style="font-weight: bold">if</span> (we) mem[write_address] &lt;= d;
 	<span style="font-weight: bold">end</span>
 	<span style="font-weight: bold">always</span> @ (<span style="font-weight: bold">posedge</span> clk2) <span style="font-weight: bold">begin</span>
 		q &lt;= mem[read_address_reg];
 		read_address_reg &lt;= read_address;
 	<span style="font-weight: bold">end</span>
<span style="font-weight: bold">endmodule</span>

<span style="font-style: italic">// Fixed point signed multiplier</span>
<span style="font-style: italic">//		Works in 11.21 fixed point</span>
<span style="font-weight: bold">module</span> signed_mult (out, a, b); <span style="font-style: italic">//11.21 fixed point</span>
	<span style="font-weight: bold">output</span> 	<span style="font-weight: bold">signed</span>  [31:0]	out;
	<span style="font-weight: bold">input</span> 	<span style="font-weight: bold">signed</span>	[31:0] 	a;
	<span style="font-weight: bold">input</span> 	<span style="font-weight: bold">signed</span>	[31:0] 	b;
	<span style="font-style: italic">// intermediate full bit length</span>
	<span style="font-weight: bold">wire</span> 	<span style="font-weight: bold">signed</span>	[63:0]	mult_out;
	<span style="font-weight: bold">assign</span> mult_out = a * b;
	<span style="font-style: italic">// select bits for 11.21 fixed point</span>
	<span style="font-weight: bold">assign</span> out = {mult_out[63], mult_out[51:21]}; <span style="font-style: italic">//11.21 fixed point</span>
<span style="font-weight: bold">endmodule</span>

<span style="font-style: italic">// Rule module</span>
<span style="font-style: italic">//		Declares rules for 7 L-Systems: Dragon curve, 2 Sierpinski arrowheads, 2 Koch curves, cross, tessellated triangle</span>
<span style="font-style: italic">//		(Equivalent to applyRule in lsystem.py)</span>
<span style="font-weight: bold">module</span> rules(clk, reset, lsystem, rule_val, rule_prev, rule_result, rule_done);
	<span style="font-weight: bold">input</span> clk, reset, rule_val;
	<span style="font-weight: bold">input</span> [2:0] lsystem;
	<span style="font-weight: bold">input</span> [7:0] rule_prev; 			<span style="font-style: italic">//8 bit input, defined by ASCII code</span>
	<span style="font-weight: bold">output</span> [79:0] rule_result; 	<span style="font-style: italic">//up to 80 bit output</span>
	<span style="font-weight: bold">output</span> [1:0] rule_done;

	<span style="font-weight: bold">reg</span> [7:0] rule_prev_reg;
	<span style="font-weight: bold">reg</span> [1:0] rule_done_reg;
	<span style="font-weight: bold">reg</span> [79:0] rule_result_reg;
	<span style="font-weight: bold">reg</span> [2:0] rule_state_reg;
	
	<span style="font-weight: bold">assign</span> rule_result = rule_result_reg;
	<span style="font-weight: bold">assign</span> rule_done = rule_done_reg;
	
	<span style="font-style: italic">//ASCII definitions of alphabet</span>
	<span style="font-weight: bold">localparam</span> [7:0] X = 8&#39;b01011000;
	<span style="font-weight: bold">localparam</span> [7:0] Y = 8&#39;b01011001;
	<span style="font-weight: bold">localparam</span> [7:0] plus = 8&#39;d43;						<span style="font-style: italic">//+</span>
	<span style="font-weight: bold">localparam</span> [7:0] minus = 8&#39;d45;						<span style="font-style: italic">//-</span>
	<span style="font-weight: bold">localparam</span> [7:0] F = 8&#39;d70;
	<span style="font-weight: bold">localparam</span> [7:0] A = 8&#39;d65;

	<span style="font-style: italic">//FSM states</span>
	<span style="font-weight: bold">localparam</span> RULE_UPDATE 							= 3&#39;b0;
	<span style="font-weight: bold">localparam</span> DRAGON_TRANSLATE 				= 3&#39;b1;
	<span style="font-weight: bold">localparam</span> TRIANGLE_TRANSLATE				= 3&#39;d2;	
	<span style="font-weight: bold">localparam</span> ARROW_TRANSLATE 					= 3&#39;d3;
	<span style="font-weight: bold">localparam</span> KOCH_TRANSLATE						= 3&#39;d4;
	<span style="font-weight: bold">localparam</span> SNOWFLAKE_TRANSLATE			= 3&#39;d5;
	<span style="font-weight: bold">localparam</span> CROSS_TRANSLATE					= 3&#39;d6;
	<span style="font-weight: bold">localparam</span> TESSELLATE_TRANSLATE			= 3&#39;d7;

	<span style="font-weight: bold">always</span> @ (<span style="font-weight: bold">posedge</span> clk) <span style="font-weight: bold">begin</span>
		<span style="font-style: italic">//reset state</span>
		<span style="font-weight: bold">if</span> (reset) <span style="font-weight: bold">begin</span>
			rule_result_reg &lt;= 80&#39;b0;
			rule_done_reg &lt;= 2&#39;b0;
			rule_prev_reg &lt;= rule_prev;
			rule_state_reg &lt;= RULE_UPDATE;
		<span style="font-weight: bold">end</span>
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
			<span style="font-weight: bold">case</span> (rule_state_reg)
				<span style="font-style: italic">//waits for new character to apply rule to</span>
				RULE_UPDATE: <span style="font-weight: bold">begin</span>
					rule_prev_reg &lt;= rule_prev;
					rule_result_reg &lt;= rule_result_reg;
					<span style="font-weight: bold">if</span> (rule_val) <span style="font-weight: bold">begin</span>	<span style="font-style: italic">//if new character has arrived</span>
						rule_done_reg &lt;= 2&#39;b0;
						<span style="font-style: italic">//choose which state to transition to based on inputted lsystem</span>
						<span style="font-weight: bold">if</span> (lsystem == 3&#39;b0) <span style="font-weight: bold">begin</span>
							rule_state_reg &lt;= DRAGON_TRANSLATE;
						<span style="font-weight: bold">end</span>
						<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (lsystem == 3&#39;b1) <span style="font-weight: bold">begin</span> 
							rule_state_reg &lt;= TRIANGLE_TRANSLATE;
						<span style="font-weight: bold">end</span> 
						<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (lsystem == 3&#39;d2) <span style="font-weight: bold">begin</span>
							rule_state_reg &lt;= KOCH_TRANSLATE;
						<span style="font-weight: bold">end</span>
						<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (lsystem == 3&#39;d3) <span style="font-weight: bold">begin</span>
							rule_state_reg &lt;= ARROW_TRANSLATE;
						<span style="font-weight: bold">end</span>
						<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (lsystem == 3&#39;d4) <span style="font-weight: bold">begin</span>
							rule_state_reg &lt;= SNOWFLAKE_TRANSLATE;
						<span style="font-weight: bold">end</span>
						<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (lsystem == 3&#39;d5) <span style="font-weight: bold">begin</span>
							rule_state_reg &lt;= CROSS_TRANSLATE;
						<span style="font-weight: bold">end</span>
						<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (lsystem == 3&#39;d6) <span style="font-weight: bold">begin</span> 
							rule_state_reg &lt;= TESSELLATE_TRANSLATE;
						<span style="font-weight: bold">end</span>
						<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span> 
							rule_state_reg &lt;= RULE_UPDATE;
						<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>	<span style="font-style: italic">//stays in this state until a valid character is received</span>
						rule_done_reg &lt;= rule_done_reg;
						rule_state_reg &lt;= RULE_UPDATE;
					<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">end</span>

				<span style="font-style: italic">//RULE APPLICATION STATES</span>
					<span style="font-style: italic">//If the inputted character matches a rule, output that string</span>
					<span style="font-style: italic">//Otherwise output the character</span>
					<span style="font-style: italic">//Buffered by zeroes to be 10 bytes (80 bits)</span>

				<span style="font-style: italic">//Dragon curve</span>
				DRAGON_TRANSLATE: <span style="font-weight: bold">begin</span>		
					rule_prev_reg &lt;= rule_prev_reg;
					<span style="font-weight: bold">if</span> (rule_prev_reg == X) <span style="font-weight: bold">begin</span>
						rule_done_reg &lt;= 2&#39;b1;
						rule_result_reg &lt;= {X, plus, Y, F, plus, 40&#39;b0};	<span style="font-style: italic">//&quot;X+YF+&quot;</span>
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (rule_prev_reg == Y) <span style="font-weight: bold">begin</span>
						rule_done_reg &lt;= 2&#39;d2;
						rule_result_reg &lt;= {minus, F, X, minus, Y, 40&#39;b0};	<span style="font-style: italic">//&quot;-FX-Y&quot;</span>
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
						rule_done_reg &lt;= 2&#39;d3;
						rule_result_reg &lt;= {rule_prev_reg, 72&#39;b0};
					<span style="font-weight: bold">end</span>
					rule_state_reg &lt;= RULE_UPDATE;
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//Sierpsinki arrowhead (1)</span>
				TRIANGLE_TRANSLATE: <span style="font-weight: bold">begin</span>
					rule_prev_reg &lt;= rule_prev_reg;
					<span style="font-weight: bold">if</span> (rule_prev_reg == X) <span style="font-weight: bold">begin</span>
						rule_done_reg &lt;= 2&#39;b1;
						rule_result_reg &lt;= {Y, F, plus, X, F, plus, Y, 24&#39;b0};	<span style="font-style: italic">//&quot;YF+XF+Y&quot;</span>
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (rule_prev_reg == Y) <span style="font-weight: bold">begin</span>
						rule_done_reg &lt;= 2&#39;d2;
						rule_result_reg &lt;= {X, F, minus, Y, F, minus, X, 24&#39;b0};	<span style="font-style: italic">//&quot;XF-YF-X&quot;</span>
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
						rule_done_reg &lt;= 2&#39;d3;
						rule_result_reg &lt;= {rule_prev_reg, 72&#39;b0};
					<span style="font-weight: bold">end</span>
					rule_state_reg &lt;= RULE_UPDATE;
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//Sierpinski arrowhead (2)</span>
				ARROW_TRANSLATE: <span style="font-weight: bold">begin</span>
					rule_prev_reg &lt;= rule_prev_reg;
					<span style="font-weight: bold">if</span> (rule_prev_reg == A) <span style="font-weight: bold">begin</span>
						rule_done_reg &lt;= 2&#39;b1;
						rule_result_reg &lt;= {plus, F, minus, A, minus, F, plus, 24&#39;b0};	<span style="font-style: italic">//&quot;+F-A-F+&quot;</span>
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (rule_prev_reg == F) <span style="font-weight: bold">begin</span>
						rule_done_reg &lt;= 2&#39;d2;
						rule_result_reg &lt;= {minus, A, plus, F, plus, A, minus, 24&#39;b0};	<span style="font-style: italic">//&quot;-A+F+A-&quot;</span>
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
						rule_done_reg &lt;= 2&#39;d3;
						rule_result_reg &lt;= {rule_prev_reg, 72&#39;b0};
					<span style="font-weight: bold">end</span>
					rule_state_reg &lt;= RULE_UPDATE;
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//Koch curve</span>
				KOCH_TRANSLATE: <span style="font-weight: bold">begin</span>
					rule_prev_reg &lt;= rule_prev_reg;
					<span style="font-weight: bold">if</span> (rule_prev_reg == F) <span style="font-weight: bold">begin</span>
						rule_done_reg &lt;= 2&#39;b1;
						rule_result_reg &lt;= {F, plus, F, minus, minus, F, plus, F, 16&#39;b0};	<span style="font-style: italic">//&quot;F+F--F+F&quot;</span>
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
						rule_done_reg &lt;= 2&#39;d3;
						rule_result_reg &lt;= {rule_prev_reg, 72&#39;b0};
					<span style="font-weight: bold">end</span>
					rule_state_reg &lt;= RULE_UPDATE;
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//Koch snowflake</span>
				SNOWFLAKE_TRANSLATE: <span style="font-weight: bold">begin</span> 
					rule_prev_reg &lt;= rule_prev_reg;
					<span style="font-weight: bold">if</span> (rule_prev_reg == F) <span style="font-weight: bold">begin</span>
						rule_done_reg &lt;= 2&#39;b1;
						rule_result_reg &lt;= {F, minus, F, plus, plus, F, minus, F, 16&#39;b0};	<span style="font-style: italic">//&quot;F-F++F-F&quot;</span>
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
						rule_done_reg &lt;= 2&#39;d3;
						rule_result_reg &lt;= {rule_prev_reg, 72&#39;b0};
					<span style="font-weight: bold">end</span>
					rule_state_reg &lt;= RULE_UPDATE;
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//Cross</span>
				CROSS_TRANSLATE: <span style="font-weight: bold">begin</span>
					rule_prev_reg &lt;= rule_prev_reg;
					<span style="font-weight: bold">if</span> (rule_prev_reg == F) <span style="font-weight: bold">begin</span>
						rule_done_reg &lt;= 2&#39;b1;
						rule_result_reg &lt;= {F, plus, F, F, plus, plus, F, plus, F, 8&#39;b0};	<span style="font-style: italic">//&quot;F+FF++F+F&quot;</span>
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
						rule_done_reg &lt;= 2&#39;d3;
						rule_result_reg &lt;= {rule_prev_reg, 72&#39;b0};
					<span style="font-weight: bold">end</span>
					rule_state_reg &lt;= RULE_UPDATE;
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//Tessellated triangle</span>
				TESSELLATE_TRANSLATE: <span style="font-weight: bold">begin</span>
					rule_prev_reg &lt;= rule_prev_reg;
					<span style="font-weight: bold">if</span> (rule_prev_reg == F) <span style="font-weight: bold">begin</span>
						rule_done_reg &lt;= 2&#39;b1;
						rule_result_reg &lt;= {F, minus, F, plus, F, 40&#39;b0};	<span style="font-style: italic">//&quot;F-F+F&quot;</span>
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
						rule_done_reg &lt;= 2&#39;d3;
						rule_result_reg &lt;= {rule_prev_reg, 72&#39;b0};
					<span style="font-weight: bold">end</span>
					rule_state_reg &lt;= RULE_UPDATE;
				<span style="font-weight: bold">end</span>
			<span style="font-weight: bold">endcase</span>
		<span style="font-weight: bold">end</span>
	<span style="font-weight: bold">end</span>	
<span style="font-weight: bold">endmodule</span>

<span style="font-style: italic">// Create System module</span>
<span style="font-style: italic">//		Performs given number of iterations on the L-System string</span>
<span style="font-style: italic">//		Stores strings in memory</span>
<span style="font-style: italic">//		Sends result of each iteration byte by byte to the top-level</span>
<span style="font-style: italic">//		(Equivalent to createSystem and processString in lsystem.py)</span>
<span style="font-weight: bold">module</span> create_system(clk, reset, top_rdy, top_graphing, lsystem, iterations, system_input_string, system_output_string, system_val, system_done, iterations_counter); <span style="font-style: italic">//equivalent to createSystem() in translated_python.c</span>
	<span style="font-weight: bold">input</span> clk, reset, top_rdy;
	<span style="font-weight: bold">input</span> [1:0] top_graphing;
	<span style="font-weight: bold">input</span> [31:0] system_input_string;
	<span style="font-weight: bold">input</span> [2:0] lsystem;
	<span style="font-weight: bold">input</span> [3:0] iterations;
	<span style="font-weight: bold">output</span> [7:0] system_output_string;
	<span style="font-weight: bold">output</span> system_val;
	<span style="font-weight: bold">output</span> system_done;
	<span style="font-weight: bold">output</span> [3:0] iterations_counter;

	<span style="font-style: italic">//ASCII definitions of alphabet</span>
	<span style="font-weight: bold">localparam</span> [7:0] X = 8&#39;b01011000;
	<span style="font-weight: bold">localparam</span> [7:0] Y = 8&#39;b01011001;
	<span style="font-weight: bold">localparam</span> [7:0] plus = 8&#39;d43;		<span style="font-style: italic">//+</span>
	<span style="font-weight: bold">localparam</span> [7:0] minus = 8&#39;d45;		<span style="font-style: italic">//-</span>
	<span style="font-weight: bold">localparam</span> [7:0] F = 8&#39;d70;
	<span style="font-weight: bold">localparam</span> [7:0] A = 8&#39;d65;
	<span style="font-weight: bold">localparam</span> [7:0] open_bracket = 8&#39;d91;	<span style="font-style: italic">//[</span>
	<span style="font-weight: bold">localparam</span> [7:0] closing_bracket = 8&#39;d93;	<span style="font-style: italic">//]</span>

	<span style="font-style: italic">//dual_clock_ram instantiations (M10K memory)</span>
	<span style="font-weight: bold">wire</span> [7:0] a_q;
	<span style="font-weight: bold">wire</span> [7:0] a_d;
	<span style="font-weight: bold">reg</span>[7:0] a_d_reg;
	<span style="font-weight: bold">wire</span> [12:0] a_write_address;
	<span style="font-weight: bold">reg</span> [12:0] a_write_address_reg;
	<span style="font-weight: bold">wire</span> [12:0] a_read_address;
	<span style="font-weight: bold">reg</span> [12:0] a_read_address_reg;
	<span style="font-weight: bold">wire</span> a_we;
	<span style="font-weight: bold">reg</span> a_we_reg;

	<span style="font-weight: bold">assign</span> a_d = a_d_reg;
	<span style="font-weight: bold">assign</span> a_write_address = a_write_address_reg;
	<span style="font-weight: bold">assign</span> a_read_address = a_read_address_reg;
	<span style="font-weight: bold">assign</span> a_we = a_we_reg;

	dual_clock_ram a(
		.q		(a_q), 
		.d		(a_d), 
		.write_address	(a_write_address), 
		.read_address	(a_read_address), 
		.we		(a_we), 
		.clk1		(clk), 
		.clk2		(clk)
	);

	<span style="font-weight: bold">wire</span> [7:0] b_q;
	<span style="font-weight: bold">wire</span> [7:0] b_d;
	<span style="font-weight: bold">reg</span>[7:0] b_d_reg;
	<span style="font-weight: bold">wire</span> [12:0] b_write_address;
	<span style="font-weight: bold">reg</span> [12:0] b_write_address_reg;
	<span style="font-weight: bold">wire</span> [12:0] b_read_address;
	<span style="font-weight: bold">reg</span> [12:0] b_read_address_reg;
	<span style="font-weight: bold">wire</span> b_we;
	<span style="font-weight: bold">reg</span> b_we_reg;

	<span style="font-weight: bold">assign</span> b_d = b_d_reg;
	<span style="font-weight: bold">assign</span> b_write_address = b_write_address_reg;
	<span style="font-weight: bold">assign</span> b_read_address = b_read_address_reg;
	<span style="font-weight: bold">assign</span> b_we = b_we_reg;

	dual_clock_ram b(
		.q		(b_q), 
		.d		(b_d), 
		.write_address	(b_write_address), 
		.read_address	(b_read_address), 
		.we		(b_we), 
		.clk1		(clk), 
		.clk2		(clk)
	);

	<span style="font-style: italic">//rules module </span>
	<span style="font-weight: bold">reg</span> rule_val_reg;
	<span style="font-weight: bold">wire</span> [79:0] rule_result;
	<span style="font-weight: bold">reg</span> [79:0] rule_result_reg;
	<span style="font-weight: bold">wire</span> [1:0] rule_done;
	<span style="font-weight: bold">wire</span> rule_val;
	<span style="font-weight: bold">reg</span> [7:0] input_char_reg;
	<span style="font-weight: bold">wire</span> [7:0] input_char;
	
	<span style="font-weight: bold">assign</span> rule_val = rule_val_reg;
	<span style="font-weight: bold">assign</span> input_char = input_char_reg;

	rules rule(
		.clk				(clk),
		.reset			(reset),
		.lsystem			(lsystem),
		.rule_prev		(input_char),
		.rule_result	(rule_result),
		.rule_done		(rule_done),
		.rule_val		(rule_val)
	);		
	
	<span style="font-style: italic">//FSM states</span>
	<span style="font-weight: bold">localparam</span> RESET_SYSTEM				= 4&#39;d0;
	<span style="font-weight: bold">localparam</span> CLEAR_M10KS				= 4&#39;d1;	
	<span style="font-weight: bold">localparam</span> GET_CHAR						= 4&#39;d2;		
	<span style="font-weight: bold">localparam</span> READ_M10K					= 4&#39;d3;		
	<span style="font-weight: bold">localparam</span> COMPUTE_DRAGON			= 4&#39;d4;
	<span style="font-weight: bold">localparam</span> WRITE_M10K_A				= 4&#39;d5;
	<span style="font-weight: bold">localparam</span> INCREMENT_WRITE_A	= 4&#39;d6;
	<span style="font-weight: bold">localparam</span> WRITE_M10K_B				= 4&#39;d7;
	<span style="font-weight: bold">localparam</span> INCREMENT_WRITE_B	= 4&#39;d8;
	<span style="font-weight: bold">localparam</span> NEXT_BYTE					= 4&#39;d9;
	<span style="font-weight: bold">localparam</span> INCREMENT_ITER			= 4&#39;d10;	
	<span style="font-weight: bold">localparam</span> ZERO_READ					= 4&#39;d11;
	<span style="font-weight: bold">localparam</span> DONE								= 4&#39;d12;
	
	<span style="font-weight: bold">reg</span> [3:0] state_reg;
	<span style="font-weight: bold">reg</span> [7:0] system_output_string_reg;
	<span style="font-weight: bold">reg</span> [7:0] output_counter;
	<span style="font-weight: bold">reg</span> [3:0] iterations_counter_reg;
	<span style="font-weight: bold">reg</span> system_val_reg;
	<span style="font-weight: bold">reg</span> system_done_reg;
	<span style="font-weight: bold">reg</span> [31:0] axiom;
	<span style="font-weight: bold">reg</span> [1:0] read_counter;

	<span style="font-weight: bold">assign</span> system_output_string = system_output_string_reg;
	<span style="font-weight: bold">assign</span> system_val = system_val_reg;
	<span style="font-weight: bold">assign</span> system_done = system_done_reg;
	<span style="font-weight: bold">assign</span> iterations_counter = iterations_counter_reg;

	<span style="font-weight: bold">always</span> @ (<span style="font-weight: bold">posedge</span> clk) <span style="font-weight: bold">begin</span>
		<span style="font-style: italic">//reset state, board startup</span>
		<span style="font-weight: bold">if</span> (reset) <span style="font-weight: bold">begin</span>
			iterations_counter_reg &lt;= 4&#39;b0;
			input_char_reg &lt;= 8&#39;b0;
			a_d_reg &lt;= 8&#39;b0;
			a_write_address_reg &lt;= 13&#39;b0;
			a_read_address_reg &lt;= 13&#39;b0;
			a_we_reg &lt;= 1&#39;b0;
			b_d_reg &lt;= 8&#39;b0;
			b_write_address_reg &lt;= 13&#39;b0;
			b_read_address_reg &lt;= 13&#39;b0;
			b_we_reg &lt;= 1&#39;b0;
			axiom &lt;= system_input_string;
			rule_result_reg &lt;= rule_result;
			read_counter &lt;= 1&#39;b0;
			system_val_reg &lt;= 1&#39;b0;
			system_output_string_reg &lt;= 8&#39;b0;
			system_done_reg &lt;= 1&#39;b0;
			state_reg &lt;= CLEAR_M10KS;
		<span style="font-weight: bold">end</span>
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
			<span style="font-weight: bold">case</span> (state_reg)
				<span style="font-style: italic">//reset state, new L-System</span>
				RESET_SYSTEM: <span style="font-weight: bold">begin</span>
					<span style="font-weight: bold">if</span> (reset) <span style="font-weight: bold">begin</span>
						iterations_counter_reg &lt;= 4&#39;b0;
						input_char_reg &lt;= 8&#39;b0;
						a_d_reg &lt;= 8&#39;b0;
						a_write_address_reg &lt;= 13&#39;b0;
						a_read_address_reg &lt;= 13&#39;b0;
						a_we_reg &lt;= 1&#39;b0;
						b_d_reg &lt;= 8&#39;b0;
						b_write_address_reg &lt;= 13&#39;b0;
						b_read_address_reg &lt;= 13&#39;b0;
						b_we_reg &lt;= 1&#39;b0;
						axiom &lt;= system_input_string;
						rule_result_reg &lt;= rule_result;
						read_counter &lt;= 1&#39;b0;
						system_val_reg &lt;= 1&#39;b0;
						system_output_string_reg &lt;= 8&#39;b0;
						system_done_reg &lt;= 1&#39;b0;
						state_reg &lt;= CLEAR_M10KS;
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
						state_reg &lt;= RESET_SYSTEM;
					<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//sets all M10K data to zero</span>
				CLEAR_M10KS: <span style="font-weight: bold">begin</span> 
					a_d_reg &lt;= 8&#39;b0;
					b_d_reg &lt;= 8&#39;b0;
					<span style="font-weight: bold">if</span> (a_write_address_reg &lt; 13&#39;h1FFF) <span style="font-weight: bold">begin</span>
						a_we_reg &lt;= 1&#39;b1;
						a_write_address_reg &lt;= a_write_address_reg + 13&#39;b1;
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">if</span> (b_write_address_reg &lt; 13&#39;h1FFF) <span style="font-weight: bold">begin</span> 
						b_we_reg &lt;= 1&#39;b1;
						b_write_address_reg &lt;= b_write_address_reg + 13&#39;b1;
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">if</span> (a_write_address_reg == 13&#39;h1FFF &amp;&amp; b_write_address_reg == 13&#39;h1FFF) <span style="font-weight: bold">begin</span> 
						a_we_reg &lt;= 1&#39;b0;
						b_we_reg &lt;= 1&#39;b0;
						a_write_address_reg &lt;= 13&#39;b0;
						b_write_address_reg &lt;= 13&#39;b0;
						state_reg &lt;= GET_CHAR;
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span> 
						state_reg &lt;= CLEAR_M10KS;
					<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//grabs the next character in the string to process, either from the axiom or M10K memory</span>
				GET_CHAR: <span style="font-weight: bold">begin</span>
					a_d_reg &lt;= 8&#39;b0;
					a_write_address_reg &lt;= a_write_address_reg;
					a_read_address_reg &lt;= a_read_address_reg;
					a_we_reg &lt;= 1&#39;b0;
					b_d_reg &lt;= 8&#39;b0;
					b_write_address_reg &lt;= b_write_address_reg;
					b_read_address_reg &lt;= b_read_address_reg;
					b_we_reg &lt;= 1&#39;b0;
					rule_result_reg &lt;= rule_result;
					read_counter &lt;= 1&#39;b0;
					system_val_reg &lt;= 1&#39;b0;
					system_output_string_reg &lt;= system_output_string_reg;
					system_done_reg &lt;= 1&#39;b0;
					<span style="font-weight: bold">if</span> (top_rdy == 1&#39;b0) <span style="font-weight: bold">begin</span>
						state_reg &lt;= GET_CHAR;
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
						<span style="font-weight: bold">if</span> (iterations_counter_reg == 4&#39;b0) <span style="font-weight: bold">begin</span>
							input_char_reg &lt;= axiom[7:0];
							state_reg &lt;= COMPUTE_DRAGON;
						<span style="font-weight: bold">end</span>
						<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (iterations_counter_reg &lt; iterations) <span style="font-weight: bold">begin</span>
							state_reg &lt;= READ_M10K;
						<span style="font-weight: bold">end</span>
						<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
							state_reg &lt;= DONE;
						<span style="font-weight: bold">end</span>	
					<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//Reads from either of the M10Ks depending on the iteration count</span>
						<span style="font-style: italic">//Requires 3 clock cycles with dual_port_ram</span>
				READ_M10K: <span style="font-weight: bold">begin</span>
					a_d_reg &lt;= 8&#39;b0;
					a_write_address_reg &lt;= a_write_address_reg;
					a_read_address_reg &lt;= a_read_address_reg;
					a_we_reg &lt;= 1&#39;b0;
					b_d_reg &lt;= 8&#39;b0;
					b_write_address_reg &lt;= b_write_address_reg;
					b_read_address_reg &lt;= b_read_address_reg;
					b_we_reg &lt;= 1&#39;b0;
					rule_result_reg &lt;= rule_result;
					read_counter &lt;= read_counter;
					system_val_reg &lt;= 1&#39;b0;
					system_done_reg &lt;= 1&#39;b0;
					<span style="font-weight: bold">if</span> (iterations_counter_reg[0] == 1&#39;b1) <span style="font-weight: bold">begin</span>
						input_char_reg &lt;= a_q;
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
						input_char_reg &lt;= b_q;
					<span style="font-weight: bold">end</span>
						state_reg &lt;= COMPUTE_DRAGON;
						<span style="font-weight: bold">if</span> (iterations_counter_reg[0] == 1&#39;b0) <span style="font-weight: bold">begin</span>
							b_read_address_reg &lt;= b_read_address_reg + 13&#39;b1;
						<span style="font-weight: bold">end</span> 
						<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
							a_read_address_reg &lt;= a_read_address_reg + 13&#39;b1;
						<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//Sends character to the rules module to be processed</span>
				COMPUTE_DRAGON: <span style="font-weight: bold">begin</span>
					a_d_reg &lt;= 8&#39;b0;
					a_write_address_reg &lt;= a_write_address_reg;
					a_read_address_reg &lt;= a_read_address_reg;
					a_we_reg &lt;= 1&#39;b0;
					b_d_reg &lt;= 8&#39;b0;
					b_write_address_reg &lt;= b_write_address_reg;
					b_read_address_reg &lt;= b_read_address_reg;
					b_we_reg &lt;= 1&#39;b0;
					rule_result_reg &lt;= rule_result;
					rule_val_reg &lt;= 1&#39;b1;
					read_counter &lt;= 1&#39;b0;
					system_val_reg &lt;= 1&#39;b0;
					system_output_string_reg &lt;= system_output_string_reg;
					system_done_reg &lt;= 1&#39;b0;
					<span style="font-weight: bold">if</span> (rule_done &gt; 2&#39;b0) <span style="font-weight: bold">begin</span>
						<span style="font-weight: bold">if</span> (iterations_counter_reg[0] == 1&#39;b0) <span style="font-weight: bold">begin</span>
							state_reg &lt;= WRITE_M10K_A;
						<span style="font-weight: bold">end</span>
						<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
							state_reg &lt;= WRITE_M10K_B;
						<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
						state_reg &lt;= COMPUTE_DRAGON;
					<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//Writes to M10K A memory on even iterations</span>
				<span style="font-style: italic">//Determines if entire result from rules has been written to memory</span>
				<span style="font-style: italic">//Sends result from rules byte by byte to top level</span>
				WRITE_M10K_A: <span style="font-weight: bold">begin</span>
					a_d_reg &lt;= rule_result_reg[79:72];
					a_write_address_reg &lt;= a_write_address_reg;
					a_read_address_reg &lt;= a_read_address_reg;
					rule_result_reg &lt;= rule_result_reg;
					read_counter &lt;= 1&#39;b0;
					system_done_reg &lt;= 1&#39;b0;
					system_output_string_reg &lt;= rule_result_reg[79:72];
					<span style="font-weight: bold">if</span> (rule_result_reg == 80&#39;b0) <span style="font-weight: bold">begin</span>
						a_we_reg &lt;= 1&#39;b0;
						system_val_reg &lt;= 1&#39;b0;
						state_reg &lt;= NEXT_BYTE;
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
						a_we_reg &lt;= 1&#39;b1;	
						<span style="font-weight: bold">if</span> (top_rdy == 1&#39;b1) <span style="font-weight: bold">begin</span>
							system_val_reg &lt;= 1&#39;b1;
							state_reg &lt;= INCREMENT_WRITE_A;
						<span style="font-weight: bold">end</span>
						<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
							system_val_reg &lt;= 1&#39;b0;
							state_reg &lt;= WRITE_M10K_A;
						<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//Increments write address for M10K A to write entire result to memory</span>
				INCREMENT_WRITE_A: <span style="font-weight: bold">begin</span>
					system_output_string_reg &lt;= system_output_string_reg;
					a_write_address_reg &lt;= a_write_address_reg + 13&#39;b1;
					a_we_reg &lt;= 1&#39;b0;	
					rule_result_reg &lt;= rule_result_reg &lt;&lt; 8;
					read_counter &lt;= 1&#39;b0;
					system_val_reg &lt;= 1&#39;b0;
					system_done_reg &lt;= 1&#39;b0;
					state_reg &lt;= WRITE_M10K_A;
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//Writes to M10K B memory on odd iterations</span>
				<span style="font-style: italic">//Determines if entire result from rules has been written to memory</span>
				<span style="font-style: italic">//Sends result from rules byte by byte to top level</span>
				WRITE_M10K_B: <span style="font-weight: bold">begin</span>
					b_d_reg &lt;= rule_result_reg[79:72];
					b_write_address_reg &lt;= b_write_address_reg;
					b_read_address_reg &lt;= b_read_address_reg;
					rule_result_reg &lt;= rule_result_reg;
					read_counter &lt;= 1&#39;b0;
					system_done_reg &lt;= 1&#39;b0;
					system_output_string_reg &lt;= rule_result_reg[79:72];
					<span style="font-weight: bold">if</span> (rule_result_reg == 80&#39;b0) <span style="font-weight: bold">begin</span>
						b_we_reg &lt;= 1&#39;b0;
						system_val_reg &lt;= 1&#39;b0;
						state_reg &lt;= NEXT_BYTE;
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
						b_we_reg &lt;= 1&#39;b1;	
						<span style="font-weight: bold">if</span> (top_rdy == 1&#39;b1) <span style="font-weight: bold">begin</span>
							system_val_reg &lt;= 1&#39;b1;
							state_reg &lt;= INCREMENT_WRITE_B;
						<span style="font-weight: bold">end</span>
						<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
							system_val_reg &lt;= 1&#39;b0;
							state_reg &lt;= WRITE_M10K_B;
						<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//Increments write address for M10K B to write entire result to memory</span>
				INCREMENT_WRITE_B: <span style="font-weight: bold">begin</span>
					system_output_string_reg &lt;= system_output_string_reg;
					b_write_address_reg &lt;= b_write_address_reg + 13&#39;b1;
					b_we_reg &lt;= 1&#39;b0;	
					rule_result_reg &lt;= rule_result_reg &lt;&lt; 8;
					read_counter &lt;= 1&#39;b0;
					system_val_reg &lt;= 1&#39;b0;
					system_done_reg &lt;= 1&#39;b0;
					state_reg &lt;= WRITE_M10K_B;
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//Shifts the axiom to indicate a character has been fully processed and written to memory</span>
				NEXT_BYTE: <span style="font-weight: bold">begin</span>
					axiom &lt;= axiom &gt;&gt; 8;
					read_counter &lt;= 1&#39;b0;
					system_val_reg &lt;= 1&#39;b0;
					system_done_reg &lt;= 1&#39;b0;
					system_output_string_reg &lt;= system_output_string_reg;
					state_reg &lt;= INCREMENT_ITER;
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//Increments the iterations_counter for the L-System</span>
					<span style="font-style: italic">//This is done:</span>
						<span style="font-style: italic">// - when there&#39;s nothing left of axiom and we&#39;re on the zeroth iteration</span>
						<span style="font-style: italic">// - a zero byte is read from M10K A on an odd iteration</span>
						<span style="font-style: italic">// - a zero byte is read from M10K B on an even iteration</span>
				INCREMENT_ITER: <span style="font-weight: bold">begin</span>
					read_counter &lt;= 1&#39;b0;
					system_val_reg &lt;= 1&#39;b0;
					system_done_reg &lt;= 1&#39;b0;
					<span style="font-weight: bold">if</span> (system_output_string_reg == 8&#39;b0 &amp;&amp; axiom == 32&#39;b0 &amp;&amp; top_graphing == 2&#39;d2) <span style="font-weight: bold">begin</span>
						<span style="font-weight: bold">if</span> (	iterations_counter_reg == 4&#39;b0 || 
								 (iterations_counter_reg[0] == 1&#39;b1 &amp;&amp; a_q == 8&#39;b0) || 
								 (iterations_counter_reg[0] == 1&#39;b0 &amp;&amp; b_q == 8&#39;b0)) <span style="font-weight: bold">begin</span>
							a_write_address_reg &lt;= 13&#39;b0;
							b_write_address_reg &lt;= 13&#39;b0;
							iterations_counter_reg &lt;= iterations_counter_reg + 4&#39;b1;
							state_reg &lt;= ZERO_READ;
						<span style="font-weight: bold">end</span>
						<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
							state_reg &lt;= GET_CHAR;
						<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
						state_reg &lt;= GET_CHAR;
					<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//Zeroes out the read addresses so that they&#39;ll start at the top of the M10K in the next iteration</span>
				ZERO_READ: <span style="font-weight: bold">begin</span>
					<span style="font-weight: bold">if</span> (iterations_counter[0] == 1&#39;b0) <span style="font-weight: bold">begin</span>
						a_read_address_reg &lt;= a_read_address_reg;
						b_read_address_reg &lt;= 13&#39;b0;
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
						a_read_address_reg &lt;= 13&#39;b0;
						b_read_address_reg &lt;= b_read_address_reg;
					<span style="font-weight: bold">end</span>
					state_reg &lt;= GET_CHAR;
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//Designated number of iterations has been performed on the L-System</span>
				DONE: <span style="font-weight: bold">begin</span>
					system_done_reg &lt;= 1&#39;b1;
					a_write_address_reg &lt;= 13&#39;b0;
					b_write_address_reg &lt;= 13&#39;b0;
					a_read_address_reg &lt;= 13&#39;b0;
					b_read_address_reg &lt;= 13&#39;b0;
					state_reg &lt;= RESET_SYSTEM;
				<span style="font-weight: bold">end</span>
			<span style="font-weight: bold">endcase</span>
		<span style="font-weight: bold">end</span>
	<span style="font-weight: bold">end</span>	
<span style="font-weight: bold">endmodule</span>
</pre>
				</div>

				<h4>DE1_SoC_Computer.v</h4>
				<!-- HTML generated using hilite.me -->
				<div
					style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
					<pre style="margin: 0; line-height: 125%"><span style="font-style: italic">////////////////////////////////////////////////////////////////////////</span>
<span style="font-style: italic">// DE1_SOC_COMPUTER.V</span>
<span style="font-style: italic">//		Top level program</span>
<span style="font-style: italic">//		Responsible for receiving user input from the HPS and graphing</span>
<span style="font-style: italic">// (Priya Kattappurath, Michael Rivera, Caitlin Stanton)</span>
<span style="font-style: italic">////////////////////////////////////////////////////////////////////////</span>

<span style="font-weight: bold">module</span> DE1_SoC_Computer (
	<span style="font-style: italic">////////////////////////////////////</span>
	<span style="font-style: italic">// FPGA Pins</span>
	<span style="font-style: italic">////////////////////////////////////</span>

	<span style="font-style: italic">// Clock pins</span>
	CLOCK_50,
	CLOCK2_50,
	CLOCK3_50,
	CLOCK4_50,

	<span style="font-style: italic">// ADC</span>
	ADC_CS_N,
	ADC_DIN,
	ADC_DOUT,
	ADC_SCLK,

	<span style="font-style: italic">// Audio</span>
	AUD_ADCDAT,
	AUD_ADCLRCK,
	AUD_BCLK,
	AUD_DACDAT,
	AUD_DACLRCK,
	AUD_XCK,

	<span style="font-style: italic">// SDRAM</span>
	DRAM_ADDR,
	DRAM_BA,
	DRAM_CAS_N,
	DRAM_CKE,
	DRAM_CLK,
	DRAM_CS_N,
	DRAM_DQ,
	DRAM_LDQM,
	DRAM_RAS_N,
	DRAM_UDQM,
	DRAM_WE_N,

	<span style="font-style: italic">// I2C Bus for Configuration of the Audio and Video-In Chips</span>
	FPGA_I2C_SCLK,
	FPGA_I2C_SDAT,

	<span style="font-style: italic">// 40-Pin Headers</span>
	GPIO_0,
	GPIO_1,
	
	<span style="font-style: italic">// Seven Segment Displays</span>
	HEX0,
	HEX1,
	HEX2,
	HEX3,
	HEX4,
	HEX5,

	<span style="font-style: italic">// IR</span>
	IRDA_RXD,
	IRDA_TXD,

	<span style="font-style: italic">// Pushbuttons</span>
	KEY,

	<span style="font-style: italic">// LEDs</span>
	LEDR,

	<span style="font-style: italic">// PS2 Ports</span>
	PS2_CLK,
	PS2_DAT,
	
	PS2_CLK2,
	PS2_DAT2,

	<span style="font-style: italic">// Slider Switches</span>
	SW,

	<span style="font-style: italic">// Video-In</span>
	TD_CLK27,
	TD_DATA,
	TD_HS,
	TD_RESET_N,
	TD_VS,

	<span style="font-style: italic">// VGA</span>
	VGA_B,
	VGA_BLANK_N,
	VGA_CLK,
	VGA_G,
	VGA_HS,
	VGA_R,
	VGA_SYNC_N,
	VGA_VS,

	<span style="font-style: italic">////////////////////////////////////</span>
	<span style="font-style: italic">// HPS Pins</span>
	<span style="font-style: italic">////////////////////////////////////</span>
	
	<span style="font-style: italic">// DDR3 SDRAM</span>
	HPS_DDR3_ADDR,
	HPS_DDR3_BA,
	HPS_DDR3_CAS_N,
	HPS_DDR3_CKE,
	HPS_DDR3_CK_N,
	HPS_DDR3_CK_P,
	HPS_DDR3_CS_N,
	HPS_DDR3_DM,
	HPS_DDR3_DQ,
	HPS_DDR3_DQS_N,
	HPS_DDR3_DQS_P,
	HPS_DDR3_ODT,
	HPS_DDR3_RAS_N,
	HPS_DDR3_RESET_N,
	HPS_DDR3_RZQ,
	HPS_DDR3_WE_N,

	<span style="font-style: italic">// Ethernet</span>
	HPS_ENET_GTX_CLK,
	HPS_ENET_INT_N,
	HPS_ENET_MDC,
	HPS_ENET_MDIO,
	HPS_ENET_RX_CLK,
	HPS_ENET_RX_DATA,
	HPS_ENET_RX_DV,
	HPS_ENET_TX_DATA,
	HPS_ENET_TX_EN,

	<span style="font-style: italic">// Flash</span>
	HPS_FLASH_DATA,
	HPS_FLASH_DCLK,
	HPS_FLASH_NCSO,

	<span style="font-style: italic">// Accelerometer</span>
	HPS_GSENSOR_INT,
		
	<span style="font-style: italic">// General Purpose I/O</span>
	HPS_GPIO,
		
	<span style="font-style: italic">// I2C</span>
	HPS_I2C_CONTROL,
	HPS_I2C1_SCLK,
	HPS_I2C1_SDAT,
	HPS_I2C2_SCLK,
	HPS_I2C2_SDAT,

	<span style="font-style: italic">// Pushbutton</span>
	HPS_KEY,

	<span style="font-style: italic">// LED</span>
	HPS_LED,
		
	<span style="font-style: italic">// SD Card</span>
	HPS_SD_CLK,
	HPS_SD_CMD,
	HPS_SD_DATA,

	<span style="font-style: italic">// SPI</span>
	HPS_SPIM_CLK,
	HPS_SPIM_MISO,
	HPS_SPIM_MOSI,
	HPS_SPIM_SS,

	<span style="font-style: italic">// UART</span>
	HPS_UART_RX,
	HPS_UART_TX,

	<span style="font-style: italic">// USB</span>
	HPS_CONV_USB_N,
	HPS_USB_CLKOUT,
	HPS_USB_DATA,
	HPS_USB_DIR,
	HPS_USB_NXT,
	HPS_USB_STP
);

<span style="font-style: italic">//=======================================================</span>
<span style="font-style: italic">//  PARAMETER declarations</span>
<span style="font-style: italic">//=======================================================</span>


<span style="font-style: italic">//=======================================================</span>
<span style="font-style: italic">//  PORT declarations</span>
<span style="font-style: italic">//=======================================================</span>

<span style="font-style: italic">////////////////////////////////////</span>
<span style="font-style: italic">// FPGA Pins</span>
<span style="font-style: italic">////////////////////////////////////</span>

<span style="font-style: italic">// Clock pins</span>
<span style="font-weight: bold">input</span>						CLOCK_50;
<span style="font-weight: bold">input</span>						CLOCK2_50;
<span style="font-weight: bold">input</span>						CLOCK3_50;
<span style="font-weight: bold">input</span>						CLOCK4_50;

<span style="font-style: italic">// ADC</span>
<span style="font-weight: bold">inout</span>						ADC_CS_N;
<span style="font-weight: bold">output</span>					ADC_DIN;
<span style="font-weight: bold">input</span>						ADC_DOUT;
<span style="font-weight: bold">output</span>					ADC_SCLK;

<span style="font-style: italic">// Audio</span>
<span style="font-weight: bold">input</span>						AUD_ADCDAT;
<span style="font-weight: bold">inout</span>						AUD_ADCLRCK;
<span style="font-weight: bold">inout</span>						AUD_BCLK;
<span style="font-weight: bold">output</span>					AUD_DACDAT;
<span style="font-weight: bold">inout</span>						AUD_DACLRCK;
<span style="font-weight: bold">output</span>					AUD_XCK;

<span style="font-style: italic">// SDRAM</span>
<span style="font-weight: bold">output</span> 		[12: 0]	DRAM_ADDR;
<span style="font-weight: bold">output</span>		[ 1: 0]	DRAM_BA;
<span style="font-weight: bold">output</span>					DRAM_CAS_N;
<span style="font-weight: bold">output</span>					DRAM_CKE;
<span style="font-weight: bold">output</span>					DRAM_CLK;
<span style="font-weight: bold">output</span>					DRAM_CS_N;
<span style="font-weight: bold">inout</span>			[15: 0]	DRAM_DQ;
<span style="font-weight: bold">output</span>					DRAM_LDQM;
<span style="font-weight: bold">output</span>					DRAM_RAS_N;
<span style="font-weight: bold">output</span>					DRAM_UDQM;
<span style="font-weight: bold">output</span>					DRAM_WE_N;

<span style="font-style: italic">// I2C Bus for Configuration of the Audio and Video-In Chips</span>
<span style="font-weight: bold">output</span>					FPGA_I2C_SCLK;
<span style="font-weight: bold">inout</span>						FPGA_I2C_SDAT;

<span style="font-style: italic">// 40-pin headers</span>
<span style="font-weight: bold">inout</span>			[35: 0]	GPIO_0;
<span style="font-weight: bold">inout</span>			[35: 0]	GPIO_1;

<span style="font-style: italic">// Seven Segment Displays</span>
<span style="font-weight: bold">output</span>		[ 6: 0]	HEX0;
<span style="font-weight: bold">output</span>		[ 6: 0]	HEX1;
<span style="font-weight: bold">output</span>		[ 6: 0]	HEX2;
<span style="font-weight: bold">output</span>		[ 6: 0]	HEX3;
<span style="font-weight: bold">output</span>		[ 6: 0]	HEX4;
<span style="font-weight: bold">output</span>		[ 6: 0]	HEX5;

<span style="font-style: italic">// IR</span>
<span style="font-weight: bold">input</span>						IRDA_RXD;
<span style="font-weight: bold">output</span>					IRDA_TXD;

<span style="font-style: italic">// Pushbuttons</span>
<span style="font-weight: bold">input</span>			[ 3: 0]	KEY;

<span style="font-style: italic">// LEDs</span>
<span style="font-weight: bold">output</span>		[ 9: 0]	LEDR;

<span style="font-style: italic">// PS2 Ports</span>
<span style="font-weight: bold">inout</span>						PS2_CLK;
<span style="font-weight: bold">inout</span>						PS2_DAT;

<span style="font-weight: bold">inout</span>						PS2_CLK2;
<span style="font-weight: bold">inout</span>						PS2_DAT2;

<span style="font-style: italic">// Slider Switches</span>
<span style="font-weight: bold">input</span>			[ 9: 0]	SW;

<span style="font-style: italic">// Video-In</span>
<span style="font-weight: bold">input</span>						TD_CLK27;
<span style="font-weight: bold">input</span>			[ 7: 0]	TD_DATA;
<span style="font-weight: bold">input</span>						TD_HS;
<span style="font-weight: bold">output</span>					TD_RESET_N;
<span style="font-weight: bold">input</span>						TD_VS;

<span style="font-style: italic">// VGA</span>
<span style="font-weight: bold">output</span>		[ 7: 0]	VGA_B;
<span style="font-weight: bold">output</span>					VGA_BLANK_N;
<span style="font-weight: bold">output</span>					VGA_CLK;
<span style="font-weight: bold">output</span>		[ 7: 0]	VGA_G;
<span style="font-weight: bold">output</span>					VGA_HS;
<span style="font-weight: bold">output</span>		[ 7: 0]	VGA_R;
<span style="font-weight: bold">output</span>					VGA_SYNC_N;
<span style="font-weight: bold">output</span>					VGA_VS;



<span style="font-style: italic">////////////////////////////////////</span>
<span style="font-style: italic">// HPS Pins</span>
<span style="font-style: italic">////////////////////////////////////</span>
	
<span style="font-style: italic">// DDR3 SDRAM</span>
<span style="font-weight: bold">output</span>		[14: 0]	HPS_DDR3_ADDR;
<span style="font-weight: bold">output</span>		[ 2: 0]  HPS_DDR3_BA;
<span style="font-weight: bold">output</span>					HPS_DDR3_CAS_N;
<span style="font-weight: bold">output</span>					HPS_DDR3_CKE;
<span style="font-weight: bold">output</span>					HPS_DDR3_CK_N;
<span style="font-weight: bold">output</span>					HPS_DDR3_CK_P;
<span style="font-weight: bold">output</span>					HPS_DDR3_CS_N;
<span style="font-weight: bold">output</span>		[ 3: 0]	HPS_DDR3_DM;
<span style="font-weight: bold">inout</span>			[31: 0]	HPS_DDR3_DQ;
<span style="font-weight: bold">inout</span>			[ 3: 0]	HPS_DDR3_DQS_N;
<span style="font-weight: bold">inout</span>			[ 3: 0]	HPS_DDR3_DQS_P;
<span style="font-weight: bold">output</span>					HPS_DDR3_ODT;
<span style="font-weight: bold">output</span>					HPS_DDR3_RAS_N;
<span style="font-weight: bold">output</span>					HPS_DDR3_RESET_N;
<span style="font-weight: bold">input</span>						HPS_DDR3_RZQ;
<span style="font-weight: bold">output</span>					HPS_DDR3_WE_N;

<span style="font-style: italic">// Ethernet</span>
<span style="font-weight: bold">output</span>					HPS_ENET_GTX_CLK;
<span style="font-weight: bold">inout</span>						HPS_ENET_INT_N;
<span style="font-weight: bold">output</span>					HPS_ENET_MDC;
<span style="font-weight: bold">inout</span>						HPS_ENET_MDIO;
<span style="font-weight: bold">input</span>						HPS_ENET_RX_CLK;
<span style="font-weight: bold">input</span>			[ 3: 0]	HPS_ENET_RX_DATA;
<span style="font-weight: bold">input</span>						HPS_ENET_RX_DV;
<span style="font-weight: bold">output</span>		[ 3: 0]	HPS_ENET_TX_DATA;
<span style="font-weight: bold">output</span>					HPS_ENET_TX_EN;

<span style="font-style: italic">// Flash</span>
<span style="font-weight: bold">inout</span>			[ 3: 0]	HPS_FLASH_DATA;
<span style="font-weight: bold">output</span>					HPS_FLASH_DCLK;
<span style="font-weight: bold">output</span>					HPS_FLASH_NCSO;

<span style="font-style: italic">// Accelerometer</span>
<span style="font-weight: bold">inout</span>						HPS_GSENSOR_INT;

<span style="font-style: italic">// General Purpose I/O</span>
<span style="font-weight: bold">inout</span>			[ 1: 0]	HPS_GPIO;

<span style="font-style: italic">// I2C</span>
<span style="font-weight: bold">inout</span>						HPS_I2C_CONTROL;
<span style="font-weight: bold">inout</span>						HPS_I2C1_SCLK;
<span style="font-weight: bold">inout</span>						HPS_I2C1_SDAT;
<span style="font-weight: bold">inout</span>						HPS_I2C2_SCLK;
<span style="font-weight: bold">inout</span>						HPS_I2C2_SDAT;

<span style="font-style: italic">// Pushbutton</span>
<span style="font-weight: bold">inout</span>						HPS_KEY;

<span style="font-style: italic">// LED</span>
<span style="font-weight: bold">inout</span>						HPS_LED;

<span style="font-style: italic">// SD Card</span>
<span style="font-weight: bold">output</span>					HPS_SD_CLK;
<span style="font-weight: bold">inout</span>						HPS_SD_CMD;
<span style="font-weight: bold">inout</span>			[ 3: 0]	HPS_SD_DATA;

<span style="font-style: italic">// SPI</span>
<span style="font-weight: bold">output</span>					HPS_SPIM_CLK;
<span style="font-weight: bold">input</span>						HPS_SPIM_MISO;
<span style="font-weight: bold">output</span>					HPS_SPIM_MOSI;
<span style="font-weight: bold">inout</span>						HPS_SPIM_SS;

<span style="font-style: italic">// UART</span>
<span style="font-weight: bold">input</span>						HPS_UART_RX;
<span style="font-weight: bold">output</span>					HPS_UART_TX;

<span style="font-style: italic">// USB</span>
<span style="font-weight: bold">inout</span>						HPS_CONV_USB_N;
<span style="font-weight: bold">input</span>						HPS_USB_CLKOUT;
<span style="font-weight: bold">inout</span>			[ 7: 0]	HPS_USB_DATA;
<span style="font-weight: bold">input</span>						HPS_USB_DIR;
<span style="font-weight: bold">input</span>						HPS_USB_NXT;
<span style="font-weight: bold">output</span>					HPS_USB_STP;

<span style="font-style: italic">//=======================================================</span>
<span style="font-style: italic">//  REG/WIRE declarations</span>
<span style="font-style: italic">//=======================================================</span>

<span style="font-weight: bold">wire</span>			[15: 0]	hex3_hex0;
<span style="font-style: italic">//wire			[15: 0]	hex5_hex4;</span>

<span style="font-style: italic">//assign HEX0 = ~hex3_hex0[ 6: 0]; // hex3_hex0[ 6: 0]; </span>
<span style="font-style: italic">//assign HEX1 = ~hex3_hex0[14: 8];</span>
<span style="font-style: italic">//assign HEX2 = ~hex3_hex0[22:16];</span>
<span style="font-style: italic">//assign HEX3 = ~hex3_hex0[30:24];</span>
<span style="font-weight: bold">assign</span> HEX4 = 7&#39;b1111111;
<span style="font-weight: bold">assign</span> HEX5 = 7&#39;b1111111;

HexDigit Digit0(HEX0, hex3_hex0[3:0]);
HexDigit Digit1(HEX1, hex3_hex0[7:4]);
HexDigit Digit2(HEX2, hex3_hex0[11:8]);
HexDigit Digit3(HEX3, hex3_hex0[15:12]);

<span style="font-style: italic">//=======================================================</span>
<span style="font-style: italic">// SRAM/VGA state machine</span>
<span style="font-style: italic">//=======================================================</span>
<span style="font-style: italic">// --Check for sram address=0 nonzero, which means that</span>
<span style="font-style: italic">//   HPS wrote some new data.</span>
<span style="font-style: italic">//</span>
<span style="font-style: italic">// --Read sram address 1 and 2 to get x1, y1 </span>
<span style="font-style: italic">//   left-most x, upper-most y</span>
<span style="font-style: italic">// --Read sram address 3 and 4 to get x2, y2</span>
<span style="font-style: italic">//   right-most x, lower-most y</span>
<span style="font-style: italic">// --Read sram address 5 to get color</span>
<span style="font-style: italic">// --write a rectangle to VGA</span>
<span style="font-style: italic">//</span>
<span style="font-style: italic">// --clear sram address=0 to signal HPS</span>
<span style="font-style: italic">//=======================================================</span>
<span style="font-style: italic">// Controls for Qsys sram slave exported in system module</span>
<span style="font-style: italic">//=======================================================</span>
<span style="font-weight: bold">wire</span> [31:0] sram_readdata ;
<span style="font-weight: bold">reg</span> [31:0] data_buffer, sram_writedata ;
<span style="font-weight: bold">reg</span> [7:0] sram_address; 
<span style="font-weight: bold">reg</span> sram_write ;
<span style="font-weight: bold">wire</span> sram_clken = 1&#39;b1;
<span style="font-weight: bold">wire</span> sram_chipselect = 1&#39;b1;
<span style="font-weight: bold">reg</span> [7:0] state ;

<span style="font-style: italic">// rectangle corners</span>
<span style="font-weight: bold">reg</span> [9:0] x1, y1, x2, y2 ;
<span style="font-weight: bold">reg</span> [31:0] timer ; <span style="font-style: italic">// may need to throttle write-rate</span>
<span style="font-style: italic">//=======================================================</span>
<span style="font-style: italic">// Controls for VGA memory</span>
<span style="font-style: italic">//=======================================================</span>
<span style="font-weight: bold">wire</span> [31:0] vga_out_base_address = 32&#39;h0000_0000 ;  <span style="font-style: italic">// vga base addr</span>
<span style="font-weight: bold">reg</span> [7:0] vga_sram_writedata ;
<span style="font-weight: bold">reg</span> [31:0] vga_sram_address; 
<span style="font-weight: bold">reg</span> vga_sram_write ;
<span style="font-weight: bold">wire</span> vga_sram_clken = 1&#39;b1;
<span style="font-weight: bold">wire</span> vga_sram_chipselect = 1&#39;b1;

<span style="font-style: italic">//=======================================================</span>
<span style="font-style: italic">// pixel address is</span>
<span style="font-weight: bold">reg</span> [9:0] vga_x_cood, vga_y_cood ;
<span style="font-weight: bold">reg</span> [7:0] pixel_color ;

<span style="font-style: italic">//=======================================================</span>
<span style="font-style: italic">// L SYSTEM MODULE</span>
<span style="font-style: italic">//=======================================================</span>

<span style="font-style: italic">//ASCII alphabet</span>
<span style="font-weight: bold">localparam</span> [7:0] X = 8&#39;b01011000;
<span style="font-weight: bold">localparam</span> [7:0] Y = 8&#39;b01011001;
<span style="font-weight: bold">localparam</span> [7:0] plus = 8&#39;d43;		<span style="font-style: italic">//+</span>
<span style="font-weight: bold">localparam</span> [7:0] minus = 8&#39;d45;		<span style="font-style: italic">//-</span>
<span style="font-weight: bold">localparam</span> [7:0] F = 8&#39;d70;
<span style="font-weight: bold">localparam</span> [7:0] A = 8&#39;d65;
<span style="font-weight: bold">localparam</span> [7:0] open_bracket = 8&#39;d91;	<span style="font-style: italic">//[</span>
<span style="font-weight: bold">localparam</span> [7:0] closing_bracket = 8&#39;d93;	<span style="font-style: italic">//]</span>

<span style="font-weight: bold">wire</span> [7:0] system_output_string;
<span style="font-weight: bold">wire</span> system_done;
<span style="font-weight: bold">wire</span> reset;
<span style="font-weight: bold">reg</span> [7:0] system_output_string_reg;
<span style="font-weight: bold">reg</span> [7:0] top_char_reg;
<span style="font-weight: bold">reg</span> top_done_reg;
<span style="font-weight: bold">wire</span> top_rdy;
<span style="font-weight: bold">reg</span> top_rdy_reg;
<span style="font-weight: bold">assign</span> top_rdy = top_rdy_reg;
<span style="font-weight: bold">wire</span> system_val;
<span style="font-weight: bold">wire</span> [1:0] top_graphing;
<span style="font-weight: bold">reg</span> [1:0] top_graphing_reg;
<span style="font-weight: bold">assign</span> top_graphing = top_graphing_reg;
<span style="font-weight: bold">reg</span> [31:0] timer_counter_reg;
<span style="font-weight: bold">wire</span> [3:0] iterations_counter;

<span style="font-style: italic">// PIO port connections</span>
<span style="font-weight: bold">wire</span> [7:0] top_char;
<span style="font-weight: bold">assign</span> top_char = top_char_reg;
<span style="font-weight: bold">wire</span> [31:0] axiom;
<span style="font-weight: bold">wire</span> [3:0] iterations;
<span style="font-weight: bold">wire</span> [4:0] length;
<span style="font-weight: bold">wire</span> [2:0] lsystem;
<span style="font-weight: bold">wire</span> [9:0] start_x, start_y;
<span style="font-weight: bold">wire</span> [31:0] timer_counter;
<span style="font-weight: bold">assign</span> timer_counter = timer_counter_reg;
<span style="font-weight: bold">wire</span> [7:0] color;

<span style="font-style: italic">//create_system module from rules.v</span>
<span style="font-style: italic">//	Calculates the L-System string to be graphed</span>
create_system system(
	.clk							(CLOCK_50), 
	.reset						(reset), 
	.top_rdy						(top_rdy),
	.top_graphing				(top_graphing),
	.lsystem						(lsystem),
	.iterations					(iterations), 
	.system_input_string		(axiom), 
	.system_output_string	(system_output_string), 
	.system_val					(system_val),
	.system_done				(system_done),
	.iterations_counter		(iterations_counter)
);

<span style="font-style: italic">//Math for graphing diagonally</span>
<span style="font-weight: bold">wire</span> [31:0] root_three = {1&#39;b0,10&#39;b1,21&#39;b1011_1011_0110_0111_1011_0};
<span style="font-weight: bold">wire</span> [31:0] y_triangle_length; <span style="font-style: italic">//length*(sqrt3)/2</span>
<span style="font-weight: bold">wire</span> [31:0] x_triangle_length = {1&#39;b0, length &gt;&gt; 1, 21&#39;b0};	<span style="font-style: italic">//length/2</span>

signed_mult triangle_mult(
	.out	(y_triangle_length), 
	.a		(root_three), 
	.b		(x_triangle_length)
);

<span style="font-style: italic">//FSM states</span>
<span style="font-weight: bold">localparam</span> TOP_RESET 				= 4&#39;d0;
<span style="font-weight: bold">localparam</span> TOP_WAIT 					= 4&#39;d1;	
<span style="font-weight: bold">localparam</span> TOP_SETUP 				= 4&#39;d2;	
<span style="font-weight: bold">localparam</span> TOP_TARGET				= 4&#39;d3;	
<span style="font-weight: bold">localparam</span> TOP_BOUND_CHECK			= 4&#39;d4;
<span style="font-weight: bold">localparam</span> TOP_GRAPH_DRAGON		= 4&#39;d5;	
<span style="font-weight: bold">localparam</span> TOP_GRAPH_TRIANGLE_X	= 4&#39;d6;
<span style="font-weight: bold">localparam</span> TOP_GRAPH_TRIANGLE_Y	= 4&#39;d7;
<span style="font-weight: bold">localparam</span> TOP_SHIFT 				= 4&#39;d8;	
<span style="font-weight: bold">localparam</span> TOP_DONE 					= 4&#39;d9;	

<span style="font-style: italic">//Internal registers</span>
<span style="font-weight: bold">reg</span> [3:0] top_state_reg;
<span style="font-weight: bold">reg</span> [31:0] x_reg;
<span style="font-weight: bold">reg</span> [31:0] y_reg;
<span style="font-weight: bold">reg</span> [31:0] targetx_reg;		<span style="font-style: italic">//11.21 fixed point (signed, but won&#39;t use sign bit)</span>
<span style="font-weight: bold">reg</span> [31:0] targety_reg;		<span style="font-style: italic">//11.21 fixed point (signed, but won&#39;t use sign bit)</span>
<span style="font-weight: bold">reg</span> [9:0] angle_reg;
<span style="font-weight: bold">reg</span> [9:0] angle_increment; <span style="font-style: italic">//90 or 60, depending on L-System</span>
<span style="font-weight: bold">reg</span> [4:0] length_reg;
<span style="font-weight: bold">reg</span> [3:0] triangle_x_counter;
<span style="font-weight: bold">reg</span> [3:0] triangle_y_counter;

<span style="font-weight: bold">always</span> @ (<span style="font-weight: bold">posedge</span> CLOCK_50) <span style="font-weight: bold">begin</span>
	<span style="font-style: italic">//Reset state, board startup</span>
	<span style="font-style: italic">//Grabs user input from HPS</span>
	<span style="font-weight: bold">if</span> (reset) <span style="font-weight: bold">begin</span>
		timer_counter_reg &lt;= 32&#39;b0;
		system_output_string_reg &lt;= 8&#39;b0;
		top_done_reg &lt;= 1&#39;b0;
		top_graphing_reg &lt;= 2&#39;b0;
		top_rdy_reg &lt;= 1&#39;b0;
		vga_sram_write &lt;= 1&#39;b0;
		vga_sram_address &lt;= vga_out_base_address;
		vga_sram_writedata &lt;= 8&#39;h00;
		x_reg &lt;= {22&#39;b0, start_x};
		y_reg &lt;= {22&#39;b0, start_y};
		targetx_reg &lt;= 32&#39;d0;
		targety_reg &lt;= 32&#39;d0;
		triangle_x_counter &lt;= 3&#39;b0;
		triangle_y_counter &lt;= 3&#39;b0;
		angle_reg &lt;= 10&#39;b0;
		<span style="font-weight: bold">if</span> (lsystem == 3&#39;b0 || lsystem == 3&#39;d5) <span style="font-weight: bold">begin</span> 
			angle_increment &lt;= 10&#39;d90;
		<span style="font-weight: bold">end</span>
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (lsystem == 3&#39;b1 || lsystem == 3&#39;d2 || lsystem == 3&#39;d3 || lsystem == 3&#39;d4) <span style="font-weight: bold">begin</span> 
			angle_increment &lt;= 10&#39;d60;
		<span style="font-weight: bold">end</span>
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (lsystem == 3&#39;d6) <span style="font-weight: bold">begin</span> 
			angle_increment &lt;= 10&#39;d120;
		<span style="font-weight: bold">end</span>
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span> 
			angle_increment &lt;= 10&#39;d0;
		<span style="font-weight: bold">end</span>
		length_reg &lt;= length;
		top_state_reg &lt;= TOP_WAIT;
	<span style="font-weight: bold">end</span>
	<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
		<span style="font-weight: bold">case</span> (top_state_reg)
			<span style="font-style: italic">//Reset state, new L-System</span>
			<span style="font-style: italic">//Grabs user input from HPS</span>
			TOP_RESET: <span style="font-weight: bold">begin</span>
				timer_counter_reg &lt;= 32&#39;b0;
				system_output_string_reg &lt;= 8&#39;b0;
				top_graphing_reg &lt;= 2&#39;b0;
				top_rdy_reg &lt;= 1&#39;b0;
				top_done_reg &lt;= 1&#39;b0;
				vga_sram_write &lt;= 1&#39;b0;
				vga_sram_address &lt;= vga_out_base_address;
				vga_sram_writedata &lt;= 8&#39;h00;
				x_reg &lt;= {22&#39;b0, start_x};
				y_reg &lt;= {22&#39;b0, start_y};
				targetx_reg &lt;= 32&#39;d0;
				targety_reg &lt;= 32&#39;d0;
				angle_reg &lt;= 10&#39;b0;
				<span style="font-weight: bold">if</span> (lsystem == 3&#39;b0 || lsystem == 3&#39;d5) <span style="font-weight: bold">begin</span> 
					angle_increment &lt;= 10&#39;d90;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (lsystem == 3&#39;b1 || lsystem == 3&#39;d2 || lsystem == 3&#39;d3 || lsystem == 3&#39;d4) <span style="font-weight: bold">begin</span> 
					angle_increment &lt;= 10&#39;d60;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (lsystem == 3&#39;d6) <span style="font-weight: bold">begin</span> 
					angle_increment &lt;= 10&#39;d120;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span> 
					angle_increment &lt;= 10&#39;d0;
				<span style="font-weight: bold">end</span>
				length_reg &lt;= length;
				<span style="font-weight: bold">if</span> (reset) <span style="font-weight: bold">begin</span>
					top_state_reg &lt;= TOP_RESET;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
					top_state_reg &lt;= TOP_WAIT;
				<span style="font-weight: bold">end</span>
			<span style="font-weight: bold">end</span>
			<span style="font-style: italic">//Waiting for next valid character byte from create_system</span>
			TOP_WAIT: <span style="font-weight: bold">begin</span>
				timer_counter_reg &lt;= timer_counter_reg + 32&#39;b1;
				top_graphing_reg &lt;= top_graphing_reg;
				top_done_reg &lt;= 1&#39;b0;
				vga_sram_write &lt;= 1&#39;b0;
				vga_sram_address &lt;= vga_out_base_address;
				vga_sram_writedata &lt;= 8&#39;h00;
				x_reg &lt;= x_reg;
				y_reg &lt;= y_reg;
				targetx_reg &lt;= x_reg;
				targety_reg &lt;= y_reg;
				angle_reg &lt;= angle_reg;
				<span style="font-weight: bold">if</span> (system_done) <span style="font-weight: bold">begin</span>
					top_state_reg &lt;= TOP_DONE;
					top_rdy_reg &lt;= 1&#39;b0;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
					<span style="font-weight: bold">if</span> (system_val == 1&#39;b0) <span style="font-weight: bold">begin</span>
						top_rdy_reg &lt;= 1&#39;b1;
						top_state_reg &lt;= TOP_WAIT;
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
						top_rdy_reg &lt;= 1&#39;b0;
						system_output_string_reg &lt;= system_output_string;
						top_state_reg &lt;= TOP_SETUP;
					<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">end</span>
			<span style="font-weight: bold">end</span>
			<span style="font-style: italic">//Grabbing the character byte from create_system</span>
			<span style="font-style: italic">//Setting the parameters for graphing later on</span>
			TOP_SETUP: <span style="font-weight: bold">begin</span>
				timer_counter_reg &lt;= timer_counter_reg + 32&#39;b1;
				top_graphing_reg &lt;= 2&#39;b0;
				top_rdy_reg &lt;= 1&#39;b0;
				top_done_reg &lt;= 1&#39;b0;
				vga_sram_write &lt;= 1&#39;b0;
				vga_sram_address &lt;= vga_out_base_address;
				vga_sram_writedata &lt;= 8&#39;h00;
				x_reg &lt;= x_reg;
				y_reg &lt;= y_reg;
				targetx_reg &lt;= targetx_reg;
				targety_reg &lt;= targety_reg;
				angle_reg &lt;= angle_reg;
				top_char_reg &lt;= system_output_string_reg;
				system_output_string_reg &lt;= system_output_string_reg;
				top_state_reg &lt;= TOP_TARGET;
			<span style="font-weight: bold">end</span>
			<span style="font-style: italic">//Calculating the coordinates for graphing based on the character byte from create_system</span>
			TOP_TARGET: <span style="font-weight: bold">begin</span>
				timer_counter_reg &lt;= timer_counter_reg + 32&#39;b1;
				top_graphing_reg &lt;= 2&#39;b0;
				top_rdy_reg &lt;= 1&#39;b0;
				vga_sram_write &lt;= 1&#39;b0;
				vga_sram_address &lt;= vga_out_base_address;
				vga_sram_writedata &lt;= 8&#39;h00;
				x_reg &lt;= x_reg;
				y_reg &lt;= y_reg;
				top_state_reg &lt;= TOP_BOUND_CHECK;
				<span style="font-style: italic">//Graphing only occurs in last iteration, so does target coordinate calculation</span>
				<span style="font-weight: bold">if</span> (iterations_counter == iterations - 4&#39;b1) <span style="font-weight: bold">begin</span> 
					<span style="font-weight: bold">case</span>(top_char_reg)
						<span style="font-style: italic">//move forward by length based on orientation (0 -&gt; up)</span>
						F: <span style="font-weight: bold">begin</span>
							<span style="font-weight: bold">if</span> (angle_reg == 10&#39;d0) <span style="font-weight: bold">begin</span>
								targetx_reg &lt;= x_reg;
								targety_reg &lt;= y_reg - length_reg;
								angle_reg &lt;= angle_reg;
							<span style="font-weight: bold">end</span> 
							<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (angle_reg == 10&#39;d60) <span style="font-weight: bold">begin</span>
								targetx_reg &lt;= x_reg + x_triangle_length[30:21];
								targety_reg &lt;= y_reg - y_triangle_length[30:21];
								angle_reg &lt;= angle_reg;
							<span style="font-weight: bold">end</span>
							<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (angle_reg == 10&#39;d90) <span style="font-weight: bold">begin</span> 
								targetx_reg &lt;= x_reg + length_reg;
								targety_reg &lt;= y_reg;
								angle_reg &lt;= angle_reg;
							<span style="font-weight: bold">end</span>
							<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (angle_reg == 10&#39;d120) <span style="font-weight: bold">begin</span> 
								targetx_reg &lt;= x_reg + x_triangle_length[30:21];
								targety_reg &lt;= y_reg + y_triangle_length[30:21];
								angle_reg &lt;= angle_reg;
							<span style="font-weight: bold">end</span>
							<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (angle_reg == 10&#39;d180) <span style="font-weight: bold">begin</span>
								targetx_reg &lt;= x_reg;
								targety_reg &lt;= y_reg + length_reg;
								angle_reg &lt;= angle_reg;
							<span style="font-weight: bold">end</span>
							<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (angle_reg == 10&#39;d240) <span style="font-weight: bold">begin</span>
								targetx_reg &lt;= x_reg - x_triangle_length[30:21];
								targety_reg &lt;= y_reg + y_triangle_length[30:21];
								angle_reg &lt;= angle_reg;
							<span style="font-weight: bold">end</span>
							<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (angle_reg == 10&#39;d270) <span style="font-weight: bold">begin</span>
								targetx_reg &lt;= x_reg - length_reg;
								targety_reg &lt;= y_reg;
								angle_reg &lt;= angle_reg;
							<span style="font-weight: bold">end</span>
							<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (angle_reg == 10&#39;d300) <span style="font-weight: bold">begin</span> 
								targetx_reg &lt;= x_reg - x_triangle_length[30:21];
								targety_reg &lt;= y_reg - y_triangle_length[30:21];
								angle_reg &lt;= angle_reg;
							<span style="font-weight: bold">end</span>
						<span style="font-weight: bold">end</span>
						<span style="font-style: italic">//move forward by length based on orientation (0 -&gt; up)</span>
						A: <span style="font-weight: bold">begin</span>
							<span style="font-weight: bold">if</span> (angle_reg == 10&#39;d0) <span style="font-weight: bold">begin</span>	
								targetx_reg &lt;= x_reg;
								targety_reg &lt;= y_reg - length_reg;
								angle_reg &lt;= angle_reg;
							<span style="font-weight: bold">end</span> 
							<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (angle_reg == 10&#39;d60) <span style="font-weight: bold">begin</span>
								targetx_reg &lt;= x_reg + x_triangle_length[30:21];
								targety_reg &lt;= y_reg - y_triangle_length[30:21];
								angle_reg &lt;= angle_reg;
							<span style="font-weight: bold">end</span>
							<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (angle_reg == 10&#39;d90) <span style="font-weight: bold">begin</span> 
								targetx_reg &lt;= x_reg + length_reg;
								targety_reg &lt;= y_reg;
								angle_reg &lt;= angle_reg;
							<span style="font-weight: bold">end</span>
							<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (angle_reg == 10&#39;d120) <span style="font-weight: bold">begin</span> 
								targetx_reg &lt;= x_reg + x_triangle_length[30:21];
								targety_reg &lt;= y_reg + y_triangle_length[30:21];
								angle_reg &lt;= angle_reg;
							<span style="font-weight: bold">end</span>
							<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (angle_reg == 10&#39;d180) <span style="font-weight: bold">begin</span>
								targetx_reg &lt;= x_reg;
								targety_reg &lt;= y_reg + length_reg;
								angle_reg &lt;= angle_reg;
							<span style="font-weight: bold">end</span>
							<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (angle_reg == 10&#39;d240) <span style="font-weight: bold">begin</span>
								targetx_reg &lt;= x_reg - x_triangle_length[30:21];
								targety_reg &lt;= y_reg + y_triangle_length[30:21];
								angle_reg &lt;= angle_reg;
							<span style="font-weight: bold">end</span>
							<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (angle_reg == 10&#39;d270) <span style="font-weight: bold">begin</span>
								targetx_reg &lt;= x_reg - length_reg;
								targety_reg &lt;= y_reg;
								angle_reg &lt;= angle_reg;
							<span style="font-weight: bold">end</span>
							<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (angle_reg == 10&#39;d300) <span style="font-weight: bold">begin</span> 
								targetx_reg &lt;= x_reg - x_triangle_length[30:21];
								targety_reg &lt;= y_reg - y_triangle_length[30:21];
								angle_reg &lt;= angle_reg;
							<span style="font-weight: bold">end</span>
						<span style="font-weight: bold">end</span>
						<span style="font-style: italic">//Increments the angle representing orientation</span>
						plus: <span style="font-weight: bold">begin</span> 
							<span style="font-weight: bold">if</span> (	(angle_reg == 10&#39;d270 &amp;&amp; lsystem == 3&#39;b0) || 
									(angle_reg == 10&#39;d300 &amp;&amp; lsystem == 3&#39;b1) || 
									(angle_reg == 10&#39;d300 &amp;&amp; lsystem == 3&#39;d2) ||
									(angle_reg == 10&#39;d300 &amp;&amp; lsystem == 3&#39;d3) ||
									(angle_reg == 10&#39;d300 &amp;&amp; lsystem == 3&#39;d4) ||
									(angle_reg == 10&#39;d270 &amp;&amp; lsystem == 3&#39;d5) ||
									(angle_reg == 10&#39;d240 &amp;&amp; lsystem == 3&#39;d6)) <span style="font-weight: bold">begin</span>
								targetx_reg &lt;= targetx_reg;
								targety_reg &lt;= targety_reg;
								angle_reg &lt;= 10&#39;d0;
							<span style="font-weight: bold">end</span>
							<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
								targetx_reg &lt;= targetx_reg;
								targety_reg &lt;= targety_reg;
								angle_reg &lt;= angle_reg + angle_increment;
							<span style="font-weight: bold">end</span>
						<span style="font-weight: bold">end</span>
						<span style="font-style: italic">//Decrements the angle representing orientation</span>
						minus: <span style="font-weight: bold">begin</span>
							<span style="font-weight: bold">if</span> (angle_reg == 10&#39;d0) <span style="font-weight: bold">begin</span>
								targetx_reg &lt;= targetx_reg;
								targety_reg &lt;= targety_reg;
								angle_reg &lt;= 10&#39;d360 - angle_increment;
							<span style="font-weight: bold">end</span>
							<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span> 
								targetx_reg &lt;= targetx_reg;
								targety_reg &lt;= targety_reg;
								angle_reg &lt;= angle_reg - angle_increment;
							<span style="font-weight: bold">end</span>
						<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">endcase</span> 
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
					targetx_reg &lt;= targetx_reg;
					targety_reg &lt;= targety_reg;
					angle_reg &lt;= angle_reg;
				<span style="font-weight: bold">end</span>
			<span style="font-weight: bold">end</span>
			<span style="font-style: italic">//Checks the target coordinates to see if they&#39;re within the 640x480 confines of the VGA screen</span>
				<span style="font-style: italic">//If they&#39;re not, don&#39;t set the write enable</span>
				<span style="font-style: italic">//Otherwise go to the appropriate graphing state for the L-System</span>
			TOP_BOUND_CHECK: <span style="font-weight: bold">begin</span>
				timer_counter_reg &lt;= timer_counter_reg + 32&#39;b1;
				top_rdy_reg &lt;= 1&#39;b0;
				targetx_reg &lt;= targetx_reg;
				targety_reg &lt;= targety_reg;
				angle_reg &lt;= angle_reg;
				<span style="font-weight: bold">if</span> (targetx_reg &lt; 32&#39;b0 ||targetx_reg &gt; 32&#39;d639 || targety_reg &lt; 32&#39;b0 || targety_reg &gt; 32&#39;d479) <span style="font-weight: bold">begin</span>
					top_state_reg &lt;= TOP_SHIFT;
					x_reg &lt;= targetx_reg;
					y_reg &lt;= targety_reg;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
					<span style="font-weight: bold">if</span> (lsystem == 3&#39;b0 || lsystem == 3&#39;d5) <span style="font-weight: bold">begin</span> 
						top_state_reg &lt;= TOP_GRAPH_DRAGON;
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (lsystem == 3&#39;b1 || lsystem == 3&#39;d2 || lsystem == 3&#39;d3 || lsystem == 3&#39;d4 || lsystem == 3&#39;d6) <span style="font-weight: bold">begin</span>
						top_state_reg &lt;= TOP_GRAPH_TRIANGLE_X;
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span> 
						top_state_reg &lt;= TOP_TARGET;
					<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">end</span>			
			<span style="font-weight: bold">end</span>
			<span style="font-style: italic">//Responsible for graphing when the L-System&#39;s angle_increment is 90 degrees (only straight lines)</span>
			TOP_GRAPH_DRAGON: <span style="font-weight: bold">begin</span>
				timer_counter_reg &lt;= timer_counter_reg + 32&#39;b1;
				top_graphing_reg &lt;= 2&#39;b1;
				top_rdy_reg &lt;= 1&#39;b0;
				targetx_reg &lt;= targetx_reg;
				targety_reg &lt;= targety_reg;
				angle_reg &lt;= angle_reg;
				<span style="font-style: italic">//Only graph on last iteration</span>
				<span style="font-weight: bold">if</span> (iterations_counter == iterations - 4&#39;b1) <span style="font-weight: bold">begin</span>
					<span style="font-weight: bold">if</span> (x_reg[31]  == 1&#39;b1 ||x_reg &gt; 32&#39;d639 || y_reg[31] == 1&#39;b1 || y_reg &gt; 32&#39;d479) <span style="font-weight: bold">begin</span>	<span style="font-style: italic">//bound check</span>
						vga_sram_write &lt;= 1&#39;b0;	<span style="font-style: italic">//don&#39;t graph if out of bounds</span>
						vga_sram_address &lt;= vga_out_base_address; <span style="font-style: italic">// compute address</span>
						vga_sram_writedata &lt;= 8&#39;h00; <span style="font-style: italic">// data</span>
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
						vga_sram_write &lt;= 1&#39;b1;	<span style="font-style: italic">//graph if in bounds</span>
						vga_sram_address &lt;= vga_out_base_address + x_reg + (y_reg*640) ; <span style="font-style: italic">// compute address</span>
						vga_sram_writedata &lt;= color; <span style="font-style: italic">// data</span>
					<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
					vga_sram_write &lt;= 1&#39;b0;	<span style="font-style: italic">//don&#39;t graph before last iteration</span>
					vga_sram_address &lt;= vga_out_base_address; <span style="font-style: italic">// compute address</span>
					vga_sram_writedata &lt;= 8&#39;h00; <span style="font-style: italic">// data</span>
				<span style="font-weight: bold">end</span>

				<span style="font-style: italic">// iterate through all x,y until target is reached</span>
				<span style="font-weight: bold">if</span> (x_reg &lt; targetx_reg) <span style="font-weight: bold">begin</span>
					x_reg &lt;= x_reg + 32&#39;d1 ;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (x_reg &gt; targetx_reg) <span style="font-weight: bold">begin</span>
					x_reg &lt;= x_reg - 32&#39;d1 ;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
					x_reg &lt;= x_reg;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">if</span> (y_reg &lt; targety_reg) <span style="font-weight: bold">begin</span>
					y_reg &lt;= y_reg + 32&#39;d1 ;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (y_reg &gt; targety_reg) <span style="font-weight: bold">begin</span>
					y_reg &lt;= y_reg - 32&#39;d1 ;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
					y_reg &lt;= y_reg;	
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//has target been reached?</span>
				<span style="font-weight: bold">if</span> (x_reg == targetx_reg &amp;&amp; y_reg == targety_reg) <span style="font-weight: bold">begin</span> 
					top_state_reg &lt;= TOP_SHIFT;
				<span style="font-weight: bold">end</span> 
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (x_reg &gt; 32&#39;d4294967295 || y_reg &gt; 32&#39;d4294967295) <span style="font-weight: bold">begin</span> <span style="font-style: italic">//outside of bounds of (2^32)-1 (maximum value stored in 32 bits)</span>
					top_state_reg &lt;= TOP_DONE;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
					top_state_reg &lt;= TOP_GRAPH_DRAGON;
				<span style="font-weight: bold">end</span>			
			<span style="font-weight: bold">end</span>
			<span style="font-style: italic">//Responsible for x graphing when the L-System&#39;s angle_increment is 60 degrees (can have diagonal and straight lines)</span>
			TOP_GRAPH_TRIANGLE_X: <span style="font-weight: bold">begin</span>
				timer_counter_reg &lt;= timer_counter_reg + 32&#39;b1;
				
				top_graphing_reg &lt;= 2&#39;b1;
				top_rdy_reg &lt;= 1&#39;b0;
				targetx_reg &lt;= targetx_reg;
				targety_reg &lt;= targety_reg;
				angle_reg &lt;= angle_reg;
				
				<span style="font-weight: bold">if</span> (iterations_counter == iterations - 4&#39;b1) <span style="font-weight: bold">begin</span>	<span style="font-style: italic">//last iteration (for graphing)</span>
					<span style="font-weight: bold">if</span> (x_reg[31] == 1&#39;b1 ||x_reg &gt; 32&#39;d639 || y_reg[31] == 1&#39;b1 || y_reg &gt; 32&#39;d479) <span style="font-weight: bold">begin</span>	<span style="font-style: italic">//bound check</span>
						vga_sram_write &lt;= 1&#39;b0;	<span style="font-style: italic">//don&#39;t graph if out of bounds</span>
						vga_sram_address &lt;= vga_out_base_address; <span style="font-style: italic">// compute address</span>
						vga_sram_writedata &lt;= 8&#39;h00; <span style="font-style: italic">// data</span>
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
						vga_sram_write &lt;= 1&#39;b1;	<span style="font-style: italic">//graph if in bounds</span>
						vga_sram_address &lt;= vga_out_base_address + x_reg + (y_reg*640) ; <span style="font-style: italic">// compute address</span>
						vga_sram_writedata &lt;= color; <span style="font-style: italic">// data</span>
					<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
					vga_sram_write &lt;= 1&#39;b0;	<span style="font-style: italic">//don&#39;t graph before last iteration</span>
					vga_sram_address &lt;= vga_out_base_address; <span style="font-style: italic">// compute address</span>
					vga_sram_writedata &lt;= 8&#39;h00; <span style="font-style: italic">// data</span>
				<span style="font-weight: bold">end</span>
				
				<span style="font-style: italic">// iterate through all x,y until target is reached</span>
				<span style="font-weight: bold">if</span> (x_reg &lt; targetx_reg) <span style="font-weight: bold">begin</span>
					x_reg &lt;= x_reg + 32&#39;d1 ;
					triangle_x_counter &lt;= triangle_x_counter + 3&#39;b1;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (x_reg &gt; targetx_reg) <span style="font-weight: bold">begin</span>
					x_reg &lt;= x_reg - 32&#39;d1 ;
					triangle_x_counter &lt;= triangle_x_counter + 3&#39;b1;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
					x_reg &lt;= x_reg;
					triangle_x_counter &lt;= 3&#39;b0;
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//has target been reached?</span>
				<span style="font-weight: bold">if</span> (		(angle_reg == 10&#39;d60 &amp;&amp; x_reg &gt;= targetx_reg &amp;&amp; y_reg &lt;= targety_reg) 	||
							(angle_reg == 10&#39;d120 &amp;&amp; x_reg &gt;= targetx_reg &amp;&amp; y_reg &gt;= targety_reg) 	||
							(angle_reg == 10&#39;d180 &amp;&amp; x_reg == targetx_reg &amp;&amp; y_reg == targety_reg) 	||
							(angle_reg == 10&#39;d240 &amp;&amp; x_reg &lt;= targetx_reg &amp;&amp; y_reg &gt;= targety_reg) 	|| 
							(angle_reg == 10&#39;d300 &amp;&amp; x_reg &lt;= targetx_reg &amp;&amp; y_reg &lt;= targety_reg) 	|| 
							(angle_reg == 10&#39;d0 &amp;&amp; x_reg == targetx_reg &amp;&amp; y_reg == targety_reg)) <span style="font-weight: bold">begin</span> 
					top_state_reg &lt;= TOP_SHIFT;
				<span style="font-weight: bold">end</span> 
				<span style="font-style: italic">//continue graphing in the x-direction</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> 	(triangle_x_counter &lt; 3&#39;d2 &amp;&amp; 
						( 	(angle_reg == 10&#39;d60 &amp;&amp; x_reg &lt; targetx_reg) 		||
							(angle_reg == 10&#39;d120 &amp;&amp; x_reg &lt; targetx_reg) 		||
							(angle_reg == 10&#39;d180 &amp;&amp; x_reg != targetx_reg) 		||
							(angle_reg == 10&#39;d240 &amp;&amp; x_reg &gt; targetx_reg) 		|| 
							(angle_reg == 10&#39;d300 &amp;&amp; x_reg &gt; targetx_reg) 		|| 
							(angle_reg == 10&#39;d0 &amp;&amp; x_reg != targetx_reg) 		) 
						) <span style="font-weight: bold">begin</span> 
					top_state_reg &lt;= TOP_GRAPH_TRIANGLE_X;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (x_reg &gt; 32&#39;d4294967295 || y_reg &gt; 32&#39;d4294967295) <span style="font-weight: bold">begin</span> <span style="font-style: italic">//outside of bounds of (2^32)-1 (maximum value stored in 32 bits)</span>
					top_state_reg &lt;= TOP_DONE;
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//continue graphing in the y-direction</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span> 
					triangle_x_counter &lt;= 3&#39;b0;
					top_state_reg &lt;= TOP_GRAPH_TRIANGLE_Y;
				<span style="font-weight: bold">end</span>
			<span style="font-weight: bold">end</span>
			<span style="font-style: italic">//Responsible for y graphing when the L-System&#39;s angle_increment is 60 degrees (can have diagonal and straight lines)</span>
			TOP_GRAPH_TRIANGLE_Y: <span style="font-weight: bold">begin</span>
				timer_counter_reg &lt;= timer_counter_reg + 32&#39;b1;
				top_graphing_reg &lt;= 2&#39;b1;
				top_rdy_reg &lt;= 1&#39;b0;
				targetx_reg &lt;= targetx_reg;
				targety_reg &lt;= targety_reg;
				angle_reg &lt;= angle_reg;
				<span style="font-weight: bold">if</span> (iterations_counter == iterations - 4&#39;b1) <span style="font-weight: bold">begin</span>	<span style="font-style: italic">//last iteration (for graphing)</span>
					<span style="font-weight: bold">if</span> (x_reg[31] == 1&#39;b1 ||x_reg &gt; 32&#39;d639 || y_reg[31] == 1&#39;b1 || y_reg &gt; 32&#39;d479) <span style="font-weight: bold">begin</span>	<span style="font-style: italic">//bound check</span>
						vga_sram_write &lt;= 1&#39;b0;	<span style="font-style: italic">//don&#39;t graph if out of bounds</span>
						vga_sram_address &lt;= vga_out_base_address; <span style="font-style: italic">// compute address</span>
						vga_sram_writedata &lt;= 8&#39;h00; <span style="font-style: italic">// data</span>
					<span style="font-weight: bold">end</span>
					<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
						vga_sram_write &lt;= 1&#39;b1;	<span style="font-style: italic">//graph if in bounds</span>
						vga_sram_address &lt;= vga_out_base_address + x_reg + (y_reg*640) ; <span style="font-style: italic">// compute address</span>
						vga_sram_writedata &lt;= color; <span style="font-style: italic">// data</span>
					<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
					vga_sram_write &lt;= 1&#39;b0;	<span style="font-style: italic">//don&#39;t graph before last iteration</span>
					vga_sram_address &lt;= vga_out_base_address; <span style="font-style: italic">// compute address</span>
					vga_sram_writedata &lt;= 8&#39;h00; <span style="font-style: italic">// data</span>
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">// iterate through all x,y until target is reached</span>
				<span style="font-weight: bold">if</span> (y_reg &lt; targety_reg) <span style="font-weight: bold">begin</span>
					y_reg &lt;= y_reg + 32&#39;d1 ;
					triangle_y_counter &lt;= triangle_y_counter + 3&#39;b1;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (y_reg &gt; targety_reg) <span style="font-weight: bold">begin</span>
					y_reg &lt;= y_reg - 32&#39;d1 ;
					triangle_y_counter &lt;= triangle_y_counter + 3&#39;b1;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
					y_reg &lt;= y_reg;
					triangle_y_counter &lt;= 3&#39;b0;
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//has target been reached?</span>
				<span style="font-weight: bold">if</span> (		(angle_reg == 10&#39;d60 &amp;&amp; x_reg &gt;= targetx_reg &amp;&amp; y_reg &lt;= targety_reg) 	||
							(angle_reg == 10&#39;d120 &amp;&amp; x_reg &gt;= targetx_reg &amp;&amp; y_reg &gt;= targety_reg) 	||
							(angle_reg == 10&#39;d180 &amp;&amp; x_reg == targetx_reg &amp;&amp; y_reg == targety_reg) 	||
							(angle_reg == 10&#39;d240 &amp;&amp; x_reg &lt;= targetx_reg &amp;&amp; y_reg &gt;= targety_reg) 	|| 
							(angle_reg == 10&#39;d300 &amp;&amp; x_reg &lt;= targetx_reg &amp;&amp; y_reg &lt;= targety_reg) 	|| 
							(angle_reg == 10&#39;d0 &amp;&amp; x_reg == targetx_reg &amp;&amp; y_reg == targety_reg)) <span style="font-weight: bold">begin</span> 
					top_state_reg &lt;= TOP_SHIFT;
				<span style="font-weight: bold">end</span> 
				<span style="font-style: italic">//continue graphing in the y-direction</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> 	(triangle_y_counter &lt; 3&#39;d5 &amp;&amp; 
						( 	(angle_reg == 10&#39;d60 &amp;&amp; y_reg &gt; targety_reg) 	||
							(angle_reg == 10&#39;d120 &amp;&amp; y_reg &lt; targety_reg) 	||
							(angle_reg == 10&#39;d180 &amp;&amp; y_reg != targety_reg) 	||
							(angle_reg == 10&#39;d240 &amp;&amp; y_reg &lt; targety_reg) 	|| 
							(angle_reg == 10&#39;d300 &amp;&amp; y_reg &gt; targety_reg) 	|| 
							(angle_reg == 10&#39;d0 &amp;&amp; y_reg != targety_reg) 		) 
						) <span style="font-weight: bold">begin</span> 
					top_state_reg &lt;= TOP_GRAPH_TRIANGLE_Y;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (x_reg &gt; 32&#39;d4294967295 || y_reg &gt; 32&#39;d4294967295) <span style="font-weight: bold">begin</span> <span style="font-style: italic">//outside of bounds of (2^32)-1 (maximum value stored in 32 bits)</span>
					top_state_reg &lt;= TOP_DONE;
				<span style="font-weight: bold">end</span>
				<span style="font-style: italic">//continue graphing in the x-direction</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span> 
					triangle_y_counter &lt;= 3&#39;b0;
					top_state_reg &lt;= TOP_GRAPH_TRIANGLE_X;
				<span style="font-weight: bold">end</span>		
			<span style="font-weight: bold">end</span>
			<span style="font-style: italic">//Graphing complete, time to wait for next character</span>
			TOP_SHIFT: <span style="font-weight: bold">begin</span>
				timer_counter_reg &lt;= timer_counter_reg + 32&#39;b1;
				top_graphing_reg &lt;= 2&#39;d2;
				top_rdy_reg &lt;= 1&#39;b0;
				top_done_reg &lt;= 1&#39;b0;
				vga_sram_write &lt;= 1&#39;b0;
				vga_sram_address &lt;= vga_out_base_address;
				vga_sram_writedata &lt;= 8&#39;h00;
				x_reg &lt;= x_reg;
				y_reg &lt;= y_reg;
				targetx_reg &lt;= targetx_reg;
				targety_reg &lt;= targety_reg;
				angle_reg &lt;= angle_reg;
				system_output_string_reg &lt;= system_output_string_reg;
				top_state_reg &lt;= TOP_WAIT;
			<span style="font-weight: bold">end</span>
			<span style="font-style: italic">//system_done signal received from create_system, so there are no more characters to graph</span>
			TOP_DONE: <span style="font-weight: bold">begin</span>
				timer_counter_reg &lt;= timer_counter_reg;
				top_graphing_reg &lt;= 2&#39;b0;
				top_rdy_reg &lt;= 1&#39;b0;
				top_done_reg &lt;= 1&#39;b1;
				vga_sram_write &lt;= 1&#39;b0;
				vga_sram_address &lt;= vga_out_base_address;
				vga_sram_writedata &lt;= 8&#39;h00;
				x_reg &lt;= x_reg;
				y_reg &lt;= y_reg;
				targetx_reg &lt;= targetx_reg;
				targety_reg &lt;= targety_reg;
				angle_reg &lt;= angle_reg;
				<span style="font-weight: bold">if</span> (reset) <span style="font-weight: bold">begin</span>
					top_state_reg &lt;= TOP_RESET;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
					top_state_reg &lt;= TOP_DONE;
				<span style="font-weight: bold">end</span>				
			<span style="font-weight: bold">end</span>
			<span style="font-weight: bold">default</span>: <span style="font-weight: bold">begin</span>
				timer_counter_reg &lt;= 32&#39;b0;
				system_output_string_reg &lt;= system_output_string;
				top_state_reg &lt;= TOP_WAIT;
				top_graphing_reg &lt;= 2&#39;b0;
				top_rdy_reg &lt;= 1&#39;b0;
				top_done_reg &lt;= 1&#39;b0;
				vga_sram_write &lt;= 1&#39;b0;
				vga_sram_address &lt;= vga_out_base_address;
				vga_sram_writedata &lt;= 8&#39;h00;
				x_reg &lt;= x_reg;
				y_reg &lt;= y_reg;
				targetx_reg &lt;= targetx_reg;
				targety_reg &lt;= targety_reg;
				angle_reg &lt;= angle_reg;
				<span style="font-weight: bold">if</span> (lsystem == 3&#39;b0 || lsystem == 3&#39;d5) <span style="font-weight: bold">begin</span> 
					angle_increment &lt;= 10&#39;d90;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (lsystem == 3&#39;b1 || lsystem == 3&#39;d2 || lsystem == 3&#39;d3 || lsystem == 3&#39;d4) <span style="font-weight: bold">begin</span> 
					angle_increment &lt;= 10&#39;d60;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (lsystem == 3&#39;d6) <span style="font-weight: bold">begin</span> 
					angle_increment &lt;= 10&#39;d120;
				<span style="font-weight: bold">end</span>
				<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span> 
					angle_increment &lt;= 10&#39;d0;
				<span style="font-weight: bold">end</span>
			<span style="font-weight: bold">end</span>
		<span style="font-weight: bold">endcase</span>
	<span style="font-weight: bold">end</span>	
<span style="font-weight: bold">end</span>

<span style="font-style: italic">//=======================================================</span>
<span style="font-style: italic">//  Structural coding</span>
<span style="font-style: italic">//=======================================================</span>
<span style="font-style: italic">// From Qsys</span>

Computer_System The_System (
	<span style="font-style: italic">////////////////////////////////////</span>
	<span style="font-style: italic">// FPGA Side</span>
	<span style="font-style: italic">////////////////////////////////////</span>
	
	<span style="font-style: italic">//PIO port connections</span>
	.reset_external_connection_export			(reset),
	.lsystem_char_external_connection_export	(top_char),
	.axiom_external_connection_export			(axiom),
	.iterations_external_connection_export		(iterations),
	.length_external_connection_export			(length),
	.lsystem_external_connection_export			(lsystem),
	.start_x_external_connection_export       (start_x),
	.start_y_external_connection_export			(start_y),
	.timing_external_connection_export			(timer_counter),
	.color_external_connection_export			(color),
	
	<span style="font-style: italic">// Global signals</span>
	.system_pll_ref_clk_clk					(CLOCK_50),
	.system_pll_ref_reset_reset			(1&#39;b0),
	
	<span style="font-style: italic">// SRAM shared block with HPS</span>
	.onchip_sram_s1_address               (sram_address),               
	.onchip_sram_s1_clken                 (sram_clken),                 
	.onchip_sram_s1_chipselect            (sram_chipselect),            
	.onchip_sram_s1_write                 (sram_write),                 
	.onchip_sram_s1_readdata              (sram_readdata),              
	.onchip_sram_s1_writedata             (sram_writedata),             
	.onchip_sram_s1_byteenable            (4&#39;b1111), 
	
	<span style="font-style: italic">//  sram to video</span>
	.onchip_vga_buffer_s1_address    (vga_sram_address),    
	.onchip_vga_buffer_s1_clken      (vga_sram_clken),      
	.onchip_vga_buffer_s1_chipselect (vga_sram_chipselect), 
	.onchip_vga_buffer_s1_write      (vga_sram_write),      
	.onchip_vga_buffer_s1_readdata   (),   <span style="font-style: italic">// never read from vga here</span>
	.onchip_vga_buffer_s1_writedata  (vga_sram_writedata),   

	<span style="font-style: italic">// AV Config</span>
	.av_config_SCLK							(FPGA_I2C_SCLK),
	.av_config_SDAT							(FPGA_I2C_SDAT),

	<span style="font-style: italic">// 50 MHz clock bridge</span>
	.clock_bridge_0_in_clk_clk            (CLOCK_50), <span style="font-style: italic">//(CLOCK_50), </span>
	
	<span style="font-style: italic">// VGA Subsystem</span>
	.vga_pll_ref_clk_clk 					(CLOCK2_50),
	.vga_pll_ref_reset_reset				(1&#39;b0),
	.vga_CLK										(VGA_CLK),
	.vga_BLANK									(VGA_BLANK_N),
	.vga_SYNC									(VGA_SYNC_N),
	.vga_HS										(VGA_HS),
	.vga_VS										(VGA_VS),
	.vga_R										(VGA_R),
	.vga_G										(VGA_G),
	.vga_B										(VGA_B),
		
	<span style="font-style: italic">// SDRAM</span>
	.sdram_clk_clk								(DRAM_CLK),
   .sdram_addr									(DRAM_ADDR),
	.sdram_ba									(DRAM_BA),
	.sdram_cas_n								(DRAM_CAS_N),
	.sdram_cke									(DRAM_CKE),
	.sdram_cs_n									(DRAM_CS_N),
	.sdram_dq									(DRAM_DQ),
	.sdram_dqm									({DRAM_UDQM,DRAM_LDQM}),
	.sdram_ras_n								(DRAM_RAS_N),
	.sdram_we_n									(DRAM_WE_N),
	
	<span style="font-style: italic">////////////////////////////////////</span>
	<span style="font-style: italic">// HPS Side</span>
	<span style="font-style: italic">////////////////////////////////////</span>
	<span style="font-style: italic">// DDR3 SDRAM</span>
	.memory_mem_a			(HPS_DDR3_ADDR),
	.memory_mem_ba			(HPS_DDR3_BA),
	.memory_mem_ck			(HPS_DDR3_CK_P),
	.memory_mem_ck_n		(HPS_DDR3_CK_N),
	.memory_mem_cke		(HPS_DDR3_CKE),
	.memory_mem_cs_n		(HPS_DDR3_CS_N),
	.memory_mem_ras_n		(HPS_DDR3_RAS_N),
	.memory_mem_cas_n		(HPS_DDR3_CAS_N),
	.memory_mem_we_n		(HPS_DDR3_WE_N),
	.memory_mem_reset_n	(HPS_DDR3_RESET_N),
	.memory_mem_dq			(HPS_DDR3_DQ),
	.memory_mem_dqs		(HPS_DDR3_DQS_P),
	.memory_mem_dqs_n		(HPS_DDR3_DQS_N),
	.memory_mem_odt		(HPS_DDR3_ODT),
	.memory_mem_dm			(HPS_DDR3_DM),
	.memory_oct_rzqin		(HPS_DDR3_RZQ),
		  
	<span style="font-style: italic">// Ethernet</span>
	.hps_io_hps_io_gpio_inst_GPIO35	(HPS_ENET_INT_N),
	.hps_io_hps_io_emac1_inst_TX_CLK	(HPS_ENET_GTX_CLK),
	.hps_io_hps_io_emac1_inst_TXD0	(HPS_ENET_TX_DATA[0]),
	.hps_io_hps_io_emac1_inst_TXD1	(HPS_ENET_TX_DATA[1]),
	.hps_io_hps_io_emac1_inst_TXD2	(HPS_ENET_TX_DATA[2]),
	.hps_io_hps_io_emac1_inst_TXD3	(HPS_ENET_TX_DATA[3]),
	.hps_io_hps_io_emac1_inst_RXD0	(HPS_ENET_RX_DATA[0]),
	.hps_io_hps_io_emac1_inst_MDIO	(HPS_ENET_MDIO),
	.hps_io_hps_io_emac1_inst_MDC		(HPS_ENET_MDC),
	.hps_io_hps_io_emac1_inst_RX_CTL	(HPS_ENET_RX_DV),
	.hps_io_hps_io_emac1_inst_TX_CTL	(HPS_ENET_TX_EN),
	.hps_io_hps_io_emac1_inst_RX_CLK	(HPS_ENET_RX_CLK),
	.hps_io_hps_io_emac1_inst_RXD1	(HPS_ENET_RX_DATA[1]),
	.hps_io_hps_io_emac1_inst_RXD2	(HPS_ENET_RX_DATA[2]),
	.hps_io_hps_io_emac1_inst_RXD3	(HPS_ENET_RX_DATA[3]),

	<span style="font-style: italic">// Flash</span>
	.hps_io_hps_io_qspi_inst_IO0	(HPS_FLASH_DATA[0]),
	.hps_io_hps_io_qspi_inst_IO1	(HPS_FLASH_DATA[1]),
	.hps_io_hps_io_qspi_inst_IO2	(HPS_FLASH_DATA[2]),
	.hps_io_hps_io_qspi_inst_IO3	(HPS_FLASH_DATA[3]),
	.hps_io_hps_io_qspi_inst_SS0	(HPS_FLASH_NCSO),
	.hps_io_hps_io_qspi_inst_CLK	(HPS_FLASH_DCLK),

	<span style="font-style: italic">// Accelerometer</span>
	.hps_io_hps_io_gpio_inst_GPIO61	(HPS_GSENSOR_INT),

	<span style="font-style: italic">//.adc_sclk                        (ADC_SCLK),</span>
	<span style="font-style: italic">//.adc_cs_n                        (ADC_CS_N),</span>
	<span style="font-style: italic">//.adc_dout                        (ADC_DOUT),</span>
	<span style="font-style: italic">//.adc_din                         (ADC_DIN),</span>

	<span style="font-style: italic">// General Purpose I/O</span>
	.hps_io_hps_io_gpio_inst_GPIO40	(HPS_GPIO[0]),
	.hps_io_hps_io_gpio_inst_GPIO41	(HPS_GPIO[1]),

	<span style="font-style: italic">// I2C</span>
	.hps_io_hps_io_gpio_inst_GPIO48	(HPS_I2C_CONTROL),
	.hps_io_hps_io_i2c0_inst_SDA		(HPS_I2C1_SDAT),
	.hps_io_hps_io_i2c0_inst_SCL		(HPS_I2C1_SCLK),
	.hps_io_hps_io_i2c1_inst_SDA		(HPS_I2C2_SDAT),
	.hps_io_hps_io_i2c1_inst_SCL		(HPS_I2C2_SCLK),

	<span style="font-style: italic">// Pushbutton</span>
	.hps_io_hps_io_gpio_inst_GPIO54	(HPS_KEY),

	<span style="font-style: italic">// LED</span>
	.hps_io_hps_io_gpio_inst_GPIO53	(HPS_LED),

	<span style="font-style: italic">// SD Card</span>
	.hps_io_hps_io_sdio_inst_CMD	(HPS_SD_CMD),
	.hps_io_hps_io_sdio_inst_D0	(HPS_SD_DATA[0]),
	.hps_io_hps_io_sdio_inst_D1	(HPS_SD_DATA[1]),
	.hps_io_hps_io_sdio_inst_CLK	(HPS_SD_CLK),
	.hps_io_hps_io_sdio_inst_D2	(HPS_SD_DATA[2]),
	.hps_io_hps_io_sdio_inst_D3	(HPS_SD_DATA[3]),

	<span style="font-style: italic">// SPI</span>
	.hps_io_hps_io_spim1_inst_CLK		(HPS_SPIM_CLK),
	.hps_io_hps_io_spim1_inst_MOSI	(HPS_SPIM_MOSI),
	.hps_io_hps_io_spim1_inst_MISO	(HPS_SPIM_MISO),
	.hps_io_hps_io_spim1_inst_SS0		(HPS_SPIM_SS),

	<span style="font-style: italic">// UART</span>
	.hps_io_hps_io_uart0_inst_RX	(HPS_UART_RX),
	.hps_io_hps_io_uart0_inst_TX	(HPS_UART_TX),

	<span style="font-style: italic">// USB</span>
	.hps_io_hps_io_gpio_inst_GPIO09	(HPS_CONV_USB_N),
	.hps_io_hps_io_usb1_inst_D0		(HPS_USB_DATA[0]),
	.hps_io_hps_io_usb1_inst_D1		(HPS_USB_DATA[1]),
	.hps_io_hps_io_usb1_inst_D2		(HPS_USB_DATA[2]),
	.hps_io_hps_io_usb1_inst_D3		(HPS_USB_DATA[3]),
	.hps_io_hps_io_usb1_inst_D4		(HPS_USB_DATA[4]),
	.hps_io_hps_io_usb1_inst_D5		(HPS_USB_DATA[5]),
	.hps_io_hps_io_usb1_inst_D6		(HPS_USB_DATA[6]),
	.hps_io_hps_io_usb1_inst_D7		(HPS_USB_DATA[7]),
	.hps_io_hps_io_usb1_inst_CLK		(HPS_USB_CLKOUT),
	.hps_io_hps_io_usb1_inst_STP		(HPS_USB_STP),
	.hps_io_hps_io_usb1_inst_DIR		(HPS_USB_DIR),
	.hps_io_hps_io_usb1_inst_NXT		(HPS_USB_NXT)
);
<span style="font-weight: bold">endmodule</span> <span style="font-style: italic">// end top level</span>

<span style="font-style: italic">//============================================================</span>
<span style="font-style: italic">// M10K module for testing</span>
<span style="font-style: italic">//============================================================</span>
<span style="font-style: italic">// See example 12-16 in </span>
<span style="font-style: italic">// http://people.ece.cornell.edu/land/courses/ece5760/DE1_SOC/HDL_style_qts_qii51007.pdf</span>
<span style="font-style: italic">//============================================================</span>

<span style="font-weight: bold">module</span> M10K_256_32( 
    <span style="font-weight: bold">output</span> <span style="font-weight: bold">reg</span> [31:0] q,
    <span style="font-weight: bold">input</span> [31:0] d,
    <span style="font-weight: bold">input</span> [7:0] write_address, read_address,
    <span style="font-weight: bold">input</span> we, clk
);
	 <span style="font-style: italic">// force M10K ram style</span>
	 <span style="font-style: italic">// 256 words of 32 bits</span>
    <span style="font-weight: bold">reg</span> [31:0] mem [255:0]  <span style="font-style: italic">/* synthesis ramstyle = &quot;no_rw_check, M10K&quot; */</span>;
	 
    <span style="font-weight: bold">always</span> @ (<span style="font-weight: bold">posedge</span> clk) <span style="font-weight: bold">begin</span>
        <span style="font-weight: bold">if</span> (we) <span style="font-weight: bold">begin</span>
            mem[write_address] &lt;= d;
		  <span style="font-weight: bold">end</span>
        q &lt;= mem[read_address]; <span style="font-style: italic">// q doesn&#39;t get d in this clock cycle</span>
    <span style="font-weight: bold">end</span>
<span style="font-weight: bold">endmodule</span>

<span style="font-style: italic">//============================================================</span>
<span style="font-style: italic">// MLAB module for testing</span>
<span style="font-style: italic">//============================================================</span>
<span style="font-style: italic">// See example 12-16 in </span>
<span style="font-style: italic">// http://people.ece.cornell.edu/land/courses/ece5760/DE1_SOC/HDL_style_qts_qii51007.pdf</span>
<span style="font-style: italic">//============================================================</span>
<span style="font-weight: bold">module</span> MLAB_20_32(
	<span style="font-weight: bold">output</span> <span style="font-weight: bold">reg</span> <span style="font-weight: bold">signed</span> [31:0] q,
	<span style="font-weight: bold">input</span>  [31:0] data,
	<span style="font-weight: bold">input</span> [7:0] readaddr, writeaddr,
	<span style="font-weight: bold">input</span> wren, clock
);
	<span style="font-style: italic">// force MLAB ram style</span>
	<span style="font-style: italic">// 20 words of 32 bits</span>
	<span style="font-weight: bold">reg</span> <span style="font-weight: bold">signed</span> [31:0] mem [19:0] <span style="font-style: italic">/* synthesis ramstyle = &quot;no_rw_check, MLAB&quot; */</span>;
	
	<span style="font-weight: bold">always</span> @ (<span style="font-weight: bold">posedge</span> clock)
	<span style="font-weight: bold">begin</span>
		<span style="font-weight: bold">if</span> (wren) <span style="font-weight: bold">begin</span>
			mem[writeaddr] &lt;= data;
		<span style="font-weight: bold">end</span>
		q &lt;= mem[readaddr];
	<span style="font-weight: bold">end</span>
<span style="font-weight: bold">endmodule</span>

<span style="font-style: italic">/**************************************************************************</span>
<span style="font-style: italic"> * Following floating point modules written by Bruce Land                                       </span>
<span style="font-style: italic"> * March 2017      </span>
<span style="font-style: italic"> *************************************************************************/</span>
<span style="font-style: italic">/**************************************************************************</span>
<span style="font-style: italic"> * Floating Point to 16-bit integer                                             *</span>
<span style="font-style: italic"> * Combinational      </span>
<span style="font-style: italic"> * Numbers with mag &gt; than +/-32768 get clipped to 32768 or -32768</span>
<span style="font-style: italic"> *************************************************************************/</span>
 <span style="font-weight: bold">module</span> Int2Fp(
		<span style="font-weight: bold">input</span> <span style="font-weight: bold">signed</span> [15:0]	iInteger,
		<span style="font-weight: bold">output</span>[26:0]	oA		
 );
		<span style="font-style: italic">// output fields</span>
    <span style="font-weight: bold">wire</span>        A_s;
    <span style="font-weight: bold">wire</span> [7:0]  A_e;
    <span style="font-weight: bold">wire</span> [17:0] A_f;
    
	 <span style="font-weight: bold">wire</span> [15:0] abs_input ;
	 <span style="font-style: italic">// get output sign bit</span>
	 <span style="font-weight: bold">assign</span> A_s = (iInteger &lt; 0);
	 <span style="font-style: italic">// remove sign from input</span>
	 <span style="font-weight: bold">assign</span> abs_input = (iInteger &lt; 0)? -iInteger : iInteger ;
	 
	 <span style="font-style: italic">// find the most significant (nonzero) bit</span>
	 <span style="font-weight: bold">wire</span> [7:0]  shft_amt;
	 <span style="font-weight: bold">assign</span> shft_amt = abs_input[15] ? 8&#39;d3 :
                      abs_input[14] ? 8&#39;d4 : abs_input[13] ? 8&#39;d5 :
                      abs_input[12] ? 8&#39;d6 : abs_input[11] ? 8&#39;d7 :
                      abs_input[10] ? 8&#39;d8 : abs_input[9]  ? 8&#39;d9 :
                      abs_input[8]  ? 8&#39;d10 : abs_input[7]  ? 8&#39;d11 :
                      abs_input[6]  ? 8&#39;d12 : abs_input[5]  ? 8&#39;d13 :
                      abs_input[4]  ? 8&#39;d14 : abs_input[3]  ? 8&#39;d15 :
                      abs_input[2]  ? 8&#39;d16 : abs_input[1]  ? 8&#39;d17 :
                      abs_input[0]  ? 8&#39;d18 : 8&#39;d19;	
	 <span style="font-style: italic">// exponent 127 + (18-shift_amt)</span>
	 <span style="font-style: italic">// 127 is 2^0</span>
	 <span style="font-style: italic">// 18 is amount &#39;1&#39; is shifted</span>
	 <span style="font-weight: bold">assign</span> A_e = 127 + 18 - shft_amt ;
	 <span style="font-style: italic">// where the intermediate value is formed</span>
	 <span style="font-weight: bold">wire</span> [33:0] shift_buffer ;
	 <span style="font-style: italic">// remember that the high-order &#39;1&#39; is not stored,</span>
	 <span style="font-style: italic">// but is shifted to bit 18</span>
	 <span style="font-weight: bold">assign</span> shift_buffer = {16&#39;b0, abs_input} &lt;&lt; shft_amt ;
	 <span style="font-weight: bold">assign</span> A_f = shift_buffer[17:0];
	 <span style="font-weight: bold">assign</span> oA = (iInteger==0)? 27&#39;b0 : {A_s, A_e, A_f};
	 
 <span style="font-weight: bold">endmodule</span> <span style="font-style: italic">//Int2Fp</span>
 
 <span style="font-style: italic">/**************************************************************************</span>
<span style="font-style: italic"> * Floating Point to 16-bit integer                                             *</span>
<span style="font-style: italic"> * Combinational      </span>
<span style="font-style: italic"> * Numbers with mag &gt; than +/-32768 get clipped to 32768 or -32768</span>
<span style="font-style: italic"> *************************************************************************/</span>
 <span style="font-weight: bold">module</span> Fp2Int(
		<span style="font-weight: bold">input</span>	 [26:0]	iA,
		<span style="font-weight: bold">output</span> <span style="font-weight: bold">reg</span> [15:0]	oInteger
 );
		<span style="font-style: italic">// Extract fields of A and B.</span>
    <span style="font-weight: bold">wire</span>        A_s;
    <span style="font-weight: bold">wire</span> [7:0]  A_e;
    <span style="font-weight: bold">wire</span> [17:0] A_f;
    <span style="font-weight: bold">assign</span> A_s = iA[26];
    <span style="font-weight: bold">assign</span> A_e = iA[25:18];
    <span style="font-weight: bold">assign</span> A_f = iA[17:0];
	 
	 <span style="font-weight: bold">wire</span> [15:0] max_int = 16&#39;h7fff ; <span style="font-style: italic">//32768</span>
	 <span style="font-weight: bold">wire</span> [33:0] shift_buffer ;
	 <span style="font-style: italic">// form (1.A_f) and shift it to postiion</span>
	 <span style="font-weight: bold">assign</span> shift_buffer = {15&#39;b0, 1&#39;b1, A_f}&lt;&lt;(A_e-127) ;
	 
	 <span style="font-style: italic">// If exponent less than 127, oInteger=0</span>
	 <span style="font-style: italic">// If exponent greater than 127+14 oInteger=max value</span>
	 <span style="font-style: italic">// Between these two values:</span>
	 <span style="font-style: italic">//	set up input mantissa with 1.mantissa </span>
	 <span style="font-style: italic">//	   and the &quot;1.&quot; in the lowest bit of an extended word.</span>
	 <span style="font-style: italic">// 	shift-left by A_e-127</span>
	 <span style="font-style: italic">// If the sign bit is set, negate oInteger</span>
	 	
	 <span style="font-weight: bold">always</span> @(*) <span style="font-weight: bold">begin</span>
			<span style="font-weight: bold">if</span> (A_e &lt; 127) oInteger = 16&#39;b0;
			<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (A_e &gt; 141) <span style="font-weight: bold">begin</span>
				<span style="font-weight: bold">if</span> (A_s) oInteger = -max_int;
				<span style="font-weight: bold">else</span>     oInteger = max_int;
			<span style="font-weight: bold">end</span>
			<span style="font-weight: bold">else</span> <span style="font-weight: bold">begin</span>
				<span style="font-weight: bold">if</span> (A_s) oInteger = -shift_buffer[33:18];
				<span style="font-weight: bold">else</span>     oInteger = shift_buffer[33:18];
			<span style="font-weight: bold">end</span>
	 <span style="font-weight: bold">end</span>
	 
 <span style="font-weight: bold">endmodule</span> <span style="font-style: italic">//Fp2Int</span>
 
<span style="font-style: italic">/**************************************************************************</span>
<span style="font-style: italic"> * Floating Point shift                                             *</span>
<span style="font-style: italic"> * Combinational      </span>
<span style="font-style: italic"> * Negative shift input is right shift</span>
<span style="font-style: italic"> *************************************************************************/</span>
 <span style="font-weight: bold">module</span> FpShift(
		<span style="font-weight: bold">input</span>	 [26:0]	iA,
		<span style="font-weight: bold">input</span>   [7:0] 	iShift,
		<span style="font-weight: bold">output</span> [26:0]	oShifted
 );
		<span style="font-style: italic">// Extract fields of A and B.</span>
    <span style="font-weight: bold">wire</span>        A_s;
    <span style="font-weight: bold">wire</span> [7:0]  A_e;
    <span style="font-weight: bold">wire</span> [17:0] A_f;
    <span style="font-weight: bold">assign</span> A_s = iA[26];
    <span style="font-weight: bold">assign</span> A_e = iA[25:18];
    <span style="font-weight: bold">assign</span> A_f = iA[17:0];
	 <span style="font-style: italic">// Flip bit 26</span>
	 <span style="font-style: italic">// zero the output if underflow/overflow</span>
<span style="font-style: italic">//    assign oShifted = (A_e+iShift&lt;8&#39;d254 &amp;&amp; A_e+iShift&gt;8&#39;d2)? </span>
<span style="font-style: italic">//									{A_s, A_e+iShift, A_f} </span>
	 <span style="font-weight: bold">assign</span> oShifted = {A_s, A_e+iShift, A_f} ;	
 <span style="font-weight: bold">endmodule</span> <span style="font-style: italic">//FpShift</span>
 
<span style="font-style: italic">/**************************************************************************</span>
<span style="font-style: italic"> * Floating Point sign negation                                             *</span>
<span style="font-style: italic"> * Combinational                                                          *</span>
<span style="font-style: italic"> *************************************************************************/</span>
 <span style="font-weight: bold">module</span> FpNegate(
		<span style="font-weight: bold">input</span>	 [26:0]	iA,
		<span style="font-weight: bold">output</span> [26:0]	oNegative
 );
		<span style="font-style: italic">// Extract fields of A and B.</span>
    <span style="font-weight: bold">wire</span>        A_s;
    <span style="font-weight: bold">wire</span> [7:0]  A_e;
    <span style="font-weight: bold">wire</span> [17:0] A_f;
    <span style="font-weight: bold">assign</span> A_s = iA[26];
    <span style="font-weight: bold">assign</span> A_e = iA[25:18];
    <span style="font-weight: bold">assign</span> A_f = iA[17:0];
	 <span style="font-style: italic">// Flip bit 26</span>
    <span style="font-weight: bold">assign</span> oNegative = {~A_s, A_e, A_f};	
 <span style="font-weight: bold">endmodule</span> <span style="font-style: italic">//FpNegate</span>

 <span style="font-style: italic">/**************************************************************************</span>
<span style="font-style: italic"> * Floating Point absolute                                             *</span>
<span style="font-style: italic"> * Combinational                                                          *</span>
<span style="font-style: italic"> *************************************************************************/</span>
 <span style="font-weight: bold">module</span> FpAbs(
		<span style="font-weight: bold">input</span>	 [26:0]	iA,
		<span style="font-weight: bold">output</span> [26:0]	oAbs
 );
		<span style="font-style: italic">// Extract fields of A and B.</span>
    <span style="font-weight: bold">wire</span>        A_s;
    <span style="font-weight: bold">wire</span> [7:0]  A_e;
    <span style="font-weight: bold">wire</span> [17:0] A_f;
    <span style="font-weight: bold">assign</span> A_s = iA[26];
    <span style="font-weight: bold">assign</span> A_e = iA[25:18];
    <span style="font-weight: bold">assign</span> A_f = iA[17:0];
	 <span style="font-style: italic">// zero bit 26</span>
    <span style="font-weight: bold">assign</span> oAbs = {1&#39;b0, A_e, A_f};	
 <span style="font-weight: bold">endmodule</span> <span style="font-style: italic">//Fp absolute</span>
 
 <span style="font-style: italic">/**************************************************************************</span>
<span style="font-style: italic"> * Floating Point compare                                             *</span>
<span style="font-style: italic"> * Combinational     </span>
<span style="font-style: italic"> * output=1 if A&gt;=B</span>
<span style="font-style: italic"> *************************************************************************/</span>
 <span style="font-weight: bold">module</span> FpCompare(
		<span style="font-weight: bold">input</span>	 [26:0]	iA,
		<span style="font-weight: bold">input</span>	 [26:0]	iB,
		<span style="font-weight: bold">output</span> <span style="font-weight: bold">reg</span> oA_larger
 );
		<span style="font-style: italic">// Extract fields of A and B.</span>
    <span style="font-weight: bold">wire</span>        A_s;
    <span style="font-weight: bold">wire</span> [7:0]  A_e;
    <span style="font-weight: bold">wire</span> [17:0] A_f;
	 <span style="font-weight: bold">wire</span>        B_s;
    <span style="font-weight: bold">wire</span> [7:0]  B_e;
    <span style="font-weight: bold">wire</span> [17:0] B_f;
    
    <span style="font-weight: bold">assign</span> A_s = iA[26];
    <span style="font-weight: bold">assign</span> A_e = iA[25:18];
    <span style="font-weight: bold">assign</span> A_f = iA[17:0];
	 <span style="font-weight: bold">assign</span> B_s = iB[26];
    <span style="font-weight: bold">assign</span> B_e = iB[25:18];
    <span style="font-weight: bold">assign</span> B_f = iB[17:0];
	 
	 <span style="font-style: italic">// Determine which of A, B is larger</span>
	 <span style="font-weight: bold">wire</span> A_mag_larger ;
    <span style="font-weight: bold">assign</span> A_mag_larger =(A_e &gt; B_e)                   ? 1&#39;b1  :
                         ((A_e == B_e) &amp;&amp; (A_f &gt;= B_f)) ? 1&#39;b1  :
                         1&#39;b0;
								 
	 <span style="font-style: italic">// now do the sign checks</span>
	 <span style="font-weight: bold">always</span> @(*) <span style="font-weight: bold">begin</span>
			<span style="font-weight: bold">if</span> (A_s==0 &amp;&amp; B_s==1) <span style="font-weight: bold">begin</span>  <span style="font-style: italic">// A positive, B negative</span>
				oA_larger = 1&#39;b1 ;
			<span style="font-weight: bold">end</span>
			<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (A_s==1 &amp;&amp; B_s==0) <span style="font-weight: bold">begin</span>  <span style="font-style: italic">// A negative, B positive</span>
				oA_larger = 1&#39;b0 ;
			<span style="font-weight: bold">end</span>
			<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (A_s==0 &amp;&amp; B_s==0) <span style="font-weight: bold">begin</span>  <span style="font-style: italic">// A positive, B positive</span>
				oA_larger = A_mag_larger ;
			<span style="font-weight: bold">end</span>
			<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (A_s==1 &amp;&amp; B_s==1) <span style="font-weight: bold">begin</span>  <span style="font-style: italic">// A negative, B negative</span>
				oA_larger = ~A_mag_larger ;
			<span style="font-weight: bold">end</span>
			<span style="font-weight: bold">else</span> oA_larger  = 0; <span style="font-style: italic">// make sure no inferred latch</span>
	 <span style="font-weight: bold">end</span>
 <span style="font-weight: bold">endmodule</span> <span style="font-style: italic">//FpCompare</span>
 
<span style="font-style: italic">/**************************************************************************</span>
<span style="font-style: italic"> * Following floating point written by Mark Eiding mje56                                                      *</span>
<span style="font-style: italic"> * ECE 5760                                                               *</span>
<span style="font-style: italic"> * Modified IEEE single precision FP                                      *</span>
<span style="font-style: italic"> * bit 26:      Sign     (0: pos, 1: neg)                                 *</span>
<span style="font-style: italic"> * bits[25:18]: Exponent (unsigned)                                       *</span>
<span style="font-style: italic"> * bits[17:0]:  Fraction (unsigned)                                       *</span>
<span style="font-style: italic"> *  (-1)^SIGN * 2^(EXP-127) * (1+.FRAC)                                   *</span>
<span style="font-style: italic"> * (http://en.wikipedia.org/wiki/Single-precision_floating-point_format)  *</span>
<span style="font-style: italic"> * Adapted from Skyler Schneider ss868                                    *</span>
<span style="font-style: italic"> *************************************************************************/</span>
<span style="font-style: italic">/**************************************************************************</span>
<span style="font-style: italic"> * Floating Point Fast Inverse Square Root                                *</span>
<span style="font-style: italic"> * 5-stage pipeline                                                       *</span>
<span style="font-style: italic"> * http://en.wikipedia.org/wiki/Fast_inverse_square_root                  *</span>
<span style="font-style: italic"> * Magic number 27&#39;d49920718                                              *</span>
<span style="font-style: italic"> * 1.5 = 27&#39;d33423360                                                     *</span>
<span style="font-style: italic"> *************************************************************************/</span>
<span style="font-weight: bold">module</span> FpInvSqrt (
    <span style="font-weight: bold">input</span>             iCLK,
    <span style="font-weight: bold">input</span>      [26:0] iA,
    <span style="font-weight: bold">output</span>     [26:0] oInvSqrt
);

    <span style="font-style: italic">// Extract fields of A and B.</span>
    <span style="font-weight: bold">wire</span>        A_s;
    <span style="font-weight: bold">wire</span> [7:0]  A_e;
    <span style="font-weight: bold">wire</span> [17:0] A_f;
    <span style="font-weight: bold">assign</span> A_s = iA[26];
    <span style="font-weight: bold">assign</span> A_e = iA[25:18];
    <span style="font-weight: bold">assign</span> A_f = iA[17:0];

    <span style="font-style: italic">//Stage 1</span>
    <span style="font-weight: bold">wire</span> [26:0] y_1, y_1_out, half_iA_1;
    <span style="font-weight: bold">assign</span> y_1 = 27&#39;d49920718 - (iA&gt;&gt;1);
    <span style="font-weight: bold">assign</span> half_iA_1 = {A_s, A_e-8&#39;d1,A_f};
    FpMul s1_mult ( .iA(y_1), .iB(y_1), .oProd(y_1_out) );
    <span style="font-style: italic">//Stage 2</span>
    <span style="font-weight: bold">reg</span> [26:0] y_2, mult_2_in, half_iA_2;
    <span style="font-weight: bold">wire</span> [26:0] y_2_out;
    FpMul s2_mult ( .iA(half_iA_2), .iB(mult_2_in), .oProd(y_2_out) );
    <span style="font-style: italic">//Stage 3</span>
    <span style="font-weight: bold">reg</span> [26:0] y_3, add_3_in;
    <span style="font-weight: bold">wire</span> [26:0] y_3_out;
    FpAdd s3_add ( .iCLK(iCLK), .iA({~add_3_in[26],add_3_in[25:0]}), .iB(27&#39;d33423360), .oSum(y_3_out) );
    <span style="font-style: italic">//Stage 4</span>
    <span style="font-weight: bold">reg</span> [26:0] y_4;
    <span style="font-style: italic">//Stage 5</span>
    <span style="font-weight: bold">reg</span> [26:0] y_5, mult_5_in;
    FpMul s5_mult ( .iA(y_5), .iB(mult_5_in), .oProd(oInvSqrt) );

    <span style="font-weight: bold">always</span> @(<span style="font-weight: bold">posedge</span> iCLK) <span style="font-weight: bold">begin</span>
    <span style="font-style: italic">//Stage 1 to 2</span>
    y_2 &lt;= y_1;
    mult_2_in &lt;= y_1_out;
    half_iA_2 &lt;= half_iA_1;
    <span style="font-style: italic">//Stage 2 to 3</span>
    y_3 &lt;= y_2;
    add_3_in &lt;= y_2_out;
    <span style="font-style: italic">//Stage 3 to 4</span>
    y_4 &lt;= y_3;
    <span style="font-style: italic">//Stage 4 to 5</span>
    y_5 &lt;= y_4;
    mult_5_in &lt;= y_3_out;
    <span style="font-weight: bold">end</span>
<span style="font-weight: bold">endmodule</span>

<span style="font-style: italic">/**************************************************************************</span>
<span style="font-style: italic"> * Floating Point Multiplier                                              *</span>
<span style="font-style: italic"> * Combinational                                                          *</span>
<span style="font-style: italic"> *************************************************************************/</span>
<span style="font-weight: bold">module</span> FpMul (
    <span style="font-weight: bold">input</span>      [26:0] iA,    <span style="font-style: italic">// First input</span>
    <span style="font-weight: bold">input</span>      [26:0] iB,    <span style="font-style: italic">// Second input</span>
    <span style="font-weight: bold">output</span>     [26:0] oProd  <span style="font-style: italic">// Product</span>
);

    <span style="font-style: italic">// Extract fields of A and B.</span>
    <span style="font-weight: bold">wire</span>        A_s;
    <span style="font-weight: bold">wire</span> [7:0]  A_e;
    <span style="font-weight: bold">wire</span> [17:0] A_f;
    <span style="font-weight: bold">wire</span>        B_s;
    <span style="font-weight: bold">wire</span> [7:0]  B_e;
    <span style="font-weight: bold">wire</span> [17:0] B_f;
    <span style="font-weight: bold">assign</span> A_s = iA[26];
    <span style="font-weight: bold">assign</span> A_e = iA[25:18];
    <span style="font-weight: bold">assign</span> A_f = {1&#39;b1, iA[17:1]};
    <span style="font-weight: bold">assign</span> B_s = iB[26];
    <span style="font-weight: bold">assign</span> B_e = iB[25:18];
    <span style="font-weight: bold">assign</span> B_f = {1&#39;b1, iB[17:1]};

    <span style="font-style: italic">// XOR sign bits to determine product sign.</span>
    <span style="font-weight: bold">wire</span>        oProd_s;
    <span style="font-weight: bold">assign</span> oProd_s = A_s ^ B_s;

    <span style="font-style: italic">// Multiply the fractions of A and B</span>
    <span style="font-weight: bold">wire</span> [35:0] pre_prod_frac;
    <span style="font-weight: bold">assign</span> pre_prod_frac = A_f * B_f;

    <span style="font-style: italic">// Add exponents of A and B</span>
    <span style="font-weight: bold">wire</span> [8:0]  pre_prod_exp;
    <span style="font-weight: bold">assign</span> pre_prod_exp = A_e + B_e;

    <span style="font-style: italic">// If top bit of product frac is 0, shift left one</span>
    <span style="font-weight: bold">wire</span> [7:0]  oProd_e;
    <span style="font-weight: bold">wire</span> [17:0] oProd_f;
    <span style="font-weight: bold">assign</span> oProd_e = pre_prod_frac[35] ? (pre_prod_exp-9&#39;d126) : (pre_prod_exp - 9&#39;d127);
    <span style="font-weight: bold">assign</span> oProd_f = pre_prod_frac[35] ? pre_prod_frac[34:17] : pre_prod_frac[33:16];

    <span style="font-style: italic">// Detect underflow</span>
    <span style="font-weight: bold">wire</span>        underflow;
    <span style="font-weight: bold">assign</span> underflow = pre_prod_exp &lt; 9&#39;h80;

    <span style="font-style: italic">// Detect zero conditions (either product frac doesn&#39;t start with 1, or underflow)</span>
    <span style="font-weight: bold">assign</span> oProd = underflow        ? 27&#39;b0 :
                   (B_e == 8&#39;d0)    ? 27&#39;b0 :
                   (A_e == 8&#39;d0)    ? 27&#39;b0 :
                   {oProd_s, oProd_e, oProd_f};

<span style="font-weight: bold">endmodule</span>


<span style="font-style: italic">/**************************************************************************</span>
<span style="font-style: italic"> * Floating Point Adder                                                   *</span>
<span style="font-style: italic"> * 2-stage pipeline                                                       *</span>
<span style="font-style: italic"> *************************************************************************/</span>
<span style="font-weight: bold">module</span> FpAdd (
    <span style="font-weight: bold">input</span>             iCLK,
    <span style="font-weight: bold">input</span>      [26:0] iA,
    <span style="font-weight: bold">input</span>      [26:0] iB,
    <span style="font-weight: bold">output</span> <span style="font-weight: bold">reg</span> [26:0] oSum
);

    <span style="font-style: italic">// Extract fields of A and B.</span>
    <span style="font-weight: bold">wire</span>        A_s;
    <span style="font-weight: bold">wire</span> [7:0]  A_e;
    <span style="font-weight: bold">wire</span> [17:0] A_f;
    <span style="font-weight: bold">wire</span>        B_s;
    <span style="font-weight: bold">wire</span> [7:0]  B_e;
    <span style="font-weight: bold">wire</span> [17:0] B_f;
    <span style="font-weight: bold">assign</span> A_s = iA[26];
    <span style="font-weight: bold">assign</span> A_e = iA[25:18];
    <span style="font-weight: bold">assign</span> A_f = {1&#39;b1, iA[17:1]};
    <span style="font-weight: bold">assign</span> B_s = iB[26];
    <span style="font-weight: bold">assign</span> B_e = iB[25:18];
    <span style="font-weight: bold">assign</span> B_f = {1&#39;b1, iB[17:1]};
    <span style="font-weight: bold">wire</span> A_larger;

    <span style="font-style: italic">// Shift fractions of A and B so that they align.</span>
    <span style="font-weight: bold">wire</span> [7:0]  exp_diff_A;
    <span style="font-weight: bold">wire</span> [7:0]  exp_diff_B;
    <span style="font-weight: bold">wire</span> [7:0]  larger_exp;
    <span style="font-weight: bold">wire</span> [36:0] A_f_shifted;
    <span style="font-weight: bold">wire</span> [36:0] B_f_shifted;

    <span style="font-weight: bold">assign</span> exp_diff_A = B_e - A_e; <span style="font-style: italic">// if B bigger</span>
    <span style="font-weight: bold">assign</span> exp_diff_B = A_e - B_e; <span style="font-style: italic">// if A bigger</span>

    <span style="font-weight: bold">assign</span> larger_exp = (B_e &gt; A_e) ? B_e : A_e;

    <span style="font-weight: bold">assign</span> A_f_shifted = A_larger             ? {1&#39;b0,  A_f, 18&#39;b0} :
                         (exp_diff_A &gt; 9&#39;d35) ? 37&#39;b0 :
                         ({1&#39;b0, A_f, 18&#39;b0} &gt;&gt; exp_diff_A);
    <span style="font-weight: bold">assign</span> B_f_shifted = ~A_larger            ? {1&#39;b0,  B_f, 18&#39;b0} :
                         (exp_diff_B &gt; 9&#39;d35) ? 37&#39;b0 :
                         ({1&#39;b0, B_f, 18&#39;b0} &gt;&gt; exp_diff_B);

    <span style="font-style: italic">// Determine which of A, B is larger</span>
    <span style="font-weight: bold">assign</span> A_larger =    (A_e &gt; B_e)                   ? 1&#39;b1  :
                         ((A_e == B_e) &amp;&amp; (A_f &gt; B_f)) ? 1&#39;b1  :
                         1&#39;b0;

    <span style="font-style: italic">// Calculate sum or difference of shifted fractions.</span>
    <span style="font-weight: bold">wire</span> [36:0] pre_sum;
    <span style="font-weight: bold">assign</span> pre_sum = ((A_s^B_s) &amp;  A_larger) ? A_f_shifted - B_f_shifted :
                     ((A_s^B_s) &amp; ~A_larger) ? B_f_shifted - A_f_shifted :
                     A_f_shifted + B_f_shifted;

    <span style="font-style: italic">// buffer midway results</span>
    <span style="font-weight: bold">reg</span>  [36:0] buf_pre_sum;
    <span style="font-weight: bold">reg</span>  [7:0]  buf_larger_exp;
    <span style="font-weight: bold">reg</span>         buf_A_e_zero;
    <span style="font-weight: bold">reg</span>         buf_B_e_zero;
    <span style="font-weight: bold">reg</span>  [26:0] buf_A;
    <span style="font-weight: bold">reg</span>  [26:0] buf_B;
    <span style="font-weight: bold">reg</span>         buf_oSum_s;
    <span style="font-weight: bold">always</span> @(<span style="font-weight: bold">posedge</span> iCLK) <span style="font-weight: bold">begin</span>
        buf_pre_sum    &lt;= pre_sum;
        buf_larger_exp &lt;= larger_exp;
        buf_A_e_zero   &lt;= (A_e == 8&#39;b0);
        buf_B_e_zero   &lt;= (B_e == 8&#39;b0);
        buf_A          &lt;= iA;
        buf_B          &lt;= iB;
        buf_oSum_s     &lt;= A_larger ? A_s : B_s;
    <span style="font-weight: bold">end</span>

    <span style="font-style: italic">// Convert to positive fraction and a sign bit.</span>
    <span style="font-weight: bold">wire</span> [36:0] pre_frac;
    <span style="font-weight: bold">assign</span> pre_frac = buf_pre_sum;

    <span style="font-style: italic">// Determine output fraction and exponent change with position of first 1.</span>
    <span style="font-weight: bold">wire</span> [17:0] oSum_f;
    <span style="font-weight: bold">wire</span> [7:0]  shft_amt;
    <span style="font-weight: bold">assign</span> shft_amt = pre_frac[36] ? 8&#39;d0  : pre_frac[35] ? 8&#39;d1  :
                      pre_frac[34] ? 8&#39;d2  : pre_frac[33] ? 8&#39;d3  :
                      pre_frac[32] ? 8&#39;d4  : pre_frac[31] ? 8&#39;d5  :
                      pre_frac[30] ? 8&#39;d6  : pre_frac[29] ? 8&#39;d7  :
                      pre_frac[28] ? 8&#39;d8  : pre_frac[27] ? 8&#39;d9  :
                      pre_frac[26] ? 8&#39;d10 : pre_frac[25] ? 8&#39;d11 :
                      pre_frac[24] ? 8&#39;d12 : pre_frac[23] ? 8&#39;d13 :
                      pre_frac[22] ? 8&#39;d14 : pre_frac[21] ? 8&#39;d15 :
                      pre_frac[20] ? 8&#39;d16 : pre_frac[19] ? 8&#39;d17 :
                      pre_frac[18] ? 8&#39;d18 : pre_frac[17] ? 8&#39;d19 :
                      pre_frac[16] ? 8&#39;d20 : pre_frac[15] ? 8&#39;d21 :
                      pre_frac[14] ? 8&#39;d22 : pre_frac[13] ? 8&#39;d23 :
                      pre_frac[12] ? 8&#39;d24 : pre_frac[11] ? 8&#39;d25 :
                      pre_frac[10] ? 8&#39;d26 : pre_frac[9]  ? 8&#39;d27 :
                      pre_frac[8]  ? 8&#39;d28 : pre_frac[7]  ? 8&#39;d29 :
                      pre_frac[6]  ? 8&#39;d30 : pre_frac[5]  ? 8&#39;d31 :
                      pre_frac[4]  ? 8&#39;d32 : pre_frac[3]  ? 8&#39;d33 :
                      pre_frac[2]  ? 8&#39;d34 : pre_frac[1]  ? 8&#39;d35 :
                      pre_frac[0]  ? 8&#39;d36 : 8&#39;d37;

    <span style="font-weight: bold">wire</span> [53:0] pre_frac_shft, uflow_shift;
	 <span style="font-style: italic">// the shift +1 is because high order bit is not stored, but implied</span>
    <span style="font-weight: bold">assign</span> pre_frac_shft = {pre_frac, 17&#39;b0} &lt;&lt; (shft_amt+1); <span style="font-style: italic">//? shft_amt+1</span>
	 <span style="font-weight: bold">assign</span> uflow_shift = {pre_frac, 17&#39;b0} &lt;&lt; (shft_amt); <span style="font-style: italic">//? shft_amt for overflow</span>
    <span style="font-weight: bold">assign</span> oSum_f = pre_frac_shft[53:36];

    <span style="font-weight: bold">wire</span> [7:0] oSum_e;
    <span style="font-weight: bold">assign</span> oSum_e = buf_larger_exp - shft_amt + 8&#39;b1;

    <span style="font-style: italic">// Detect underflow</span>
    <span style="font-weight: bold">wire</span> underflow;
	 <span style="font-style: italic">// this incorrectly sets uflow for 10-10.1</span>
    <span style="font-style: italic">//assign underflow = ~oSum_e[7] &amp;&amp; buf_larger_exp[7] &amp;&amp; (shft_amt != 8&#39;b0);</span>
	 
	 <span style="font-style: italic">// if top bit of matissa is not set, then denorm</span>
	 <span style="font-weight: bold">assign</span> underflow = ~uflow_shift[53]; 
	 
	 <span style="font-weight: bold">always</span> @(<span style="font-weight: bold">posedge</span> iCLK) <span style="font-weight: bold">begin</span>
			oSum &lt;= (buf_A_e_zero &amp;&amp; buf_B_e_zero)    ? 27&#39;b0 :
                  buf_A_e_zero                     ? buf_B :
                  buf_B_e_zero                     ? buf_A :
                  underflow                        ? 27&#39;b0 :
                  (pre_frac == 0)                  ? 27&#39;b0 :
                  {buf_oSum_s, oSum_e, oSum_f};
	 <span style="font-weight: bold">end</span> <span style="font-style: italic">//output update</span>
<span style="font-weight: bold">endmodule</span>

<span style="font-style: italic">/// end /////////////////////////////////////////////////////////////////////</span>
</pre>
				</div>

				<h4>graphics.c</h4>
				<!-- HTML generated using hilite.me -->
				<div
					style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
					<pre style="margin: 0; line-height: 125%"><span style="font-style: italic">////////////////////////////////////////////////////////////////////////</span>
<span style="font-style: italic">// GRAPHICS.C</span>
<span style="font-style: italic">//		Responsible for sending user input from serial input commands</span>
<span style="font-style: italic">//		Compile with gcc graphics.c -o graphics</span>
<span style="font-style: italic">// (Priya Kattappurath, Michael Rivera, Caitlin Stanton)</span>
<span style="font-style: italic">////////////////////////////////////////////////////////////////////////</span>

<span style="font-style: italic">#include &lt;stdio.h&gt;</span>
<span style="font-style: italic">#include &lt;stdlib.h&gt;</span>
<span style="font-style: italic">#include &lt;unistd.h&gt;</span>
<span style="font-style: italic">#include &lt;fcntl.h&gt;</span>
<span style="font-style: italic">#include &lt;math.h&gt;</span>
<span style="font-style: italic">#include &lt;sys/types.h&gt;</span>
<span style="font-style: italic">#include &lt;string.h&gt;</span>
<span style="font-style: italic">// interprocess comm</span>
<span style="font-style: italic">#include &lt;sys/ipc.h&gt;</span>
<span style="font-style: italic">#include &lt;sys/shm.h&gt;</span>
<span style="font-style: italic">#include &lt;sys/mman.h&gt;</span>
<span style="font-style: italic">#include &lt;time.h&gt;</span>
<span style="font-style: italic">// network stuff</span>
<span style="font-style: italic">#include &lt;sys/socket.h&gt;</span>
<span style="font-style: italic">#include &lt;netinet/in.h&gt;</span>
<span style="font-style: italic">#include &lt;netdb.h&gt;</span>

<span style="font-style: italic">#include &quot;address_map_arm_brl4.h&quot;</span>

<span style="font-style: italic">// fixed point</span>
<span style="font-style: italic">#define float2fix30(a) ((int)((a)*1073741824)) // 2^30</span>

<span style="font-style: italic">#define SWAP(X, Y) \</span>
<span style="font-style: italic">	do               \</span>
<span style="font-style: italic">	{                \</span>
<span style="font-style: italic">		int temp = X;  \</span>
<span style="font-style: italic">		X = Y;         \</span>
<span style="font-style: italic">		Y = temp;      \</span>
<span style="font-style: italic">	} while (0)</span>

<span style="font-style: italic">// shift fraction to 32-bit sound</span>
<span style="font-style: italic">#define fix2audio28(a) (a &lt;&lt; 4)</span>
<span style="font-style: italic">// shift fraction to 16-bit sound</span>
<span style="font-style: italic">#define fix2audio16(a) (a &gt;&gt; 12)</span>

<span style="font-style: italic">/* function prototypes */</span>
<span style="font-weight: bold">void</span> VGA_text(<span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>, <span style="font-weight: bold">char</span> *);
<span style="font-weight: bold">void</span> VGA_text_clear();
<span style="font-weight: bold">void</span> VGA_box(<span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>, <span style="font-weight: bold">short</span>);
<span style="font-weight: bold">void</span> VGA_line(<span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>, <span style="font-weight: bold">short</span>);
<span style="font-weight: bold">void</span> VGA_disc(<span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>, <span style="font-weight: bold">short</span>);
<span style="font-weight: bold">int</span> VGA_read_pixel(<span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>);
<span style="font-weight: bold">int</span> video_in_read_pixel(<span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>);
<span style="font-weight: bold">void</span> draw_delay(<span style="font-weight: bold">void</span>);

<span style="font-style: italic">// 8-bit line color choices</span>
<span style="font-style: italic">#define pink (0xe6)</span>
<span style="font-style: italic">#define red (0xe1)</span>
<span style="font-style: italic">#define orange (0xf1)</span>
<span style="font-style: italic">#define green (0x59)</span>
<span style="font-style: italic">#define blue (0x32)</span>
<span style="font-style: italic">#define purple (0xaa)</span>
<span style="font-style: italic">#define white (0xff)</span>
<span style="font-style: italic">#define black (0x00)</span>
<span style="font-weight: bold">int</span> colors[] = {pink, red, orange, green, blue, purple, white, black};

<span style="font-style: italic">// pixel macro</span>
<span style="font-style: italic">// !!!PACKED VGA MEMORY!!!</span>
<span style="font-style: italic">#define VGA_PIXEL(x, y, color)                           \</span>
<span style="font-style: italic">	do                                                     \</span>
<span style="font-style: italic">	{                                                      \</span>
<span style="font-style: italic">		char *pixel_ptr;                                     \</span>
<span style="font-style: italic">		pixel_ptr = (char *)vga_pixel_ptr + ((y)*640) + (x); \</span>
<span style="font-style: italic">		*(char *)pixel_ptr = (color);                        \</span>
<span style="font-style: italic">	} while (0)</span>

<span style="font-style: italic">// virtual to real address pointers</span>

<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *reset_pio;
<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *lsystem_char;
<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">char</span> *axiom;
<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *iterations;
<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *length;
<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *lsystem;
<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *start_x;
<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *start_y;
<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *timer_counter;
<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">char</span> *color;

<span style="font-style: italic">// phase accumulator</span>

<span style="font-style: italic">// fixed pt macros suitable for 32-bit sound</span>
<span style="font-weight: bold">typedef</span> <span style="font-weight: bold">signed</span> <span style="font-weight: bold">int</span> fix28;
<span style="font-style: italic">// drum-specific multiply macros simulated by shifts</span>
<span style="font-style: italic">#define times0pt5(a) ((a) &gt;&gt; 1)</span>
<span style="font-style: italic">#define times0pt25(a) ((a) &gt;&gt; 2)</span>
<span style="font-style: italic">#define times2pt0(a) ((a) &lt;&lt; 1)</span>
<span style="font-style: italic">#define times4pt0(a) ((a) &lt;&lt; 2)</span>
<span style="font-style: italic">#define times0pt9998(a) ((a) - ((a) &gt;&gt; 12)) //&gt;&gt;10</span>
<span style="font-style: italic">#define times0pt9999(a) ((a) - ((a) &gt;&gt; 13)) //&gt;&gt;10</span>
<span style="font-style: italic">#define times0pt999(a) ((a) - ((a) &gt;&gt; 10))	//&gt;&gt;10</span>
<span style="font-style: italic">#define MIN(X, Y) (((X) &lt; (Y)) ? (X) : (Y))</span>

<span style="font-style: italic">//multiply two fixed 4:28</span>
<span style="font-style: italic">#define multfix28(a, b) ((fix28)((((signed long long)(a)) * ((signed long long)(b))) &gt;&gt; 28))</span>
<span style="font-style: italic">//#define multfix28(a,b) ((fix28)((( ((short)((a)&gt;&gt;17)) * ((short)((b)&gt;&gt;17)) ))))</span>
<span style="font-style: italic">#define float2fix28(a) ((fix28)((a)*268435456.0f)) // 2^28</span>
<span style="font-style: italic">#define fix2float28(a) ((float)(a) / 268435456.0f)</span>
<span style="font-style: italic">#define int2fix28(a) ((a) &lt;&lt; 28)</span>
<span style="font-style: italic">#define fix2int28(a) ((a) &gt;&gt; 28)</span>
<span style="font-style: italic">#define times_rho(a, b) (multfix28(a, float2fix28(MIN(0.49, 0.06 + fix2float28(multfix28((b &gt;&gt; 1), (b &gt;&gt; 1))))))) //&gt;&gt;2</span>

<span style="font-style: italic">// shift fraction to 32-bit sound</span>
<span style="font-style: italic">#define fix2audio28(a) (a &lt;&lt; 4)</span>

<span style="font-style: italic">// reset pio</span>
<span style="font-style: italic">#define RESET_START 0x00000000</span>
<span style="font-style: italic">#define RESET_END 0x0000000f</span>
<span style="font-style: italic">#define RESET_SPAN 0x00000010</span>

<span style="font-style: italic">// lsystem char pio</span>
<span style="font-style: italic">#define LSYSTEM_CHAR_START 0x00000010</span>
<span style="font-style: italic">#define LSYSTEM_CHAR_END 0x0000001f</span>
<span style="font-style: italic">#define LSYSTEM_CHAR_SPAN 0x00000010</span>

<span style="font-style: italic">// axiom pio</span>
<span style="font-style: italic">#define AXIOM_START 0x00000030</span>
<span style="font-style: italic">#define AXIOM_END 0x0000003f</span>
<span style="font-style: italic">#define AXIOM_SPAN 0x00000010</span>

<span style="font-style: italic">// iterations pio</span>
<span style="font-style: italic">#define ITERATIONS_START 0x00000040</span>
<span style="font-style: italic">#define ITERATIONS_END 0x0000004f</span>
<span style="font-style: italic">#define ITERATIONS_SPAN 0x00000010</span>

<span style="font-style: italic">// length pio</span>
<span style="font-style: italic">#define LENGTH_START 0x00000050</span>
<span style="font-style: italic">#define LENGTH_END 0x0000005f</span>
<span style="font-style: italic">#define LENGTH_SPAN 0x00000010</span>

<span style="font-style: italic">// lsystem pio</span>
<span style="font-style: italic">#define LSYSTEM_START 0x00000060</span>
<span style="font-style: italic">#define LSYSTEM_END 0x0000006f</span>
<span style="font-style: italic">#define LSYSTEM_SPAN 0x00000010</span>

<span style="font-style: italic">// start_x pio</span>
<span style="font-style: italic">#define START_X_START 0x00000070</span>
<span style="font-style: italic">#define START_X_END 0x0000007f</span>
<span style="font-style: italic">#define START_X_SPAN 0x00000010</span>

<span style="font-style: italic">// start_y pio</span>
<span style="font-style: italic">#define START_Y_START 0x00000080</span>
<span style="font-style: italic">#define START_Y_END 0x0000008f</span>
<span style="font-style: italic">#define START_Y_SPAN 0x00000010</span>

<span style="font-style: italic">// timer counter pio</span>
<span style="font-style: italic">#define TIMER_START 0x00000090</span>
<span style="font-style: italic">#define TIMER_END 0x0000009f</span>
<span style="font-style: italic">#define TIMER_SPAN 0x00000010</span>

<span style="font-style: italic">// color pio</span>
<span style="font-style: italic">#define COLOR_START 0x00000100</span>
<span style="font-style: italic">#define COLOR_END 0x0000010f</span>
<span style="font-style: italic">#define COLOR_SPAN 0x00000010</span>

<span style="font-style: italic">// the light weight buss base</span>
<span style="font-weight: bold">void</span> *h2p_lw_virtual_base;

<span style="font-style: italic">// pixel buffer</span>
<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *vga_pixel_ptr = NULL;
<span style="font-weight: bold">void</span> *vga_pixel_virtual_base;

<span style="font-style: italic">// character buffer</span>
<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *vga_char_ptr = NULL;
<span style="font-weight: bold">void</span> *vga_char_virtual_base;

<span style="font-style: italic">// /dev/mem file descriptor</span>
<span style="font-weight: bold">int</span> fd;

<span style="font-style: italic">// shared memory</span>
<span style="font-weight: bold">key_t</span> mem_key = 0xf0;
<span style="font-weight: bold">int</span> shared_mem_id;
<span style="font-weight: bold">int</span> *shared_ptr;
<span style="font-style: italic">///</span>

<span style="font-weight: bold">int</span> string_length(<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">char</span> *s)
{
	<span style="font-weight: bold">int</span> c = 0;
	<span style="font-weight: bold">while</span> (*s != <span style="font-style: italic">&#39;\0&#39;</span>)
	{
		c++;
		*s++;
	}
	<span style="font-weight: bold">return</span> c;
}

<span style="font-weight: bold">int</span> main(<span style="font-weight: bold">void</span>)
{
	<span style="font-style: italic">// Declare volatile pointers to I/O registers (volatile 	// means that IO load and store instructions will be used 	// to access these pointer locations,</span>
	<span style="font-style: italic">// instead of regular memory loads and stores)</span>

	<span style="font-weight: bold">uint64_t</span> diff;
	<span style="font-weight: bold">struct</span> timespec start, end;
	<span style="font-style: italic">//int i;</span>

	<span style="font-style: italic">// === shared memory =======================</span>
	<span style="font-style: italic">// with video process</span>
	shared_mem_id = shmget(mem_key, 100, IPC_CREAT | 0666);
	shared_ptr = shmat(shared_mem_id, NULL, 0);

	<span style="font-style: italic">// === need to mmap: =======================</span>
	<span style="font-style: italic">// FPGA_CHAR_BASE</span>
	<span style="font-style: italic">// FPGA_ONCHIP_BASE</span>
	<span style="font-style: italic">// HW_REGS_BASE</span>

	<span style="font-style: italic">// === get FPGA addresses ==================</span>
	<span style="font-style: italic">// Open /dev/mem</span>
	<span style="font-weight: bold">if</span> ((fd = open(<span style="font-style: italic">&quot;/dev/mem&quot;</span>, (O_RDWR | O_SYNC))) == -1)
	{
		printf(<span style="font-style: italic">&quot;ERROR: could not open </span><span style="font-weight: bold; font-style: italic">\&quot;</span><span style="font-style: italic">/dev/mem</span><span style="font-weight: bold; font-style: italic">\&quot;</span><span style="font-style: italic">...</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		<span style="font-weight: bold">return</span> (1);
	}

	<span style="font-style: italic">// get virtual addr that maps to physical</span>
	h2p_lw_virtual_base = mmap(NULL, HW_REGS_SPAN, (PROT_READ | PROT_WRITE), MAP_SHARED, fd, HW_REGS_BASE);
	<span style="font-weight: bold">if</span> (h2p_lw_virtual_base == MAP_FAILED)
	{
		printf(<span style="font-style: italic">&quot;ERROR: mmap1() failed...</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		close(fd);
		<span style="font-weight: bold">return</span> (1);
	}

	<span style="font-style: italic">//map reset PIO port</span>
	reset_pio = (<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *)(h2p_lw_virtual_base + RESET_START);
	lsystem_char = (<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *)(h2p_lw_virtual_base + LSYSTEM_CHAR_START);
	axiom = (<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">char</span> *)(h2p_lw_virtual_base + AXIOM_START);
	iterations = (<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *)(h2p_lw_virtual_base + ITERATIONS_START);
	length = (<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *)(h2p_lw_virtual_base + LENGTH_START);
	lsystem = (<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *)(h2p_lw_virtual_base + LSYSTEM_START);
	start_x = (<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *)(h2p_lw_virtual_base + START_X_START);
	start_y = (<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *)(h2p_lw_virtual_base + START_Y_START);
	timer_counter = (<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *)(h2p_lw_virtual_base + TIMER_START);
	color = (<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">char</span> *)(h2p_lw_virtual_base + COLOR_START);

	<span style="font-style: italic">// address to resolution register</span>
	<span style="font-style: italic">//res_reg_ptr =(unsigned int *)(h2p_lw_virtual_base +  	 	//		resOffset);</span>

	<span style="font-style: italic">//addr to vga status</span>
	<span style="font-style: italic">//stat_reg_ptr = (unsigned int *)(h2p_lw_virtual_base +  	 	//		statusOffset);</span>

	<span style="font-style: italic">// === get VGA char addr =====================</span>
	<span style="font-style: italic">// get virtual addr that maps to physical</span>
	vga_char_virtual_base = mmap(NULL, FPGA_CHAR_SPAN, (PROT_READ | PROT_WRITE), MAP_SHARED, fd, FPGA_CHAR_BASE);
	<span style="font-weight: bold">if</span> (vga_char_virtual_base == MAP_FAILED)
	{
		printf(<span style="font-style: italic">&quot;ERROR: mmap2() failed...</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		close(fd);
		<span style="font-weight: bold">return</span> (1);
	}

	<span style="font-style: italic">// Get the address that maps to the FPGA LED control</span>
	vga_char_ptr = (<span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *)(vga_char_virtual_base);

	<span style="font-style: italic">// === get VGA pixel addr ====================</span>
	<span style="font-style: italic">// get virtual addr that maps to physical</span>
	vga_pixel_virtual_base = mmap(NULL, FPGA_ONCHIP_SPAN, (PROT_READ | PROT_WRITE), MAP_SHARED, fd, FPGA_ONCHIP_BASE);
	<span style="font-weight: bold">if</span> (vga_pixel_virtual_base == MAP_FAILED)
	{
		printf(<span style="font-style: italic">&quot;ERROR: mmap3() failed...</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		close(fd);
		<span style="font-weight: bold">return</span> (1);
	}

	<span style="font-style: italic">// Get the address that maps to the FPGA pixel buffer</span>
	vga_pixel_ptr = (<span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *)(vga_pixel_virtual_base);

	<span style="font-weight: bold">char</span> buffer[256];
	<span style="font-style: italic">//add a signal to help clear between new l-systems</span>
	<span style="font-style: italic">//high in TOP_RESET</span>
	*length = 0;
	memset(axiom, 0, 4);
	<span style="font-weight: bold">while</span> (1)
	{
		printf(<span style="font-style: italic">&quot;What L-System would you like?</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>); <span style="font-style: italic">//recommend default axiom, say what characters are available</span>
		printf(<span style="font-style: italic">&quot;0: Dragon Curve; 1: Sierpinski Arrowhead (1); 2: Koch Curve; 3: Sierpinski Arrowhead (2); 4: Koch Snowflake; 5: Cross; 6: Tessellated Triangle </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		printf(<span style="font-style: italic">&quot;L-System: &quot;</span>);
		scanf(<span style="font-style: italic">&quot;%i&quot;</span>, lsystem);

		<span style="font-style: italic">//print default axiom and available characters based on lsystem choice</span>
		<span style="font-weight: bold">if</span> (*lsystem == 0)
		{
			printf(<span style="font-style: italic">&quot;The default axiom for the Dragon Curve is FX</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Rule-making characters: X,Y</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Drawing characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Available characters are: F,A,X,Y,+,-</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		}
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (*lsystem == 1)
		{
			printf(<span style="font-style: italic">&quot;The default axiom for the Sierpinski Arrowhead (1) is YF</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Rule-making characters: X,Y</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Drawing characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Available characters are: F,A,X,Y,+,-</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		}
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (*lsystem == 2)
		{
			printf(<span style="font-style: italic">&quot;The default axiom for the Koch Curve is F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Rule-making characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Drawing characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Available characters are: F,A,X,Y,+,-</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		}
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (*lsystem == 3)
		{
			printf(<span style="font-style: italic">&quot;The default axiom for the Sierpinski Arrowhead (2) is A</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Rule-making characters: A,F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Drawing characters: A,F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Available characters are: F,A,X,Y,+,-</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		}
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (*lsystem == 4)
		{
			printf(<span style="font-style: italic">&quot;The default axiom for the Koch Snowflake is F++F++F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Rule-making characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Drawing characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Available characters are: F,A,X,Y,+,-</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		}
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (*lsystem == 5)
		{
			printf(<span style="font-style: italic">&quot;The default axiom for the Cross is F+F+F+F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Rule-making characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Drawing characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Available characters are: F,A,X,Y,+,-</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		}
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (*lsystem == 6)
		{
			printf(<span style="font-style: italic">&quot;The default axiom for the Tessellated Triangle is F+F+F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Rule-making characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Drawing characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;Available characters are: F,A,X,Y,+,-</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		}
		<span style="font-weight: bold">else</span>
		{
			printf(<span style="font-style: italic">&quot;Please input a valid L-System</span><span style="font-weight: bold; font-style: italic">\n\n</span><span style="font-style: italic">&quot;</span>);
		}

		<span style="font-weight: bold">while</span> (*lsystem &gt; 6 || *length &lt; 0)
		{
			printf(<span style="font-style: italic">&quot;What L-System would you like?</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>); <span style="font-style: italic">//recommend default axiom, say what characters are available</span>
			printf(<span style="font-style: italic">&quot;0: Dragon curve; 1: Sierpinski Arrowhead (1); 2: Koch Curve; 3: Sierpinski Arrowhead (2); 4: Koch Snowflake; 5: Cross; 6: Tessellated Triangle  </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			printf(<span style="font-style: italic">&quot;L-System: &quot;</span>);
			scanf(<span style="font-style: italic">&quot;%i&quot;</span>, lsystem);

			<span style="font-style: italic">//print default axiom and available characters based on lsystem choice</span>
			<span style="font-weight: bold">if</span> (*lsystem == 0)
			{
				printf(<span style="font-style: italic">&quot;The default axiom for the Dragon Curve is FX</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Rule-making characters: X,Y</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Drawing characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Available characters are: F,A,X,Y,+,-</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			}
			<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (*lsystem == 1)
			{
				printf(<span style="font-style: italic">&quot;The default axiom for the Sierpinski Arrowhead (1) is YF</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Rule-making characters: X,Y</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Drawing characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Available characters are: F,A,X,Y,+,-</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			}
			<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (*lsystem == 2)
			{
				printf(<span style="font-style: italic">&quot;The default axiom for the Koch Curve is F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Rule-making characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Drawing characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Available characters are: F,A,X,Y,+,-</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			}
			<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (*lsystem == 3)
			{
				printf(<span style="font-style: italic">&quot;The default axiom for the Sierpinski Arrowhead (2) is A</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Rule-making characters: A,F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Drawing characters: A,F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Available characters are: F,A,X,Y,+,-</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			}
			<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (*lsystem == 4)
			{
				printf(<span style="font-style: italic">&quot;The default axiom for the Koch Snowflake is F++F++F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Rule-making characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Drawing characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Available characters are: F,A,X,Y,+,-</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			}
			<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (*lsystem == 5)
			{
				printf(<span style="font-style: italic">&quot;The default axiom for the Cross is F+F+F+F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Rule-making characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Drawing characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Available characters are: F,A,X,Y,+,-</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			}
			<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (*lsystem == 6)
			{
				printf(<span style="font-style: italic">&quot;The default axiom for the Tessellated Triangle is F+F+F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Rule-making characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Drawing characters: F</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				printf(<span style="font-style: italic">&quot;Available characters are: F,A,X,Y,+,-</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			}
			<span style="font-weight: bold">else</span>
			{
				printf(<span style="font-style: italic">&quot;Please input a valid L-System</span><span style="font-weight: bold; font-style: italic">\n\n</span><span style="font-style: italic">&quot;</span>);
			}
		}

		printf(<span style="font-style: italic">&quot;Axiom: &quot;</span>);
		scanf(<span style="font-style: italic">&quot;%s&quot;</span>, &amp;axiom[0]);

		printf(<span style="font-style: italic">&quot;Number of iterations: &quot;</span>);
		scanf(<span style="font-style: italic">&quot;%i&quot;</span>, iterations);

		printf(<span style="font-style: italic">&quot;Length of line: &quot;</span>);
		scanf(<span style="font-style: italic">&quot;%i&quot;</span>, length);
		<span style="font-weight: bold">if</span> (*lsystem == 0)
		{
			<span style="font-weight: bold">while</span> (*length &lt; 3 || *length &gt; 31)
			{
				printf(<span style="font-style: italic">&quot;Length of line: &quot;</span>);
				scanf(<span style="font-style: italic">&quot;%i&quot;</span>, length);
			}
		}
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (*lsystem == 1 || *lsystem == 2 || *lsystem == 3)
		{
			<span style="font-weight: bold">while</span> (*length &lt; 7 || *length &gt; 31)
			{
				printf(<span style="font-style: italic">&quot;Length of line: &quot;</span>);
				scanf(<span style="font-style: italic">&quot;%i&quot;</span>, length);
			}
		}

		printf(<span style="font-style: italic">&quot;What color would you like?</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		printf(<span style="font-style: italic">&quot;Choices are: pink, red, orange, green, blue, purple, and white</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		printf(<span style="font-style: italic">&quot;Line color: &quot;</span>);
		scanf(<span style="font-style: italic">&quot;%s&quot;</span>, &amp;buffer[0]);
		<span style="font-weight: bold">if</span> (strcmp(buffer, <span style="font-style: italic">&quot;pink&quot;</span>) == 0)
		{
			*color = pink;
		}
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (strcmp(buffer, <span style="font-style: italic">&quot;red&quot;</span>) == 0)
		{
			*color = red;
		}
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (strcmp(buffer, <span style="font-style: italic">&quot;orange&quot;</span>) == 0)
		{
			*color = orange;
		}
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (strcmp(buffer, <span style="font-style: italic">&quot;green&quot;</span>) == 0)
		{
			*color = green;
		}
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (strcmp(buffer, <span style="font-style: italic">&quot;blue&quot;</span>) == 0)
		{
			*color = blue;
		}
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (strcmp(buffer, <span style="font-style: italic">&quot;purple&quot;</span>) == 0)
		{
			*color = purple;
		}
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (strcmp(buffer, <span style="font-style: italic">&quot;white&quot;</span>) == 0)
		{
			*color = white;
		}
		<span style="font-weight: bold">else</span>
		{
			printf(<span style="font-style: italic">&quot;Invalid color choice, default white chosen</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			*color = white;
		}

		printf(<span style="font-style: italic">&quot;Starting x coordinate (between 1 and 638): &quot;</span>);
		scanf(<span style="font-style: italic">&quot;%i&quot;</span>, start_x);
		<span style="font-weight: bold">while</span> (*start_x &lt; 1 || *start_x &gt; 638)
		{
			printf(<span style="font-style: italic">&quot;Starting x coordinate (between 1 and 638): &quot;</span>);
			scanf(<span style="font-style: italic">&quot;%i&quot;</span>, start_x);
		}

		printf(<span style="font-style: italic">&quot;Starting y coordinate (between 1 and 478): &quot;</span>);
		scanf(<span style="font-style: italic">&quot;%i&quot;</span>, start_y);
		<span style="font-weight: bold">while</span> (*start_y &lt; 1 || *start_y &gt; 478)
		{
			printf(<span style="font-style: italic">&quot;Starting y coordinate (between 1 and 478): &quot;</span>);
			scanf(<span style="font-style: italic">&quot;%i&quot;</span>, start_y);
		}

		VGA_box(0, 0, 639, 479, black);
		*reset_pio = 1;
		scanf(<span style="font-style: italic">&quot;%s&quot;</span>, &amp;buffer[0]);
		*reset_pio = 0;
		printf(<span style="font-style: italic">&quot;reset sent</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);

		<span style="font-weight: bold">int</span> wait = 0;
		<span style="font-weight: bold">while</span> (wait != *timer_counter)
		{
			wait = *timer_counter;
		};
		printf(<span style="font-style: italic">&quot;Time to visualize: %f</span><span style="font-weight: bold; font-style: italic">\n\n</span><span style="font-style: italic">&quot;</span>, (<span style="font-weight: bold">float</span>)(*timer_counter * (pow(10, -9)) * 20));

		*buffer = 0;
		<span style="font-weight: bold">while</span> (*buffer != 4)
		{

			printf(<span style="font-style: italic">&quot;1: Zoom in; 2: Zoom out; 3: Pan to new coordinates; 4: Quit zoom/pan functionality</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			scanf(<span style="font-style: italic">&quot;%i&quot;</span>, buffer);

			<span style="font-weight: bold">if</span> (*buffer == 4)
			{
				printf(<span style="font-style: italic">&quot;</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
				<span style="font-weight: bold">break</span>;
			}
			<span style="font-weight: bold">else</span>
			{
				<span style="font-weight: bold">if</span> (*buffer == 1)
				{ <span style="font-style: italic">//zoom in</span>
					*length = *length * 2;
					<span style="font-weight: bold">if</span> (*length &lt;= 2)
					{
						*length == 3;
					}
					VGA_box(0, 0, 639, 479, black);
				}
				<span style="font-weight: bold">if</span> (*buffer == 2)
				{ <span style="font-style: italic">//zoom in</span>
					*length = *length / 2;
					<span style="font-weight: bold">if</span> (*length &gt;= 32)
					{
						*length == 31;
					}
					VGA_box(0, 0, 639, 479, black);
				}
				<span style="font-weight: bold">if</span> (*buffer == 3)
				{
					printf(<span style="font-style: italic">&quot;Starting x coordinate (between 1 and 638): &quot;</span>);
					scanf(<span style="font-style: italic">&quot;%i&quot;</span>, start_x);
					<span style="font-weight: bold">while</span> (*start_x &lt; 1 || *start_x &gt; 638)
					{
						printf(<span style="font-style: italic">&quot;Starting x coordinate (between 1 and 638): &quot;</span>);
						scanf(<span style="font-style: italic">&quot;%i&quot;</span>, start_x);
					}

					printf(<span style="font-style: italic">&quot;Starting y coordinate (between 1 and 478): &quot;</span>);
					scanf(<span style="font-style: italic">&quot;%i&quot;</span>, start_y);
					<span style="font-weight: bold">while</span> (*start_y &lt; 1 || *start_y &gt; 478)
					{
						printf(<span style="font-style: italic">&quot;Starting y coordinate (between 1 and 478): &quot;</span>);
						scanf(<span style="font-style: italic">&quot;%i&quot;</span>, start_y);
					}
					VGA_box(0, 0, 639, 479, black);
				}

				*reset_pio = 1;
				scanf(<span style="font-style: italic">&quot;%s&quot;</span>, &amp;buffer[0]);
				*reset_pio = 0;
				printf(<span style="font-style: italic">&quot;reset sent</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);

				wait = 0;
				<span style="font-weight: bold">while</span> (wait != *timer_counter)
				{
					wait = *timer_counter;
				};
				printf(<span style="font-style: italic">&quot;Time to visualize: %f</span><span style="font-weight: bold; font-style: italic">\n\n</span><span style="font-style: italic">&quot;</span>, (<span style="font-weight: bold">float</span>)(*timer_counter * (pow(10, -9)) * 20));

				*buffer = 0;
			}
		}
	} <span style="font-style: italic">// end while(1)</span>
} <span style="font-style: italic">// end main</span>

<span style="font-style: italic">/****************************************************************************************</span>
<span style="font-style: italic"> * Subroutine to read a pixel from the VGA monitor </span>
<span style="font-style: italic">****************************************************************************************/</span>
<span style="font-weight: bold">int</span> VGA_read_pixel(<span style="font-weight: bold">int</span> x, <span style="font-weight: bold">int</span> y)
{
	<span style="font-weight: bold">char</span> *pixel_ptr;
	pixel_ptr = (<span style="font-weight: bold">char</span> *)vga_pixel_ptr + ((y)*640) + (x);
	<span style="font-weight: bold">return</span> *pixel_ptr;
}

<span style="font-style: italic">/****************************************************************************************</span>
<span style="font-style: italic"> * Subroutine to send a string of text to the VGA monitor </span>
<span style="font-style: italic">****************************************************************************************/</span>
<span style="font-weight: bold">void</span> VGA_text(<span style="font-weight: bold">int</span> x, <span style="font-weight: bold">int</span> y, <span style="font-weight: bold">char</span> *text_ptr)
{
	<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">char</span> *character_buffer = (<span style="font-weight: bold">char</span> *)vga_char_ptr; <span style="font-style: italic">// VGA character buffer</span>
	<span style="font-weight: bold">int</span> offset;
	<span style="font-style: italic">/* assume that the text string fits on one line */</span>
	offset = (y &lt;&lt; 7) + x;
	<span style="font-weight: bold">while</span> (*(text_ptr))
	{
		<span style="font-style: italic">// write to the character buffer</span>
		*(character_buffer + offset) = *(text_ptr);
		++text_ptr;
		++offset;
	}
}

<span style="font-style: italic">/****************************************************************************************</span>
<span style="font-style: italic"> * Subroutine to clear text to the VGA monitor </span>
<span style="font-style: italic">****************************************************************************************/</span>
<span style="font-weight: bold">void</span> VGA_text_clear()
{
	<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">char</span> *character_buffer = (<span style="font-weight: bold">char</span> *)vga_char_ptr; <span style="font-style: italic">// VGA character buffer</span>
	<span style="font-weight: bold">int</span> offset, x, y;
	<span style="font-weight: bold">for</span> (x = 0; x &lt; 79; x++)
	{
		<span style="font-weight: bold">for</span> (y = 0; y &lt; 59; y++)
		{
			<span style="font-style: italic">/* assume that the text string fits on one line */</span>
			offset = (y &lt;&lt; 7) + x;
			<span style="font-style: italic">// write to the character buffer</span>
			*(character_buffer + offset) = <span style="font-style: italic">&#39; &#39;</span>;
		}
	}
}

<span style="font-style: italic">/****************************************************************************************</span>
<span style="font-style: italic"> * Draw a filled rectangle on the VGA monitor </span>
<span style="font-style: italic">****************************************************************************************/</span>
<span style="font-style: italic">#define SWAP(X, Y) \</span>
<span style="font-style: italic">	do               \</span>
<span style="font-style: italic">	{                \</span>
<span style="font-style: italic">		int temp = X;  \</span>
<span style="font-style: italic">		X = Y;         \</span>
<span style="font-style: italic">		Y = temp;      \</span>
<span style="font-style: italic">	} while (0)</span>

<span style="font-weight: bold">void</span> VGA_box(<span style="font-weight: bold">int</span> x1, <span style="font-weight: bold">int</span> y1, <span style="font-weight: bold">int</span> x2, <span style="font-weight: bold">int</span> y2, <span style="font-weight: bold">short</span> pixel_color)
{
	<span style="font-weight: bold">char</span> *pixel_ptr;
	<span style="font-weight: bold">int</span> row, col;

	<span style="font-style: italic">/* check and fix box coordinates to be valid */</span>
	<span style="font-weight: bold">if</span> (x1 &gt; 639)
		x1 = 639;
	<span style="font-weight: bold">if</span> (y1 &gt; 479)
		y1 = 479;
	<span style="font-weight: bold">if</span> (x2 &gt; 639)
		x2 = 639;
	<span style="font-weight: bold">if</span> (y2 &gt; 479)
		y2 = 479;
	<span style="font-weight: bold">if</span> (x1 &lt; 0)
		x1 = 0;
	<span style="font-weight: bold">if</span> (y1 &lt; 0)
		y1 = 0;
	<span style="font-weight: bold">if</span> (x2 &lt; 0)
		x2 = 0;
	<span style="font-weight: bold">if</span> (y2 &lt; 0)
		y2 = 0;
	<span style="font-weight: bold">if</span> (x1 &gt; x2)
		SWAP(x1, x2);
	<span style="font-weight: bold">if</span> (y1 &gt; y2)
		SWAP(y1, y2);
	<span style="font-weight: bold">for</span> (row = y1; row &lt;= y2; row++)
		<span style="font-weight: bold">for</span> (col = x1; col &lt;= x2; ++col)
		{
			<span style="font-style: italic">//640x480</span>
			VGA_PIXEL(col, row, pixel_color);
			<span style="font-style: italic">//pixel_ptr = (char *)vga_pixel_ptr + (row&lt;&lt;10)    + col ;</span>
			<span style="font-style: italic">// set pixel color</span>
			<span style="font-style: italic">//*(char *)pixel_ptr = pixel_color;</span>
		}
}

<span style="font-style: italic">/****************************************************************************************</span>
<span style="font-style: italic"> * Draw a filled circle on the VGA monitor </span>
<span style="font-style: italic">****************************************************************************************/</span>

<span style="font-weight: bold">void</span> VGA_disc(<span style="font-weight: bold">int</span> x, <span style="font-weight: bold">int</span> y, <span style="font-weight: bold">int</span> r, <span style="font-weight: bold">short</span> pixel_color)
{
	<span style="font-weight: bold">char</span> *pixel_ptr;
	<span style="font-weight: bold">int</span> row, col, rsqr, xc, yc;

	rsqr = r * r;

	<span style="font-weight: bold">for</span> (yc = -r; yc &lt;= r; yc++)
		<span style="font-weight: bold">for</span> (xc = -r; xc &lt;= r; xc++)
		{
			col = xc;
			row = yc;
			<span style="font-style: italic">// add the r to make the edge smoother</span>
			<span style="font-weight: bold">if</span> (col * col + row * row &lt;= rsqr + r)
			{
				col += x; <span style="font-style: italic">// add the center point</span>
				row += y; <span style="font-style: italic">// add the center point</span>
				<span style="font-style: italic">//check for valid 640x480</span>
				<span style="font-weight: bold">if</span> (col &gt; 639)
					col = 639;
				<span style="font-weight: bold">if</span> (row &gt; 479)
					row = 479;
				<span style="font-weight: bold">if</span> (col &lt; 0)
					col = 0;
				<span style="font-weight: bold">if</span> (row &lt; 0)
					row = 0;
				VGA_PIXEL(col, row, pixel_color);
				<span style="font-style: italic">//pixel_ptr = (char *)vga_pixel_ptr + (row&lt;&lt;10) + col ;</span>
				<span style="font-style: italic">// set pixel color</span>
				<span style="font-style: italic">//nanosleep(&amp;delay_time, NULL);</span>
				<span style="font-style: italic">//draw_delay();</span>
				<span style="font-style: italic">//*(char *)pixel_ptr = pixel_color;</span>
			}
		}
}

<span style="font-style: italic">// =============================================</span>
<span style="font-style: italic">// === Draw a line</span>
<span style="font-style: italic">// =============================================</span>
<span style="font-style: italic">//plot a line</span>
<span style="font-style: italic">//at x1,y1 to x2,y2 with color</span>
<span style="font-style: italic">//Code is from David Rodgers,</span>
<span style="font-style: italic">//&quot;Procedural Elements of Computer Graphics&quot;,1985</span>
<span style="font-weight: bold">void</span> VGA_line(<span style="font-weight: bold">int</span> x1, <span style="font-weight: bold">int</span> y1, <span style="font-weight: bold">int</span> x2, <span style="font-weight: bold">int</span> y2, <span style="font-weight: bold">short</span> c)
{
	<span style="font-weight: bold">int</span> e;
	<span style="font-weight: bold">signed</span> <span style="font-weight: bold">int</span> dx, dy, j, temp;
	<span style="font-weight: bold">signed</span> <span style="font-weight: bold">int</span> s1, s2, xchange;
	<span style="font-weight: bold">signed</span> <span style="font-weight: bold">int</span> x, y;
	<span style="font-weight: bold">char</span> *pixel_ptr;

	<span style="font-style: italic">/* check and fix line coordinates to be valid */</span>
	<span style="font-weight: bold">if</span> (x1 &gt; 639)
		x1 = 639;
	<span style="font-weight: bold">if</span> (y1 &gt; 479)
		y1 = 479;
	<span style="font-weight: bold">if</span> (x2 &gt; 639)
		x2 = 639;
	<span style="font-weight: bold">if</span> (y2 &gt; 479)
		y2 = 479;
	<span style="font-weight: bold">if</span> (x1 &lt; 0)
		x1 = 0;
	<span style="font-weight: bold">if</span> (y1 &lt; 0)
		y1 = 0;
	<span style="font-weight: bold">if</span> (x2 &lt; 0)
		x2 = 0;
	<span style="font-weight: bold">if</span> (y2 &lt; 0)
		y2 = 0;

	x = x1;
	y = y1;

	<span style="font-style: italic">//take absolute value</span>
	<span style="font-weight: bold">if</span> (x2 &lt; x1)
	{
		dx = x1 - x2;
		s1 = -1;
	}

	<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (x2 == x1)
	{
		dx = 0;
		s1 = 0;
	}

	<span style="font-weight: bold">else</span>
	{
		dx = x2 - x1;
		s1 = 1;
	}

	<span style="font-weight: bold">if</span> (y2 &lt; y1)
	{
		dy = y1 - y2;
		s2 = -1;
	}

	<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (y2 == y1)
	{
		dy = 0;
		s2 = 0;
	}

	<span style="font-weight: bold">else</span>
	{
		dy = y2 - y1;
		s2 = 1;
	}

	xchange = 0;

	<span style="font-weight: bold">if</span> (dy &gt; dx)
	{
		temp = dx;
		dx = dy;
		dy = temp;
		xchange = 1;
	}

	e = ((<span style="font-weight: bold">int</span>)dy &lt;&lt; 1) - dx;

	<span style="font-weight: bold">for</span> (j = 0; j &lt;= dx; j++)
	{
		<span style="font-style: italic">//video_pt(x,y,c); //640x480</span>
		VGA_PIXEL(x, y, c);
		<span style="font-style: italic">//pixel_ptr = (char *)vga_pixel_ptr + (y&lt;&lt;10)+ x;</span>
		<span style="font-style: italic">// set pixel color</span>
		<span style="font-style: italic">//*(char *)pixel_ptr = c;</span>

		<span style="font-weight: bold">if</span> (e &gt;= 0)
		{
			<span style="font-weight: bold">if</span> (xchange == 1)
				x = x + s1;
			<span style="font-weight: bold">else</span>
				y = y + s2;
			e = e - ((<span style="font-weight: bold">int</span>)dx &lt;&lt; 1);
		}

		<span style="font-weight: bold">if</span> (xchange == 1)
			y = y + s2;
		<span style="font-weight: bold">else</span>
			x = x + s1;

		e = e + ((<span style="font-weight: bold">int</span>)dy &lt;&lt; 1);
	}
}

<span style="font-style: italic">/////////////////////////////////////////////</span>
</pre>
				</div>

				<h4>lsystem.py</h4>
				<!-- HTML generated using hilite.me -->
				<div
					style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
					<pre style="margin: 0; line-height: 125%"><span style="font-style: italic"># ////////////////////////////////////////////////////////////////////////</span>
<span style="font-style: italic">#   LSYSTEM.PY</span>
<span style="font-style: italic">#       Baseline Python code</span>
<span style="font-style: italic">#       Computes and graphs entire L-Systems</span>
<span style="font-style: italic">#   (Priya Kattappurath, Michael Rivera, Caitlin Stanton)</span>
<span style="font-style: italic"># ////////////////////////////////////////////////////////////////////////</span>

<span style="font-weight: bold">import</span> <span style="font-weight: bold">pygame</span>
<span style="font-weight: bold">import</span> <span style="font-weight: bold">math</span>
<span style="font-weight: bold">import</span> <span style="font-weight: bold">random</span>
<span style="font-weight: bold">import</span> <span style="font-weight: bold">time</span>

<span style="font-style: italic"># other = variables</span>
<span style="font-style: italic"># F,A = move n forward</span>
<span style="font-style: italic"># - = turn left by angle</span>
<span style="font-style: italic"># + = turn right by angle</span>

rules = {}

<span style="font-style: italic"># Have to comment out rules, axioms, and angles for all L-Systems but one</span>
<span style="font-style: italic"># The following are the seven L-Systems for our project</span>

<span style="font-style: italic"># rules[&#39;X&#39;] = &#39;X+YF+&#39;  # Dragon curve</span>
<span style="font-style: italic"># rules[&#39;Y&#39;] = &#39;-FX-Y&#39;</span>
<span style="font-style: italic"># axiom = &#39;FX&#39;</span>
<span style="font-style: italic"># angle = 90</span>

<span style="font-style: italic"># rules[&#39;X&#39;] = &#39;YF+XF+Y&#39;  # Sierpinski arrowhead (1)</span>
<span style="font-style: italic"># rules[&#39;Y&#39;] = &#39;XF-YF-X&#39;</span>
<span style="font-style: italic"># axiom = &#39;YF&#39;</span>
<span style="font-style: italic"># angle = 60</span>

<span style="font-style: italic"># rules[&#39;A&#39;] = &#39;+F-A-F+&#39;  # Sierpinski arrowhead (2)</span>
<span style="font-style: italic"># rules[&#39;F&#39;] = &#39;-A+F+A-&#39;</span>
<span style="font-style: italic"># axiom = &#39;A&#39;</span>
<span style="font-style: italic"># angle = 60</span>

<span style="font-style: italic"># rules[&#39;F&#39;] = &#39;F+F--F+F&#39;  # Koch curve</span>
<span style="font-style: italic"># axiom = &#39;F&#39;</span>
<span style="font-style: italic"># angle = 60</span>

<span style="font-style: italic"># rules[&#39;F&#39;] = &#39;F-F++F-F&#39;  # Koch snowflake</span>
<span style="font-style: italic"># axiom = &#39;F++F++F&#39;</span>
<span style="font-style: italic"># angle = 60</span>

<span style="font-style: italic"># rules[&#39;F&#39;] = &#39;F+FF++F+F&#39;  # Cross</span>
<span style="font-style: italic"># axiom = &#39;F+F+F+F&#39;</span>
<span style="font-style: italic"># angle = 90</span>

<span style="font-style: italic"># rules[&#39;F&#39;] = &#39;F-F+F&#39;  # Tessellated triangle</span>
<span style="font-style: italic"># axiom = &#39;F+F+F&#39;</span>
<span style="font-style: italic"># angle = 120</span>

iterations = 12  <span style="font-style: italic"># number of iterations</span>
step = 7  <span style="font-style: italic"># step size / line length</span>

angleoffset = 90

size = width, height = 1920, 1080  <span style="font-style: italic"># display with/height</span>
pygame.init()  <span style="font-style: italic"># init display</span>
screen = pygame.display.set_mode(size)  <span style="font-style: italic"># open screen</span>

<span style="font-style: italic"># startpos = 100, height - 225</span>
<span style="font-style: italic"># startpos = 50, height / 2 - 50</span>
<span style="font-style: italic"># startpos = width / 2, height / 2</span>
startpos = width / 2 - 200, height / 2
<span style="font-style: italic"># startpos = 100, height / 2</span>
<span style="font-style: italic"># startpos = 10, 10</span>


<span style="font-weight: bold">def</span> applyRule(input):
    output = <span style="font-style: italic">&quot;&quot;</span>
    <span style="font-weight: bold">for</span> rule, result <span style="font-weight: bold">in</span> rules.items(
    ):  <span style="font-style: italic"># applying the rule by checking the current char against it</span>
        <span style="font-weight: bold">if</span> (input == rule):
            output = result  <span style="font-style: italic"># Rule 1</span>
            <span style="font-weight: bold">break</span>
        <span style="font-weight: bold">else</span>:
            output = input  <span style="font-style: italic"># else ( no rule set ) output = the current char -&gt; no rule was applied</span>
    <span style="font-weight: bold">return</span> output


<span style="font-weight: bold">def</span> processString(oldStr):
    newstr = <span style="font-style: italic">&quot;&quot;</span>
    <span style="font-weight: bold">for</span> character <span style="font-weight: bold">in</span> oldStr:
        newstr = newstr + applyRule(character)  <span style="font-style: italic"># build the new string</span>
    <span style="font-weight: bold">return</span> newstr


<span style="font-weight: bold">def</span> createSystem(numIters, axiom):
    startString = axiom
    endString = <span style="font-style: italic">&quot;&quot;</span>
    <span style="font-weight: bold">for</span> i <span style="font-weight: bold">in</span> range(numIters):  <span style="font-style: italic"># iterate with appling the rules</span>
        print(<span style="font-style: italic">&quot;Iteration: {0}&quot;</span>.format(i))
        endString = processString(startString)
        startString = endString
    <span style="font-weight: bold">return</span> endString


<span style="font-weight: bold">def</span> polar_to_cart(theta, r, offx, offy):
    x = r * math.cos(math.radians(theta))
    y = r * math.sin(math.radians(theta))
    <span style="font-weight: bold">return</span> tuple([x + y <span style="font-weight: bold">for</span> x, y <span style="font-weight: bold">in</span> zip((int(x), int(y)), (offx, offy))])


<span style="font-weight: bold">def</span> cart_to_polar(x, y):
    <span style="font-weight: bold">return</span> (math.degrees(math.atan(y / x)),
            math.sqrt(math.pow(x, 2) + math.pow(y, 2)))


<span style="font-weight: bold">def</span> drawTree(input, oldpos):
    a = 0  <span style="font-style: italic"># angle</span>
    i = 0  <span style="font-style: italic"># counter for processcalculation</span>
    processOld = 0  <span style="font-style: italic"># old process</span>
    newpos = oldpos
    color = (255, 255, 255)
    linesize = 1
    <span style="font-weight: bold">for</span> character <span style="font-weight: bold">in</span> input:  <span style="font-style: italic"># process for drawing the l-system by writing the string to the screen</span>

        i += 1  <span style="font-style: italic"># print process in percent</span>
        process = i * 100 / len(input)
        <span style="font-weight: bold">if</span> <span style="font-weight: bold">not</span> process == processOld:
            <span style="font-style: italic"># print(process, &quot;%&quot;)</span>
            processOld = process

        <span style="font-weight: bold">if</span> character == <span style="font-style: italic">&#39;A&#39;</span>:  <span style="font-style: italic"># magic happens here</span>
            newpos = polar_to_cart(a + angleoffset, step, *oldpos)
            pygame.draw.line(screen, color, oldpos, newpos, linesize)
            oldpos = newpos
        <span style="font-weight: bold">elif</span> character == <span style="font-style: italic">&#39;F&#39;</span>:
            newpos = polar_to_cart(a + angleoffset, step, *oldpos)
            pygame.draw.line(screen, color, oldpos, newpos, linesize)
            oldpos = newpos
        <span style="font-weight: bold">elif</span> character == <span style="font-style: italic">&#39;+&#39;</span>:
            a += angle
        <span style="font-weight: bold">elif</span> character == <span style="font-style: italic">&#39;-&#39;</span>:
            a -= angle


<span style="font-weight: bold">if</span> __name__ == <span style="font-style: italic">&#39;__main__&#39;</span>:
    start = time.time()
    tree = (createSystem(iterations, axiom))
    <span style="font-style: italic"># print(len(tree))</span>
    drawTree(tree, startpos)
    end = time.time()
    pygame.display.flip()
    pygame.image.save(screen, <span style="font-style: italic">&quot;screenshot.png&quot;</span>)
    print(<span style="font-style: italic">&quot;Finished in &quot;</span> + str(end - start) + <span style="font-style: italic">&quot; seconds&quot;</span>)

    <span style="font-weight: bold">while</span> (1):
        <span style="font-weight: bold">pass</span>
        exit()  <span style="font-style: italic"># uncommand</span>
</pre>
				</div>


				<h4>translated_python.c</h4>
				<!-- HTML generated using hilite.me -->
				<div
					style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
					<pre style="margin: 0; line-height: 125%"><span style="font-style: italic">////////////////////////////////////////////////////////////////////////</span>
<span style="font-style: italic">// TRANSLATED_PYTHON.C</span>
<span style="font-style: italic">//		Baseline C code from lsystem.py</span>
<span style="font-style: italic">//		Computes and graphs entire L-Systems</span>
<span style="font-style: italic">//		Compile with gcc translated_python.c -o fp1 -lm</span>
<span style="font-style: italic">//			Must have ECE 5760 GPU with FAST display from SRAM project loaded onto board</span>
<span style="font-style: italic">// (Priya Kattappurath, Michael Rivera, Caitlin Stanton)</span>
<span style="font-style: italic">////////////////////////////////////////////////////////////////////////</span>

<span style="font-style: italic">#include &lt;stdio.h&gt;</span>
<span style="font-style: italic">#include &lt;string.h&gt;</span>
<span style="font-style: italic">#include &lt;stdlib.h&gt;</span>
<span style="font-style: italic">#include &lt;unistd.h&gt;</span>
<span style="font-style: italic">#include &lt;fcntl.h&gt;</span>
<span style="font-style: italic">#include &lt;sys/types.h&gt;</span>
<span style="font-style: italic">#include &lt;sys/ipc.h&gt;</span>
<span style="font-style: italic">#include &lt;sys/shm.h&gt;</span>
<span style="font-style: italic">#include &lt;sys/mman.h&gt;</span>
<span style="font-style: italic">#include &lt;sys/time.h&gt;</span>
<span style="font-style: italic">#include &lt;math.h&gt;</span>

<span style="font-style: italic">#include &quot;address_map_arm_brl4.h&quot;</span>

<span style="font-style: italic">/* function prototypes */</span>
<span style="font-weight: bold">void</span> VGA_text(<span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>, <span style="font-weight: bold">char</span> *);
<span style="font-weight: bold">void</span> VGA_text_clear();
<span style="font-weight: bold">void</span> VGA_box(<span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>, <span style="font-weight: bold">short</span>);
<span style="font-weight: bold">void</span> VGA_line(<span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>, <span style="font-weight: bold">short</span>);
<span style="font-weight: bold">void</span> VGA_disc(<span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>, <span style="font-weight: bold">short</span>);
<span style="font-weight: bold">int</span> VGA_read_pixel(<span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>);
<span style="font-weight: bold">int</span> video_in_read_pixel(<span style="font-weight: bold">int</span>, <span style="font-weight: bold">int</span>);
<span style="font-weight: bold">void</span> draw_delay(<span style="font-weight: bold">void</span>);

<span style="font-style: italic">// 16-bit primary colors</span>
<span style="font-style: italic">#define red (0 + (0 &lt;&lt; 5) + (31 &lt;&lt; 11))</span>
<span style="font-style: italic">#define dark_red (0 + (0 &lt;&lt; 5) + (15 &lt;&lt; 11))</span>
<span style="font-style: italic">#define green (0 + (63 &lt;&lt; 5) + (0 &lt;&lt; 11))</span>
<span style="font-style: italic">#define dark_green (0 + (31 &lt;&lt; 5) + (0 &lt;&lt; 11))</span>
<span style="font-style: italic">#define blue (31 + (0 &lt;&lt; 5) + (0 &lt;&lt; 11))</span>
<span style="font-style: italic">#define dark_blue (15 + (0 &lt;&lt; 5) + (0 &lt;&lt; 11))</span>
<span style="font-style: italic">#define yellow (0 + (63 &lt;&lt; 5) + (31 &lt;&lt; 11))</span>
<span style="font-style: italic">#define cyan (31 + (63 &lt;&lt; 5) + (0 &lt;&lt; 11))</span>
<span style="font-style: italic">#define magenta (31 + (0 &lt;&lt; 5) + (31 &lt;&lt; 11))</span>
<span style="font-style: italic">#define black (0x0000)</span>
<span style="font-style: italic">#define gray (15 + (31 &lt;&lt; 5) + (51 &lt;&lt; 11))</span>
<span style="font-style: italic">#define white (0xffff)</span>
<span style="font-weight: bold">int</span> colors[] = {red, dark_red, green, dark_green, blue, dark_blue,
								yellow, cyan, magenta, gray, black, white};

<span style="font-style: italic">// the light weight buss base</span>
<span style="font-weight: bold">void</span> *h2p_lw_virtual_base;

<span style="font-style: italic">// RAM FPGA command buffer</span>
<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *sram_ptr = NULL;
<span style="font-weight: bold">void</span> *sram_virtual_base;

<span style="font-style: italic">// pixel buffer</span>
<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *vga_pixel_ptr = NULL;
<span style="font-weight: bold">void</span> *vga_pixel_virtual_base;

<span style="font-style: italic">// character buffer</span>
<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *vga_char_ptr = NULL;
<span style="font-weight: bold">void</span> *vga_char_virtual_base;

<span style="font-style: italic">// /dev/mem file id</span>
<span style="font-weight: bold">int</span> fd;

<span style="font-style: italic">// pixel macro</span>
<span style="font-style: italic">// !!!PACKED VGA MEMORY!!!</span>
<span style="font-style: italic">#define VGA_PIXEL(x, y, color)                           \</span>
<span style="font-style: italic">	do                                                     \</span>
<span style="font-style: italic">	{                                                      \</span>
<span style="font-style: italic">		char *pixel_ptr;                                     \</span>
<span style="font-style: italic">		pixel_ptr = (char *)vga_pixel_ptr + ((y)*640) + (x); \</span>
<span style="font-style: italic">		*(char *)pixel_ptr = (color);                        \</span>
<span style="font-style: italic">	} while (0)</span>

<span style="font-weight: bold">char</span> *applyRule_DragonCurve(<span style="font-weight: bold">char</span> input)
{
	<span style="font-weight: bold">char</span> tmp[1000000];
	<span style="font-weight: bold">switch</span> (input)
	{
	<span style="font-weight: bold">case</span> <span style="font-style: italic">&#39;X&#39;</span>:
	{
		strcpy(tmp, <span style="font-style: italic">&quot;X+YF+&quot;</span>);
		<span style="font-weight: bold">break</span>;
	}
	<span style="font-weight: bold">case</span> <span style="font-style: italic">&#39;Y&#39;</span>:
	{
		strcpy(tmp, <span style="font-style: italic">&quot;-FX-Y&quot;</span>);
		<span style="font-weight: bold">break</span>;
	}
	default:
	{
		strcpy(tmp, (<span style="font-weight: bold">char</span>[2]){(<span style="font-weight: bold">char</span>)input, <span style="font-style: italic">&#39;\0&#39;</span>});
		<span style="font-weight: bold">break</span>;
	}
	}
	<span style="font-weight: bold">return</span> tmp;
}

<span style="font-weight: bold">char</span> *processString_DragonCurve(<span style="font-weight: bold">char</span> *prev)
{
	<span style="font-weight: bold">int</span> i = 0;
	<span style="font-weight: bold">char</span> *tmp;
	<span style="font-weight: bold">char</span> *check;
	<span style="font-weight: bold">int</span> length = strlen(prev);
	<span style="font-weight: bold">for</span> (i = 0; i &lt; length; i++)
	{
		check = prev;
		tmp = applyRule_DragonCurve(prev[i]);
		strcat(prev, tmp);
	}
	<span style="font-weight: bold">return</span> prev;
}

<span style="font-weight: bold">char</span> *createSystem_DragonCurve(<span style="font-weight: bold">int</span> numIters, <span style="font-weight: bold">char</span> *axiom)
{
	<span style="font-weight: bold">char</span> start[1000000];
	strcpy(start, axiom);
	<span style="font-weight: bold">char</span> end[1000000];
	*end = <span style="font-style: italic">&quot;&quot;</span>;
	<span style="font-weight: bold">int</span> i = 0;
	<span style="font-weight: bold">char</span> *check;
	<span style="font-weight: bold">for</span> (i = 0; i &lt; numIters; i++)
	{
		check = processString_DragonCurve(start);
		*start = end;
	}
	<span style="font-weight: bold">return</span> start;
}

<span style="font-weight: bold">void</span> draw_DragonCurve(<span style="font-weight: bold">char</span> *input, <span style="font-weight: bold">int</span> old_x, <span style="font-weight: bold">int</span> old_y)
{
	<span style="font-weight: bold">int</span> a = 0; <span style="font-style: italic">// 0 degrees is straight up vertically</span>
	<span style="font-weight: bold">int</span> length = 10;
	<span style="font-weight: bold">int</span> new_x = old_x;
	<span style="font-weight: bold">int</span> new_y = old_y;
	<span style="font-weight: bold">int</span> i = 0;
	<span style="font-weight: bold">char</span> *check = input;
	printf(<span style="font-style: italic">&quot;GRAPHING STRING: &quot;</span>);
	<span style="font-weight: bold">while</span> (*check != <span style="font-style: italic">&#39;\0&#39;</span>)
		printf(<span style="font-style: italic">&quot;%c&quot;</span>, *check++);
	printf(<span style="font-style: italic">&quot;</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
	<span style="font-weight: bold">for</span> (i = 0; i &lt; strlen(input); i++)
	{
		<span style="font-weight: bold">if</span> (input[i] == <span style="font-style: italic">&#39;X&#39;</span>)
		{
			<span style="font-weight: bold">continue</span>;
		}
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (input[i] == <span style="font-style: italic">&#39;Y&#39;</span>)
		{
			<span style="font-weight: bold">continue</span>;
		}
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (input[i] == <span style="font-style: italic">&#39;F&#39;</span>)
		{
			<span style="font-weight: bold">if</span> (a % 360 == 0)
			{
				VGA_line(new_x, new_y, new_x, new_y - length, red);
				new_x = new_x;
				new_y = new_y - length;
			}
			<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (a % 270 == 0)
			{
				VGA_line(new_x, new_y, new_x - length, new_y, yellow);
				new_x = new_x - length;
				new_y = new_y;
			}
			<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (a % 180 == 0)
			{
				VGA_line(new_x, new_y, new_x, new_y + length, red);
				new_x = new_x;
				new_y = new_y + length;
			}
			<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (a % 90 == 0)
			{
				VGA_line(new_x, new_y, new_x + length, new_y, yellow);
				new_x = new_x + length;
				new_y = new_y;
			}
		}
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (input[i] == <span style="font-style: italic">&#39;+&#39;</span>)
		{
			a = a + 90;
		}
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (input[i] == <span style="font-style: italic">&#39;-&#39;</span>)
		{
			a = a - 90;
		}
	}
}

<span style="font-style: italic">// measure time</span>
<span style="font-weight: bold">struct</span> timeval t1, t2;
<span style="font-weight: bold">double</span> elapsedTime;
<span style="font-weight: bold">struct</span> timespec delay_time;

<span style="font-weight: bold">int</span> main(<span style="font-weight: bold">void</span>)
{
	delay_time.tv_nsec = 10;
	delay_time.tv_sec = 0;

	<span style="font-style: italic">// Declare volatile pointers to I/O registers (volatile 	// means that IO load and store instructions will be used 	// to access these pointer locations,</span>
	<span style="font-style: italic">// instead of regular memory loads and stores)</span>

	<span style="font-style: italic">// === need to mmap: =======================</span>
	<span style="font-style: italic">// FPGA_CHAR_BASE</span>
	<span style="font-style: italic">// FPGA_ONCHIP_BASE</span>
	<span style="font-style: italic">// HW_REGS_BASE</span>

	<span style="font-style: italic">// === get FPGA addresses ==================</span>
	<span style="font-style: italic">// Open /dev/mem</span>
	<span style="font-weight: bold">if</span> ((fd = open(<span style="font-style: italic">&quot;/dev/mem&quot;</span>, (O_RDWR | O_SYNC))) == -1)
	{
		printf(<span style="font-style: italic">&quot;ERROR: could not open </span><span style="font-weight: bold; font-style: italic">\&quot;</span><span style="font-style: italic">/dev/mem</span><span style="font-weight: bold; font-style: italic">\&quot;</span><span style="font-style: italic">...</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		<span style="font-weight: bold">return</span> (1);
	}

	<span style="font-style: italic">// get virtual addr that maps to physical</span>
	<span style="font-style: italic">// for light weight bus</span>
	h2p_lw_virtual_base = mmap(NULL, HW_REGS_SPAN, (PROT_READ | PROT_WRITE), MAP_SHARED, fd, HW_REGS_BASE);
	<span style="font-weight: bold">if</span> (h2p_lw_virtual_base == MAP_FAILED)
	{
		printf(<span style="font-style: italic">&quot;ERROR: mmap1() failed...</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		close(fd);
		<span style="font-weight: bold">return</span> (1);
	}

	<span style="font-style: italic">// === get VGA char addr =====================</span>
	<span style="font-style: italic">// get virtual addr that maps to physical</span>
	vga_char_virtual_base = mmap(NULL, FPGA_CHAR_SPAN, (PROT_READ | PROT_WRITE), MAP_SHARED, fd, FPGA_CHAR_BASE);
	<span style="font-weight: bold">if</span> (vga_char_virtual_base == MAP_FAILED)
	{
		printf(<span style="font-style: italic">&quot;ERROR: mmap2() failed...</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		close(fd);
		<span style="font-weight: bold">return</span> (1);
	}

	<span style="font-style: italic">// Get the address that maps to the character</span>
	vga_char_ptr = (<span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *)(vga_char_virtual_base);

	<span style="font-style: italic">// === get VGA pixel addr ====================</span>
	<span style="font-style: italic">// get virtual addr that maps to physical</span>
	<span style="font-style: italic">// SDRAM</span>
	vga_pixel_virtual_base = mmap(NULL, FPGA_ONCHIP_SPAN, (PROT_READ | PROT_WRITE), MAP_SHARED, fd, SDRAM_BASE); <span style="font-style: italic">//SDRAM_BASE</span>

	<span style="font-weight: bold">if</span> (vga_pixel_virtual_base == MAP_FAILED)
	{
		printf(<span style="font-style: italic">&quot;ERROR: mmap3() failed...</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		close(fd);
		<span style="font-weight: bold">return</span> (1);
	}
	<span style="font-style: italic">// Get the address that maps to the FPGA pixel buffer</span>
	vga_pixel_ptr = (<span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *)(vga_pixel_virtual_base);

	<span style="font-style: italic">// === get RAM FPGA parameter addr =========</span>
	sram_virtual_base = mmap(NULL, FPGA_ONCHIP_SPAN, (PROT_READ | PROT_WRITE), MAP_SHARED, fd, FPGA_ONCHIP_BASE); <span style="font-style: italic">//fp</span>

	<span style="font-weight: bold">if</span> (sram_virtual_base == MAP_FAILED)
	{
		printf(<span style="font-style: italic">&quot;ERROR: mmap3() failed...</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		close(fd);
		<span style="font-weight: bold">return</span> (1);
	}
	<span style="font-style: italic">// Get the address that maps to the RAM buffer</span>
	sram_ptr = (<span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span> *)(sram_virtual_base);

	<span style="font-style: italic">// ===========================================</span>

	<span style="font-style: italic">// clear the screen</span>
	VGA_box(0, 0, 639, 479, 0x03);
	printf(<span style="font-style: italic">&quot;start</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
	<span style="font-weight: bold">char</span> input[100] = <span style="font-style: italic">&quot;FX&quot;</span>;
	<span style="font-weight: bold">char</span> *tree = createSystem_DragonCurve(9, input);
	draw_DragonCurve(tree, 100, 500);
} <span style="font-style: italic">// end main</span>

<span style="font-style: italic">/****************************************************************************************</span>
<span style="font-style: italic"> * Subroutine to read a pixel from the video input </span>
<span style="font-style: italic">****************************************************************************************/</span>
<span style="font-style: italic">// int  video_in_read_pixel(int x, int y){</span>
<span style="font-style: italic">// char  *pixel_ptr ;</span>
<span style="font-style: italic">// pixel_ptr = (char *)video_in_ptr + ((y)&lt;&lt;9) + (x) ;</span>
<span style="font-style: italic">// return *pixel_ptr ;</span>
<span style="font-style: italic">// }</span>

<span style="font-style: italic">/****************************************************************************************</span>
<span style="font-style: italic"> * Subroutine to read a pixel from the VGA monitor </span>
<span style="font-style: italic">****************************************************************************************/</span>
<span style="font-weight: bold">int</span> VGA_read_pixel(<span style="font-weight: bold">int</span> x, <span style="font-weight: bold">int</span> y)
{
	<span style="font-weight: bold">char</span> *pixel_ptr;
	pixel_ptr = (<span style="font-weight: bold">char</span> *)vga_pixel_ptr + ((y)*640) + (x);
	<span style="font-weight: bold">return</span> *pixel_ptr;
}

<span style="font-style: italic">/****************************************************************************************</span>
<span style="font-style: italic"> * Subroutine to send a string of text to the VGA monitor </span>
<span style="font-style: italic">****************************************************************************************/</span>
<span style="font-weight: bold">void</span> VGA_text(<span style="font-weight: bold">int</span> x, <span style="font-weight: bold">int</span> y, <span style="font-weight: bold">char</span> *text_ptr)
{
	<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">char</span> *character_buffer = (<span style="font-weight: bold">char</span> *)vga_char_ptr; <span style="font-style: italic">// VGA character buffer</span>
	<span style="font-weight: bold">int</span> offset;
	<span style="font-style: italic">/* assume that the text string fits on one line */</span>
	offset = (y &lt;&lt; 7) + x;
	<span style="font-weight: bold">while</span> (*(text_ptr))
	{
		<span style="font-style: italic">// write to the character buffer</span>
		*(character_buffer + offset) = *(text_ptr);
		++text_ptr;
		++offset;
	}
}

<span style="font-style: italic">/****************************************************************************************</span>
<span style="font-style: italic"> * Subroutine to clear text to the VGA monitor </span>
<span style="font-style: italic">****************************************************************************************/</span>
<span style="font-weight: bold">void</span> VGA_text_clear()
{
	<span style="font-weight: bold">volatile</span> <span style="font-weight: bold">char</span> *character_buffer = (<span style="font-weight: bold">char</span> *)vga_char_ptr; <span style="font-style: italic">// VGA character buffer</span>
	<span style="font-weight: bold">int</span> offset, x, y;
	<span style="font-weight: bold">for</span> (x = 0; x &lt; 79; x++)
	{
		<span style="font-weight: bold">for</span> (y = 0; y &lt; 59; y++)
		{
			<span style="font-style: italic">/* assume that the text string fits on one line */</span>
			offset = (y &lt;&lt; 7) + x;
			<span style="font-style: italic">// write to the character buffer</span>
			*(character_buffer + offset) = <span style="font-style: italic">&#39; &#39;</span>;
		}
	}
}

<span style="font-style: italic">/****************************************************************************************</span>
<span style="font-style: italic"> * Draw a filled rectangle on the VGA monitor </span>
<span style="font-style: italic">****************************************************************************************/</span>
<span style="font-style: italic">#define SWAP(X, Y) \</span>
<span style="font-style: italic">	do               \</span>
<span style="font-style: italic">	{                \</span>
<span style="font-style: italic">		int temp = X;  \</span>
<span style="font-style: italic">		X = Y;         \</span>
<span style="font-style: italic">		Y = temp;      \</span>
<span style="font-style: italic">	} while (0)</span>

<span style="font-weight: bold">void</span> VGA_box(<span style="font-weight: bold">int</span> x1, <span style="font-weight: bold">int</span> y1, <span style="font-weight: bold">int</span> x2, <span style="font-weight: bold">int</span> y2, <span style="font-weight: bold">short</span> pixel_color)
{
	<span style="font-weight: bold">char</span> *pixel_ptr;
	<span style="font-weight: bold">int</span> row, col;

	<span style="font-style: italic">/* check and fix box coordinates to be valid */</span>
	<span style="font-weight: bold">if</span> (x1 &gt; 639)
		x1 = 639;
	<span style="font-weight: bold">if</span> (y1 &gt; 479)
		y1 = 479;
	<span style="font-weight: bold">if</span> (x2 &gt; 639)
		x2 = 639;
	<span style="font-weight: bold">if</span> (y2 &gt; 479)
		y2 = 479;
	<span style="font-weight: bold">if</span> (x1 &lt; 0)
		x1 = 0;
	<span style="font-weight: bold">if</span> (y1 &lt; 0)
		y1 = 0;
	<span style="font-weight: bold">if</span> (x2 &lt; 0)
		x2 = 0;
	<span style="font-weight: bold">if</span> (y2 &lt; 0)
		y2 = 0;
	<span style="font-weight: bold">if</span> (x1 &gt; x2)
		SWAP(x1, x2);
	<span style="font-weight: bold">if</span> (y1 &gt; y2)
		SWAP(y1, y2);
	<span style="font-weight: bold">for</span> (row = y1; row &lt;= y2; row++)
		<span style="font-weight: bold">for</span> (col = x1; col &lt;= x2; ++col)
		{
			<span style="font-style: italic">//640x480</span>
			VGA_PIXEL(col, row, pixel_color);
			<span style="font-style: italic">//pixel_ptr = (char *)vga_pixel_ptr + (row&lt;&lt;10)    + col ;</span>
			<span style="font-style: italic">// set pixel color</span>
			<span style="font-style: italic">//*(char *)pixel_ptr = pixel_color;</span>
		}
}

<span style="font-style: italic">/****************************************************************************************</span>
<span style="font-style: italic"> * Draw a filled circle on the VGA monitor </span>
<span style="font-style: italic">****************************************************************************************/</span>

<span style="font-weight: bold">void</span> VGA_disc(<span style="font-weight: bold">int</span> x, <span style="font-weight: bold">int</span> y, <span style="font-weight: bold">int</span> r, <span style="font-weight: bold">short</span> pixel_color)
{
	<span style="font-weight: bold">char</span> *pixel_ptr;
	<span style="font-weight: bold">int</span> row, col, rsqr, xc, yc;

	rsqr = r * r;

	<span style="font-weight: bold">for</span> (yc = -r; yc &lt;= r; yc++)
		<span style="font-weight: bold">for</span> (xc = -r; xc &lt;= r; xc++)
		{
			col = xc;
			row = yc;
			<span style="font-style: italic">// add the r to make the edge smoother</span>
			<span style="font-weight: bold">if</span> (col * col + row * row &lt;= rsqr + r)
			{
				col += x; <span style="font-style: italic">// add the center point</span>
				row += y; <span style="font-style: italic">// add the center point</span>
				<span style="font-style: italic">//check for valid 640x480</span>
				<span style="font-weight: bold">if</span> (col &gt; 639)
					col = 639;
				<span style="font-weight: bold">if</span> (row &gt; 479)
					row = 479;
				<span style="font-weight: bold">if</span> (col &lt; 0)
					col = 0;
				<span style="font-weight: bold">if</span> (row &lt; 0)
					row = 0;
				VGA_PIXEL(col, row, pixel_color);
				<span style="font-style: italic">//pixel_ptr = (char *)vga_pixel_ptr + (row&lt;&lt;10) + col ;</span>
				<span style="font-style: italic">// set pixel color</span>
				<span style="font-style: italic">//nanosleep(&amp;delay_time, NULL);</span>
				<span style="font-style: italic">//draw_delay();</span>
				<span style="font-style: italic">//*(char *)pixel_ptr = pixel_color;</span>
			}
		}
}

<span style="font-style: italic">// =============================================</span>
<span style="font-style: italic">// === Draw a line</span>
<span style="font-style: italic">// =============================================</span>
<span style="font-style: italic">//plot a line</span>
<span style="font-style: italic">//at x1,y1 to x2,y2 with color</span>
<span style="font-style: italic">//Code is from David Rodgers,</span>
<span style="font-style: italic">//&quot;Procedural Elements of Computer Graphics&quot;,1985</span>
<span style="font-weight: bold">void</span> VGA_line(<span style="font-weight: bold">int</span> x1, <span style="font-weight: bold">int</span> y1, <span style="font-weight: bold">int</span> x2, <span style="font-weight: bold">int</span> y2, <span style="font-weight: bold">short</span> c)
{
	<span style="font-weight: bold">int</span> e;
	<span style="font-weight: bold">signed</span> <span style="font-weight: bold">int</span> dx, dy, j, temp;
	<span style="font-weight: bold">signed</span> <span style="font-weight: bold">int</span> s1, s2, xchange;
	<span style="font-weight: bold">signed</span> <span style="font-weight: bold">int</span> x, y;
	<span style="font-weight: bold">char</span> *pixel_ptr;

	<span style="font-style: italic">/* check and fix line coordinates to be valid */</span>
	<span style="font-weight: bold">if</span> (x1 &gt; 639)
		x1 = 639;
	<span style="font-weight: bold">if</span> (y1 &gt; 479)
		y1 = 479;
	<span style="font-weight: bold">if</span> (x2 &gt; 639)
		x2 = 639;
	<span style="font-weight: bold">if</span> (y2 &gt; 479)
		y2 = 479;
	<span style="font-weight: bold">if</span> (x1 &lt; 0)
		x1 = 0;
	<span style="font-weight: bold">if</span> (y1 &lt; 0)
		y1 = 0;
	<span style="font-weight: bold">if</span> (x2 &lt; 0)
		x2 = 0;
	<span style="font-weight: bold">if</span> (y2 &lt; 0)
		y2 = 0;

	x = x1;
	y = y1;

	<span style="font-style: italic">//take absolute value</span>
	<span style="font-weight: bold">if</span> (x2 &lt; x1)
	{
		dx = x1 - x2;
		s1 = -1;
	}

	<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (x2 == x1)
	{
		dx = 0;
		s1 = 0;
	}

	<span style="font-weight: bold">else</span>
	{
		dx = x2 - x1;
		s1 = 1;
	}

	<span style="font-weight: bold">if</span> (y2 &lt; y1)
	{
		dy = y1 - y2;
		s2 = -1;
	}

	<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (y2 == y1)
	{
		dy = 0;
		s2 = 0;
	}

	<span style="font-weight: bold">else</span>
	{
		dy = y2 - y1;
		s2 = 1;
	}

	xchange = 0;

	<span style="font-weight: bold">if</span> (dy &gt; dx)
	{
		temp = dx;
		dx = dy;
		dy = temp;
		xchange = 1;
	}

	e = ((<span style="font-weight: bold">int</span>)dy &lt;&lt; 1) - dx;

	<span style="font-weight: bold">for</span> (j = 0; j &lt;= dx; j++)
	{
		<span style="font-style: italic">//video_pt(x,y,c); //640x480</span>
		VGA_PIXEL(x, y, c);
		<span style="font-style: italic">//pixel_ptr = (char *)vga_pixel_ptr + (y&lt;&lt;10)+ x;</span>
		<span style="font-style: italic">// set pixel color</span>
		<span style="font-style: italic">//*(char *)pixel_ptr = c;</span>

		<span style="font-weight: bold">if</span> (e &gt;= 0)
		{
			<span style="font-weight: bold">if</span> (xchange == 1)
				x = x + s1;
			<span style="font-weight: bold">else</span>
				y = y + s2;
			e = e - ((<span style="font-weight: bold">int</span>)dx &lt;&lt; 1);
		}

		<span style="font-weight: bold">if</span> (xchange == 1)
			y = y + s2;
		<span style="font-weight: bold">else</span>
			x = x + s1;

		e = e + ((<span style="font-weight: bold">int</span>)dy &lt;&lt; 1);
	}
}

<span style="font-style: italic">/////////////////////////////////////////////</span>

<span style="font-style: italic">#define NOP10() asm(&quot;nop;nop;nop;nop;nop;nop;nop;nop;nop;nop&quot;)</span>

<span style="font-weight: bold">void</span> draw_delay(<span style="font-weight: bold">void</span>)
{
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10(); <span style="font-style: italic">//16</span>
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10(); <span style="font-style: italic">//32</span>
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10(); <span style="font-style: italic">//48</span>
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10(); <span style="font-style: italic">//64</span>
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10();
	NOP10(); <span style="font-style: italic">//68</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10(); //80</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10();</span>
					 <span style="font-style: italic">// NOP10(); NOP10(); NOP10(); NOP10(); //96</span>
}

<span style="font-style: italic">/// /// /////////////////////////////////////</span>
<span style="font-style: italic">/// end /////////////////////////////////////</span>
</pre>
				</div>

			</section>
		</div>

	</div>

	<!-- Footer -->
	<div id="footer">
		<div class="container medium">

			<header class="major last">
				<h2>Thank you to Hunter Adams, Bruce Land, and Katie Bradford for their countless hours of help, even when our
					code made no sense at all.</h2>
			</header>

			<p>All hail Wayne Gretzsky</p>

			<ul class="copyright">
				<li>&copy; Untitled. All rights reserved.</li>
				<li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
			</ul>

		</div>
	</div>

	<!-- Scripts -->
	<script src="assets/js/jquery.min.js"></script>
	<script src="assets/js/browser.min.js"></script>
	<script src="assets/js/breakpoints.min.js"></script>
	<script src="assets/js/util.js"></script>
	<script src="assets/js/main.js"></script>

</body>

</html>