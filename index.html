<!DOCTYPE HTML>
<!--
	Directive by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>

<head>
	<title>FPGA L-Systems</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<link rel="stylesheet" href="assets/css/main.css" />
</head>

<body class="is-preload">

	<!-- Header -->
	<div id="header">
		<span class="logo icon fa-paper-plane"></span>
		<h1>Graphing L-Systems on the FPGA</h1>
		<p><i>a project by</i></p>
		<h3>Priya Kattapurath, Michael Rivera, & Caitlin Stanton</h3>
		<p><i>for ECE 5760 (Advanced Microcontrollers) at Cornell University</i></p>
		<p></a>.
		</p>
	</div>

	<!-- Main -->
	<div id="main">

		<section id="sidebar">
			<div class="inner">
				<nav>
					<ul>
						<li><a href="#intro">Introduction</a></li>
						<li><a href="#high-level">High-Level</a></li>
						<li><a href="#baseline">Baseline</a></li>
						<li><a href="#full-system">Full System</a></li>
						<li><a href="#testing">Testing</a></li>
						<li><a href="#results">Results</a></li>
						<li><a href="#conclusion">Conclusion</a></li>
					</ul>
				</nav>
			</div>
		</section>

		<header class="major container medium">
			<p>We implemented naturally recursive Lindenmayer systems (commonly known as fractals) on an Intel Altera board to
				graph on a VGA screen. Our system proved to be faster than pure software programs written in both Python and
				C.</p>
		</header>

		<!-- <div class="box alt container">

			<section class="feature left">
				<a href="#" class="image icon solid fa-signal"><img src="images/pic01.jpg" alt="" /></a>
				<div class="content">
					<h3>The First Thing</h3>
					<p>Vitae natoque dictum etiam semper magnis enim feugiat amet curabitur tempor orci penatibus. Tellus erat
						mauris ipsum fermentum etiam vivamus eget. Nunc nibh morbi quis fusce lacus.</p>
				</div>
			</section>
			<section class="feature right">
				<a href="#" class="image icon solid fa-code"><img src="images/pic02.jpg" alt="" /></a>
				<div class="content">
					<h3>The Second Thing</h3>
					<p>Vitae natoque dictum etiam semper magnis enim feugiat amet curabitur tempor orci penatibus. Tellus erat
						mauris ipsum fermentum etiam vivamus eget. Nunc nibh morbi quis fusce lacus.</p>
				</div>
			</section>
			<section class="feature left">
				<a href="#" class="image icon solid fa-mobile-alt"><img src="images/pic03.jpg" alt="" /></a>
				<div class="content">
					<h3>The Third Thing</h3>
					<p>Vitae natoque dictum etiam semper magnis enim feugiat amet curabitur tempor orci penatibus. Tellus erat
						mauris ipsum fermentum etiam vivamus eget. Nunc nibh morbi quis fusce lacus.</p>
				</div>
			</section>
		</div> -->

		<br id="intro">
		<div class="box container">
			<section>
				<header>
					<h2>Introduction</h2>
				</header>
				<p>There are dozens of L-Systems in existence, and for this project we implemented seven. Each was configurable
					via the number of iterations the system performed, the axiom to begin with, the size and color of the lines,
					and the starting coordinates of the system.
				</p>
				<ul>
					<li>Dragon curve</li>
					<li>Two versions of the Sierpinski arrowhead</li>
					<li>Two versions of the Koch curve</li>
					<li>Cross</li>
					<li>Tessellated triangles</li>
				</ul>
				<p>This project was composed of two subsystems: Verilog code for the FPGA to calculate the L-Systems and graph
					the result, and the C code for the HPS to interface with the user. The FPGA has a faster system clock
					frequency and, considering the generation of L-Systems is computationally intensive, it made sense to offload
					that onto the faster, hardware-based part of the Altera board. Graphing on the VGA screen isn’t something
					that’s limited to the FPGA itself, but bandwidth would’ve been a limiting factor when transmitting large
					chunks of data from the FPGA to the HPS. With this in mind, graphing was kept to the FPGA, where the results
					were already being calculated. The HPS was instead utilized for its terminal interface, where the user was
					able to configure the L-System to be graphed. Any system settings were communicated to the FPGA via PIO ports
					to use in its computations. </p>
			</section>
		</div>
		<br id="high-level">
		<div class="box container">
			<section>
				<header>
					<h2>High-Level Design</h2>
				</header>
				<p>The formal definition of a Lindenmayer System (or L-System) is “a parallel rewriting system and a type of
					formal grammar.” In simpler terms, L-Systems generate fractals, which are never-ending complex patterns that
					are self similar at different scales such that zooming in or out will still show the same fractal pattern.
				</p>
				<p>There are three main components to every L-System: an alphabet, an axiom, and rules. These configure and
					manipulate the strings of characters that define how the visualization should act, such as moving forward,
					turning 90 degrees to the right, or branching out from a previous state. The alphabet is the set of valid
					symbols that can be included in these strings; for example, an alphabet of {A, B} restricts any valid sentence
					to only contain A and B. The axiom sets the initial value for the system’s string; working within the system
					with alphabet {A, B}, an axiom could be “A.” Rules change the string recursively, generating new strings
					repeatedly and providing actions to control the movements of the growing visualization. They’re structured to
					take in a predecessor and a successor—the former is the input and the latter is the output after having the
					rule applied to it. A rule to our {A, B} system with axiom A could be “A → AB”; this would take our initial
					state and create the string “AB” for the next state.
				</p>
				<p>The alphabet for every phase of our design, no matter the coding language, consists of the following symbols,
					as shown in Table 1. Each symbol corresponds to a specific action, from graphing (which are consistent across
					L-Systems) to buffer characters for rule generation (specific to each L-System).</p>
				<img src="images/alphabet.png" style="display:block;margin: 0 auto;">
				<br>
				<p>Though there is an infinite number of combinations of axioms and rules within the given alphabet, the seven
					L-Systems we developed have preset values for each. We followed these so as to ensure the graphed results
					would match what was expected. Table 2 shows the axioms and rules for each L-System.</p>
				<img src="images/lsystems.png" style="display:block;margin: 0 auto;">
				<br>
			</section>
		</div>
		<br id="baseline">
		<div class="box container">
			<section>
				<h2>Baseline Design</h2>
				<p>Considering L-Systems have multiple moving parts, the most straightforward way to understand their inner
					mechanisms comes from our baseline designs.
				</p>
				<h3>Python</h3>
				<p>This Python code is an off-the-shelf implementation that we extended to incorporate the axioms and rules for
					our specific L-Systems. It uses a dictionary of rules—key-value pairs where the key is the character to apply
					to rule to and the value is the output string for that character—and locally declared <code>axiom</code>,
					<code>iterations</code>,
					<code>angle</code>, and <code>step</code> variables to iterate over a starting axiom and graph the resulting
					L-System using pygame. This
					is accomplished with several functions, each of which helped build the foundations for our C code and
					eventually our Verilog design.
				</p>
				<p><code>applyRule</code> is responsible for taking in a single character and converting it to the output string
					as specified
					in the <code>rules</code> dictionary. It uses a for loop through every entry in <code>rules</code> to see if
					any key matches the <code>input</code>
					character. If a rule exists for this specific character, the result string is set to that rule’s value,
					otherwise the result string is the original character. This exemplifies how not every character will be
					expanded through a rule—at the very least it’ll just be copied into the resulting output string.</p>
				<!-- HTML generated using hilite.me -->
				<div
					style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
					<pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">def</span> applyRule(input):
   output = <span style="font-style: italic">&quot;&quot;</span>
   <span style="font-weight: bold">for</span> rule, result <span style="font-weight: bold">in</span> rules.items(
   ):  <span style="font-style: italic"># applying the rule by checking the current char against it</span>
       <span style="font-weight: bold">if</span> (input == rule):
           output = result  <span style="font-style: italic"># Rule 1</span>
           <span style="font-weight: bold">break</span>
       <span style="font-weight: bold">else</span>:
           output = input  <span style="font-style: italic"># else ( no rule set ) output = the current char -&gt; no rule was applied</span>
   <span style="font-weight: bold">return</span> output
</pre>
				</div>
				<br>
				<p>The next function is <code>processString</code>. Rather than take an individual character as input, it
					receives an entire
					string to process. Every character must be handled in order to see if a rule can apply to it, so a for loop
					runs over every character and sends each to <code>applyRule</code>. The new string is built up with each call
					to <code>applyRule</code>,
					creating a string that will have grown in length from the original.</p>
				<!-- HTML generated using hilite.me -->
				<div
					style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
					<pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">def</span> processString(oldStr):
   newstr = <span style="font-style: italic">&quot;&quot;</span>
   <span style="font-weight: bold">for</span> character <span style="font-weight: bold">in</span> oldStr:
       newstr = newstr + applyRule(character)  <span style="font-style: italic"># build the new string</span>
   <span style="font-weight: bold">return</span> newstr
</pre>
				</div>
				<br>
				<p><code>createSystem</code> puts the previous two functions together to bring iterations into the mix. It takes
					in <code>axiom</code> and
					<code>numIters</code> as inputs, where the former is the starting string for the L-System and the latter is
					the specified
					number of iterations to process the string by. While <code>processString</code> does grow the string as it
					loops over every
					character, <code>createSystem</code> is responsible for repeating this process multiple times from iteration
					number zero to
					iteration number <code>numIters</code>-1. With each iteration, it takes the string from the previous iteration
					and puts it
					into <code>processString</code>, storing the result so that the next iteration can use it.
				</p>
				<!-- HTML generated using hilite.me -->
				<div
					style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
					<pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">def</span> createSystem(numIters, axiom):
   startString = axiom
   endString = <span style="font-style: italic">&quot;&quot;</span>
   <span style="font-weight: bold">for</span> i <span style="font-weight: bold">in</span> range(numIters):  <span style="font-style: italic"># iterate with applying the rules</span>
       print(<span style="font-style: italic">&quot;Iteration: {0}&quot;</span>.format(i))
       endString = processString(startString)
       startString = endString
   <span style="font-weight: bold">return</span> endString
</pre>
				</div>
				<br>
				<p>With the L-System string built through <code>createSystem</code>, <code>drawTree</code> is able to graph the
					L-System using pygame. It
					takes in the L-System string and the starting coordinates from which to graph. It then uses a loop to look at
					every character in the string to determine what (if any) graphing functionality it needs to provide. If it
					sees an ‘A’ or ‘F’ it draws forward by the length determined by <code>step</code>. If it sees a ‘+’ it
					increments the
					orientation of the system by <code>angle</code>, and similarly decrements the orientation of the system by
					<code>angle</code> if it sees
					a ‘-’. ‘X’ and ‘Y’ aren’t graphing characters so they, and any other characters not equal to ‘A’, ‘F’, ‘+’, or
					‘-’, are skipped over.
				</p>
				<!-- HTML generated using hilite.me -->
				<div
					style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
					<pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">def</span> drawTree(input, oldpos):
   a = 0  <span style="font-style: italic"># angle</span>
   i = 0  <span style="font-style: italic"># counter for process calculation</span>
   processOld = 0  <span style="font-style: italic"># old process</span>
   newpos = oldpos
   color = (255, 255, 255)
   linesize = 1
   <span style="font-weight: bold">for</span> character <span style="font-weight: bold">in</span> input:  <span style="font-style: italic"># process for drawing the l-system by writing the string to the screen</span>
 
       i += 1  <span style="font-style: italic"># print process in percent</span>
       process = i * 100 / len(input)
       <span style="font-weight: bold">if</span> <span style="font-weight: bold">not</span> process == processOld:
           <span style="font-style: italic"># print(process, &quot;%&quot;)</span>
           processOld = process
 
       <span style="font-weight: bold">if</span> character == <span style="font-style: italic">&#39;A&#39;</span>:  <span style="font-style: italic"># magic happens here</span>
           newpos = polar_to_cart(a + angleoffset, step, *oldpos)
           pygame.draw.line(screen, color, oldpos, newpos, linesize)
           oldpos = newpos
       <span style="font-weight: bold">elif</span> character == <span style="font-style: italic">&#39;F&#39;</span>:
           newpos = polar_to_cart(a + angleoffset, step, *oldpos)
           pygame.draw.line(screen, color, oldpos, newpos, linesize)
           oldpos = newpos
       <span style="font-weight: bold">elif</span> character == <span style="font-style: italic">&#39;+&#39;</span>:
           a += angle
       <span style="font-weight: bold">elif</span> character == <span style="font-style: italic">&#39;-&#39;</span>:
           a -= angle
</pre>
				</div>
				<br>
				<h3>C</h3>
				<p>Since Python is an interpreted, high-level language, our next step was to synthesize and graph L-Systems in C
					code to be run on the FPGA. This did require a Quartus project to be compiled and loaded onto the board, but
					it wasn’t something that we changed at all. Specifically, we used the “GPU with FAST display from SRAM”
					project from the ECE 5760 Avalon Bus Master page.
				</p>
				<p>The program layout of the Python code corresponds almost entirely with that of the C program, though it only
					focuses on the dragon curve, not all seven L-Systems. First there is the <code>applyRule_DragonCurve</code>
					function, which
					is responsible for receiving a single character and outputting a character pointer to a string. This string is
					built by putting the input character through a switch-case statement and seeing which condition it matches.
				</p>
				<!-- HTML generated using hilite.me -->
				<div
					style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
					<pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">char</span>* applyRule_DragonCurve(<span style="font-weight: bold">char</span> input) {
 <span style="font-weight: bold">char</span> tmp[1000000];
 <span style="font-weight: bold">switch</span>(input) {
   <span style="font-weight: bold">case</span> <span style="font-style: italic">&#39;X&#39;</span>: {
     strcpy(tmp,<span style="font-style: italic">&quot;X+YF+&quot;</span>);
     <span style="font-weight: bold">break</span>;
   }
   <span style="font-weight: bold">case</span> <span style="font-style: italic">&#39;Y&#39;</span>: {
     strcpy(tmp,<span style="font-style: italic">&quot;-FX-Y&quot;</span>);
     <span style="font-weight: bold">break</span>;
   }
   default: {
     strcpy(tmp, (<span style="font-weight: bold">char</span>[2]) { (<span style="font-weight: bold">char</span>) input, <span style="font-style: italic">&#39;\0&#39;</span> } );
     <span style="font-weight: bold">break</span>;
   }
 }
 <span style="font-weight: bold">return</span> tmp;
}
</pre>
				</div>
				<br>
				<p><code>processString_DragonCurve</code> follows the same logic as <code>processString</code> in the Python. It
					takes in a
					character
					pointer to a string and then iterates on every character to put it through <code>applyRule_DragonCurve</code>.
					The result
					string from each call to <code>applyRule_DragonCurve</code> is concatenated together in memory.
				</p>
				<!-- HTML generated using hilite.me -->
				<div
					style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
					<pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">char</span>* processString_DragonCurve(<span style="font-weight: bold">char</span>* prev) {
	<span style="font-weight: bold">int</span> i = 0;
	<span style="font-weight: bold">char</span> *tmp;
	<span style="font-weight: bold">char</span> *check;
	<span style="font-weight: bold">int</span> length = strlen(prev);
	<span style="font-weight: bold">for</span> (i = 0; i &lt; length; i++) {
		check = prev;
		tmp = applyRule_DragonCurve(prev[i]);
		strcat(prev, tmp);
	}
	<span style="font-weight: bold">return</span> prev;
 }
 </pre>
				</div>
				<br>
				<p><code>createSystem_DragonCurve</code> needs the number of iterations and the starting axiom to function. For
					every number
					in the range [0, <code>numIters</code>-1] it calls <code>processString_DragonCurve</code> on the string from
					the previous
					iteration.</p>
				<!-- HTML generated using hilite.me -->
				<div
					style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
					<pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">char</span>* createSystem_DragonCurve(<span style="font-weight: bold">int</span> numIters, <span style="font-weight: bold">char</span>* axiom) {
 <span style="font-weight: bold">char</span> start[1000000];
 strcpy(start, axiom);
 <span style="font-weight: bold">char</span> end[1000000];
 *end = <span style="font-style: italic">&quot;&quot;</span>;
 <span style="font-weight: bold">int</span> i = 0;
 <span style="font-weight: bold">char</span> *check;
 <span style="font-weight: bold">for</span> (i = 0; i &lt; numIters; i++) {
   check = processString_DragonCurve(start);
   *start = end;
 }
 <span style="font-weight: bold">return</span> start;
}
</pre>
				</div>
				<br>
				<p>Finally, the dragon curve is drawn through the aptly named function <code>draw_DragonCurve</code>. It loops
					through each
					character in the character pointer of the L-System string and checks to see what graphing functionality that
					character possesses. This leans on VGA drawing functions written by Bruce Land.</p>
			</section>
			<!-- HTML generated using hilite.me -->
			<div
				style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
				<pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">void</span> draw_DragonCurve(<span style="font-weight: bold">char</span>* input, <span style="font-weight: bold">int</span> old_x, <span style="font-weight: bold">int</span> old_y) {
 <span style="font-weight: bold">int</span> a = 0; <span style="font-style: italic">// 0 degrees is straight up vertically</span>
 <span style="font-weight: bold">int</span> length = 10;
 <span style="font-weight: bold">int</span> new_x = old_x;
 <span style="font-weight: bold">int</span> new_y = old_y;
 <span style="font-weight: bold">int</span> i = 0;
 <span style="font-weight: bold">char</span> *check = input;
 printf(<span style="font-style: italic">&quot;GRAPHING STRING: &quot;</span>);
 <span style="font-weight: bold">while</span>(*check!=<span style="font-style: italic">&#39;\0&#39;</span>)
     printf(<span style="font-style: italic">&quot;%c&quot;</span>,*check++);
   printf(<span style="font-style: italic">&quot;</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
 <span style="font-weight: bold">for</span> (i = 0; i &lt; strlen(input); i++) {
   <span style="font-weight: bold">if</span>(input[i] == <span style="font-style: italic">&#39;X&#39;</span>) {
     <span style="font-weight: bold">continue</span>;
   } <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (input[i] == <span style="font-style: italic">&#39;Y&#39;</span>) {
     <span style="font-weight: bold">continue</span>;
   } <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (input[i] == <span style="font-style: italic">&#39;F&#39;</span>) {
     <span style="font-weight: bold">if</span> (a % 360 == 0) {
       VGA_line(new_x, new_y, new_x, new_y - length, red);
       new_x = new_x;
       new_y = new_y - length;
     } <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (a % 270 == 0) {
       VGA_line(new_x, new_y, new_x - length, new_y, yellow);
       new_x = new_x - length;
       new_y = new_y;
     } <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (a % 180 == 0) {
       VGA_line(new_x, new_y, new_x, new_y + length, red);
       new_x = new_x;
       new_y = new_y + length;
     } <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (a % 90 == 0) {
       VGA_line(new_x, new_y, new_x + length, new_y, yellow);
       new_x = new_x + length;
       new_y = new_y;
     }
   } <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (input[i] == <span style="font-style: italic">&#39;+&#39;</span>) {
     a = a + 90;
   } <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (input[i] == <span style="font-style: italic">&#39;-&#39;</span>) {
     a = a - 90;
   }
 }
}
</pre>
			</div>

		</div>
		<br id="full-system">
		<div class="box container">
			<section>
				<h2>Full-System Design</h2>
				<h3>Structure</h3>
				<p>Boasting a faster internal clock and configurable hardware, the FPGA is the core computational power for the
					system. This power is directed towards two main functionalities: calculating the L-System and graphing the
					L-System. The former relies on string manipulation, while the latter uses enable and address signals to write
					to the VGA screen. Since this system serves two distinct purposes, it was useful to split each into a separate
					Verilog file: <code>rules.v</code> for the calculations and <code>DE1_SoC_Computer.v</code> for the graphing.
					This modular approach not
					only made it simpler to visualize how each module connects, but it also made the testing process easier to
					take step by step.</p>
				<p>The C code running on the ARM side establishes the serial input control for the L-System’s settings, such as
					the L-System in question and the starting coordinates for graphing. There was the opportunity to use this for
					graphing as well, but the bandwidth and PIO port size limitations would’ve hindered our speedup. There was the
					additional thought of housing the L-System calculations on the ARM side, but this was also scrapped due to the
					FPGA’s faster clock frequency and opportunity for large amounts of data to be stored through M10Ks.</p>
				<p>Bridging the gap between the ARM and FPGA is the Avalon bus, visualized and configured using QSYS. The ARM
					takes in settings from the user and outputs them to the FPGA through output PIO ports, while the FPGA sends
					over timing information through an input PIO port. These ports have to be programmed on both ends; the ARM
					code memory maps their address spans, and the FPGA instantiates wires to connect the ports of the ARM module
					(called <code>Computer_System</code> in the Verilog) to relevant inputs/outputs in Verilog modules.</p>
				<p>The interweaving of these two technologies and the emphasis on each system’s strengths led to the development
					of responsive, visualizable L-Systems. Figure XX below shows how each connects via input and output signals
					and wires.</p>
				<img src="images/signalblockdiagram.png" style="display:block;margin: 0 auto; width:70%; height:70%">
				<br>
				<h3>Computation</h3>
				<p>The bulk of the code used to create these L-Systems is found in <code>rules.v</code> across four modules:
					<code>dual_clock_ram</code>,
					<code>signed_mult</code>, <code>rules</code>, and <code>create_system</code>.
				</p>
				<h4>dual_clock_ram</h4>
				<p><code>dual_clock_ram</code> is the memory unit of our system that allows our system to be recursive. Each
					instantiation of
					the module is composed of eight M10k blocks in a 8-bit by 8K configuration, with each block holding one of the
					eight blocks. The module performs one cycle writes and two cycle reads. Thus, in the cycle that a memory
					operation is called, a write would finish the following cycle, and a read would finish after the second
					positive edge of the clock. However, it is possible for these memops to still take the same amount of time
					because the read and write operations are processed on different clocks, both of which are taken as inputs
					(<code>clk1</code>, <code>clk2</code>). The other inputs are write enable (<code>we</code>),
					<code>read_address</code>, <code>write_address</code>, and write data (<code>d</code>). The
					sole output is read data (<code>q</code>). When graphing, this module is the limiting factor for the number of
					iterations
					which can be performed. With a fixed memory size, at some point, we will run out of space to write a new
					iteration. We settled on 8K memory locations because we calibrated our system to fit a 10-11 iteration dragon
					curve.
				</p>
				<h4>signed_mult</h4>
				<p>This module performs 11.21 fixed point signed multiplication. This means that there are 11 bits of integer
					and 21 bits of decimal in the inputs and output. Our reasoning behind 11.21 for the fixed point representation
					was that there were ample integer bits, so as to avoid overflowing during computation. For the purposes of
					this project, we felt the ranges of integer and floating point provided good resolution. This module is
					instantiated in our top level code for use in calculating the necessary vertical distances for diagonal lines.
				</p>
				<h4>rules</h4>
				<p><code>rules</code> is a clocked module which applies a specific update rule to an input character.
					Specifically it takes
					in an 8-bit character, and, depending on the specified L-system, will convert the input to an up to ten
					character output string. To interpret the character inputs properly, the alphabet of all valid characters for
					the available L-systems is defined with local parameters. The module operates by sitting in an initial wait
					state until a valid signal is asserted, indicating that the input is valid. The module then transitions to the
					appropriate update state depending on the input L-system signal. Within the specified state, only the rules of
					that system are available. If there exists a rule for that character, the corresponding conversion will be
					written to the result. If not, then the character is written to the result with 72 zeros appended to the end
					to fit the ten character buffer size.
				</p>
				<img src="images/rules_fsm.png" style="display:block;margin: 0 auto; width:95%; height:95%">
				<p>This scheme makes it fairly easy to add new L-Systems. We merely have to expand the alphabet and add an extra
					state to handle this new case. Below are examples of some of the systems we generated. We currently have 7
					systems encoded. They are the dragon curve, two versions of the Sierpinski arrowhead, Koch curve, Koch
					snowflake, cross, and tessellated triangle.</p>
				<img src="images/dragon_11iter_4length,300,300.png" style="display:block;margin: 0 auto; width:70%; height:70%">
				<br>
				<img src="images/arrow2_6iter_7length,300,300.png" style="display:block;margin: 0 auto; width:70%; height:70%">
				<br>
				<h4>create_system</h4>
				<p><code>create_system</code> in particular does the heavy lifting, instantiating two
					<code>dual_clock_ram</code> modules and
					one <code>rules</code>
					module in order to receive a 32-bit axiom, perform the calculations necessary to convert that starting string
					into a set of characters representing a fractal of that requested L-System, and output the entire result
					string byte by byte to the top level.
				</p>
				<p><code>create_system</code> requires a plethora of input and output values in order to function. The typical
					one bit <code>clk</code>
					and <code>reset</code> signals are inputs to the system, dictating when the internal FSM is allowed to restart
					and at what
					frequency it can run. <code>system_input_string</code> is the starting axiom, limited to 32 bits due to the
					maximum width
					of the PIO ports sending over this string from the HPS. A three bit signal <code>lsystem</code> chooses which
					of the seven
					L-Systems to calculate and graph, and four bit value <code>iterations</code> provides the number of recursive
					iterations
					the L-System will be required to make. As the module hops from state to state,
					<code>system_output_string</code> is set to
					a byte of the outputted result in order to somewhat parallelize the math being performed with the graphing
					being done. <code>iterations_counter</code> is another output, this time four bits; it’s updated to be equal
					to the
					iteration <code>create_system</code> is on so as to let the top level know when it’s appropriate to graph.
				</p>
				<p>The handshake interface between <code>create_system</code> and the top level FSM for graphing worked with
					four signals:
					<code>top_rdy</code>, <code>top_graphing</code>, <code>system_val</code>, and <code>system_done</code>. Those
					outputted by the top level—<code>top_rdy</code> and
					<code>top_graphing</code>—were received as inputs, indicating that the top level was ready for the next byte
					to be graphed
					and in what stage of graphing the top level was in, respectively. <code>system_val</code> and
					<code>system_done</code> are outputs, set
					appropriately to show that there’s a new valid output from <code>create_system</code> and that
					<code>create_system</code> has completed
					its L-System entirely.
				</p>
				<p>Two <code>dual_clock_ram</code> modules are instantiated to hold the L-System as it passes through every
					iteration. The
					first loop through the L-System string is performed on the axiom, which is a hard-coded value set by the user
					through the HPS. The expanded result string, created by running each character through the <code>rules</code>
					module, is
					then stored in an M10K block connected to one of the <code>dual_clock_ram</code> modules (let’s call it A).
					The next
					iteration takes this processed result string from A, runs each character through the <code>rules</code>
					module, and stores
					the new result in an M10K block created by the other <code>dual_clock_ram</code> module (designated as B).
					From then on,
					every iteration of <code>create_system</code> will read the previous iteration’s result from one
					<code>dual_clock_ram</code> and write
					the result to the other, alternating between A being read and B being written to B being read and A being
					written. Considering that <code>iterations_counter</code>—the register used to keep track of the
					iterations—starts at zero,
					here’s a simple rule of thumb: every even iteration writes to A and reads from B (except in the case of the
					zeroth iteration, which reads from axiom), and every odd iteration writes to B and reads from A. The
					<code>dual_clock_ram</code> modules will be referred to as A and B from now on.
				</p>
				<p>Aptly named <code>rule</code>, an instance of the <code>rules</code> module is connected to the appropriate
					inputs and internal
					registers. It needs the <code>lsystem</code> input to choose the correct L-System rules to apply to each
					character of the
					L-System string, the character in question (stored in <code>input_char</code>), and a valid signal
					<code>rule_val</code> to
					indicate the
					next character is ready to be processed. It outputs a maximum 80 bit value to <code>rule_result</code> after
					applying the
					relevant L-System rules to <code>input_char</code>, and a done signal <code>rule_done</code> used to
					acknowledge that it’s
					done
					processing.
				</p>
				<p>The mechanism propelling the creation of the requested L-System is composed of 13 states, as seen in the FSM
					below. The state logic and transitions are handled within an always block clocked on the positive triggering
					edge of the <code>clk</code> signal.</p>
				<img src="images/create_system_fsm.png" style="display:block;margin: 0 auto; width:95%; height:95%">
				<br>
				<p>The <code>reset</code> signal is active high and is sent across the PIO ports from the HPS once the user has
					configured
					all of the desired characteristics of the L-System. On reset, all of the internal registers (most notably the
					read/write addresses and write enables of both A and B, and the <code>system_done</code> signal) are cleared
					and
					<code>system_input_string</code> is loaded into the <code>axiom</code> register. The defined
					<code>RESET_SYSTEM</code> does this as well. The
					difference between the actions triggered by the <code>reset</code> signal and the <code>RESET_SYSTEM</code>
					state is that
					the former
					only occurs once at the very beginning of the program, and the latter is what the FSM returns to after
					completing an L-System and waiting for the next request from the user.
				</p>
				<p>Both the <code>reset</code> signal condition and <code>RESET_SYSTEM</code> transition to
					<code>CLEAR_M10KS</code> (though the latter
					waits until
					reset is high again, indicating the new L-System characteristics have been sent from the HPS). Since the
					L-System strings during and between iterations are stored in M10K blocks, it’s necessary to clear them before
					embarking on the next L-System. Until the write address values for A and B have reached the last possible
					memory address 0h1FFF (8191 in decimal), both write enable signals are set to one and the data values set to
					zero. This will result in every byte of the M10Ks being set to 8’b0. The state stays within itself until this
					process is complete, then moves on to <code>GET_CHAR</code>.
				</p>
				<p><code>GET_CHAR</code> is responsible for grabbing the next character in the string to pass into the
					<code>rule</code>
					module. However,
					it must wait until the top level is ready (equivalent to the top level finishing graphing the previous
					character sent over from <code>create_system</code>) so it doesn’t set the value of <code>input_char</code>
					for the <code>rules</code>
					module until
					the <code>top_rdy</code> signal is set to one. When this condition is met, how the state proceeds depends on
					what iteration
					the system is on, shown in <code>iterations_counter</code>. If the system is on the zeroth iteration, the
					hardcoded <code>axiom</code>
					is being processed so <code>input_char</code> is the least significant (rightmost) byte of <code>axiom</code>
					and the FSM can
					immediately transition to <code>COMPUTE_DRAGON</code>. If the system hasn’t reached the inputted value of
					iterations, it
					proceeds to <code>READ_M10K</code> to read a byte from the string written to either A or B’s M10K memory. If
					the system has
					performed the required number of iterations, the FSM goes to <code>DONE</code>.
				</p>
				<p><code>READ_M10K</code> chooses which set of M10Ks to read from based on whether
					<code>iterations_counter</code> is even or odd. Based
					on the setup of the <code>dual_clock_ram</code>, there’s no read enable signal; instead it takes three cycles
					to read the
					requested address in the M10K. Originally, we thought this meant our FSM would require some number of buffer
					states to ensure three clock cycles passed before the value was ready to be used, but the fact that our FSM is
					13 states means that enough time passes between individual characters being processed to absorb those three
					clock cycles. We take advantage of this by incrementing the read address for the appropriate
					<code>dual_clock_ram</code>
					module within <code>READ_M10K</code> based on whether <code>iterations_counter</code> is even or odd. Since
					this is the
					only state to
					change the value of the read addresses, A and B will read at their corresponding incremented address and the
					value at that address will be ready to grab the next time the FSM goes to <code>READ_M10K</code>.
				</p>
				<p>Whether from <code>GET_CHAR</code> directly or <code>READ_M10K</code>, the next state of the FSM is
					<code>COMPUTE_DRAGON</code>. Don’t
					let the name
					fool you, as this state is responsible for getting the resulting output from applying any of the seven
					L-System rule configurations, not just that of the dragon curve. The <code>rule_val</code> signal is set to
					tell <code>rule</code> that
					another character is on its way, and <code>rule_result</code> is stored in another register to be shifted in
					future states
					of the FSM. While the done signal <code>rule_done</code> is equal to zero, the FSM stays in
					<code>COMPUTE_DRAGON</code>,
					waiting for the
					<code>rule</code> module to finish processing the character. When this isn’t the case, it’s time to write the
					result to the
					M10Ks: A through state <code>WRITE_M10K_A</code> if <code>iterations_counter</code> is even, or B through
					state
					<code>WRITE_M10K_B</code> if
					<code>iterations_counter</code> is odd.
				</p>
				<p><code>WRITE_M10K_A</code> and <code>WRITE_M10K_B</code> are identical, save for the fact that they’re dealing
					with two different
					<code>dual_clock_ram</code> modules. As each memory location in the M10Ks is a byte wide, we take the most
					significant
					(leftmost) byte of <code>rule_result_reg</code> (note that this is not <code>rule_result</code>) and load it
					into either A or B’s data
					register as well as <code>system_output_string</code>. Every rule applied to the characters can output a
					maximum of ten
					bytes from a single byte input, so it takes multiple cycles to write the entirety of
					<code>rule_result_reg</code> to the
					M10Ks. The simplest way to keep track of which bytes had been written back and which ones hadn’t is by
					shifting out each byte of <code>rule_result_reg</code> after it’s written to its appropriate location in the
					M10Ks. Hence,
					we know the entirety of the output from rule is stored in memory once <code>rule_result_reg</code> equals 80
					bit zero; in
					this case, the write enable is set low so as to not accidentally write to any extra memory locations,
					<code>system_val</code> is set low to indicate that there isn’t a character to be graphed by the top level,
					and the FSM
					transitions to <code>NEXT_BYTE</code>. If there are more bytes in <code>rule_result_reg</code> to write to the
					M10Ks, the
					write enable
					is set high and the <code>top_rdy</code> is checked. <code>top_rdy</code> lets <code>create_system</code> know
					when the top
					level has
					finished
					handling the previous character sent to it and is ready for the next. When <code>top_rdy</code> is high,
					<code>system_val</code> is set
					high in response to say “Hey, we have a new character ready for you!” and the FSM transitions to
					<code>INCREMENT_WRITE_A</code> (or <code>INCREMENT_WRITE_B</code> when in <code>WRITE_M10K_B</code>, writing
					to the B <code>dual_clock_ram</code>).
					Otherwise,
					<code>system_val</code> is kept low and the FSM stays within <code>WRITE_M10K_A</code>.
				</p>
				<p>The goal for this val/rdy handshake is to not let one part of the system get ahead of the other. We don’t
					want <code>create_system</code> to continue chugging along with processing and storing the result string
					before the top
					level is done with the previous character. We also don’t want the top level to graph a character that isn’t
					ready yet, lest it mess up the final design of the L-System.</p>
				<p>Much like <code>WRITE_M10K_A</code> and <code>WRITE_M10K_B</code>, <code>INCREMENT_WRITE_A</code> and
					<code>INCREMENT_WRITE_B</code> are the same except for what
					<code>dual_clock_ram</code> they’re interfacing with. This state is responsible for incrementing either A or
					B’s write
					address so that the next time the FSM is in <code>WRITE_M10K_A</code> or <code>WRITE_M10K_B</code> it knows to
					write to the next
					available location in memory. It’s also responsible for shifting <code>rule_result_reg</code>. Since the
					baseline Python
					code looped across each string from left to right, so does this Verilog implementation by shifting the
					leftmost byte out. The FSM immediately transitions back to <code>WRITE_M10K_A</code> or
					<code>WRITE_M10K_B</code>.
				</p>
				<p>After the entirety of <code>rule_result_reg</code> has been stored in the appropriate
					<code>dual_clock_ram</code> module,
					<code>NEXT_BYTE</code> is
					responsible for shifting <code>axiom</code> in a similar fashion to <code>rule_result_reg</code>. As described
					earlier,
					<code>axiom</code> holds the
					32 bit hardcoded axiom for the L-System and is the starting point for the zeroth iteration of
					<code>create_system</code>.
					Once every character of <code>axiom</code> has gone through the <code>rules</code> module, it can be shifted
					out because
					there is no use
					for it anymore—its result is all the system needs to remember about it, and that’s already been written to the
					M10Ks. In any iteration besides the zeroth, this acts more like a buffer state than anything else, but it also
					serves to hold the <code>system_val</code> and <code>system_done</code> signals low, which are easy to lose
					track of.
				</p>
				<p>The next state is <code>INCREMENT_ITER</code>; as the name implies, it’s responsible for incrementing the
					value of
					<code>iterations_counter</code> once the entirety of the string has been processed. There are many checks that
					must be done
					before this simple task can happen, since there are multiple cycles within the FSM and the iterations
					themselves are cycles. First, <code>system_output_string</code> must be zero, <code>axiom</code> must be zero,
					and
					<code>top_graphing</code> must be
					two. <code>system_output_string</code> being zero means that the last value of <code>rule_result_reg</code> is
					zero and the
					entirety of
					the string has been processed and shifted out, with <code>system_output_string</code> lagging and grabbing an
					extra byte of
					<code>rule_result_reg</code> in <code>WRITE_M10K_A/B</code> while waiting to go to <code>NEXT_BYTE</code>.
					<code>axiom</code> is zero once the zeroth
					iteration
					has reached its end, so this check makes sure that the system has at least gotten through that.
					<code>top_graphing</code>
					is an input from the top level showing what state of graphing the top level is in: 0 before a character is
					graphed, 1 during graphing, and 2 post-graphing. A value of 2 means that the last character sent over by
					<code>create_system</code> has been fully graphed. The next check depends on <code>iterations_counter</code>:
					if it’s zero,
					no
					additional logic is needed; if it’s even, B needs to be reading a value of zero; and if it’s odd, A needs to
					be reading a value of zero. This is a check to see if there are more bytes to be read and processed from the
					M10Ks (hence why on the zeroth iteration this doesn’t require any logic) since all bytes in the M10Ks
					following the last byte of the processed string will be zero (as promised by <code>CLEAR_M10KS</code>). If
					those hurdles
					are cleared, it’s time for <code>iterations_counter</code> to be incremented and the write addresses for both
					<code>dual_clock_ram</code> modules to be zeroed out. This ensures that the next iteration will write the
					result from the
					top of the M10Ks, overwriting the previous iteration and even going past that (since every iteration grows the
					string in length). The next state will be <code>ZERO_READ</code> if all of the conditionals are true,
					otherwise no logic is
					performed at all and the FSM heads back to <code>GET_CHAR</code> to start the processing and storing of the
					next character
					in the string.
				</p>
				<p><code>ZERO_READ</code> is also self-explanatory: it zeroes the read addresses for the
					<code>dual_clock_ram</code> modules.
					The read
					address for B is only set to zero if the system is on an even-numbered iteration, otherwise the read address
					for A is set to zero. This state transitions to <code>GET_CHAR</code>.
				</p>
				<p>The last state of the FSM is <code>DONE</code>. Its primary function is to set the <code>system_done</code>
					signal to one
					in order to
					let the top level know not to expect any more characters from <code>create_system</code> as it has completed
					the requested
					number of iterations over the L-System string. The read/write addresses for A and B are set to zero to prepare
					to handle the next L-System after heading back to <code>RESET_SYSTEM</code>.</p>
				<h3>Graphing</h3>
				<p>Our top level, <code>DE1_SoC_Computer.v</code>, serves as the bridge between the user inputs and the
					<code>create_system</code> module.
					In addition, it holds the graphing finite state machine.
				</p>
				<p>Writing to the VGA screen utilizes three signals: <code>vga_sram_write</code>, <code>vga_sram_address</code>,
					and <code>vga_sram_write</code>
					is a one bit write enable signal—if it’s 1, the VGA will be written to. <code>vga_sram_address</code> is a
					32 bit value attributed to an address in the space of the screen, where the base address is 32’b0.
					<code>vga_sram_writedata</code> is an eight bit value corresponding to the data to be written at
					<code>vga_sram_address</code>,
					specifically the color of the pixel located at that address.
				</p>
				<p>The output PIO ports (from the ARM to the FPGA) allow for user interaction through the terminal to change the
					<code>lsystem</code>, <code>axiom</code>, number of iterations, length and color of lines, as well as the
					initial coordinates, <code>start_x</code>
					and <code>start_y</code>. There is also an output PIO port that sends the <code>reset</code> signal, driven by
					the HPS. In
					addition, an
					input PIO port sends <code>timer_counter</code> from the FPGA to the ARM in order to calculate the timing
					information of
					the system.
				</p>
				<p>We instantiate a module of <code>create_system</code> to send over required values. Particularly, the
					<code>top_rdy</code>
					and
					<code>system_val</code> wires allow for a handshake between the modules, so that the top level FSM does not
					start graphing
					too early.
				</p>
				<img src="images/trig_sketch.png" style="display:block;margin: 0 auto;">
				<p>There is also an instantiation of <code>signed_mult</code>, called <code>triangle_mult</code>, which
					calculates the target pixel
					required for the 60° based diagonal lines. Remembering trigonometry, we know that the horizontal step size is
					<code>length</code>/2, which can be calculated by shifting <code>length</code> by 1. However, the vertical
					step size is
					sqrt(3)<code>length</code>/2,
					which cannot be so easily calculated with bitwise operations. Thus, we use 11.21 fixed point multiplication.
					The inputs to this module are <code>root_three</code> (sqrt(3) represented in 11.21 fixed point), and
					<code>x_triangle_length</code>,
					the 11.21 fixed point version of <code>length</code> >> 1. The output is <code>y_triangle_length</code>. For
					use in
					graphing to pixels,
					the integer bits [30:21], are used in calculations. These bits omit the signed bit in the fixed point integer,
					which causes a limitation in calculation values off off the screen in the negative direction.
				</p>
				<img src="images/top_level_fsm.png" style="display:block;margin: 0 auto; width:95%; height: 95%">
				<br>
				<p>The 10 state top level FSM is triggered on the positive rising edge of the 50MHz clock. We consider this FSM
					to be modular—as in, some states are chosen based on which L-System is being graphed.
					<code>timer_counter_reg</code> is
					incremented in every state except for <code>TOP_RESET</code> and <code>TOP_DONE</code>, to provide timing
					information for the whole
					system.
				</p>
				<p>The first state is <code>TOP_RESET</code>, which is entered at the <code>reset</code> signal from the HPS. In
					this state,
					<code>angle_increment</code> is set based on what is required for the <code>lsystem</code> entered. If the
					<code>reset</code> signal is
					sent again,
					the FSM will stay in this state. Otherwise, it will move onto <code>TOP_WAIT</code>.
				</p>
				<p>In <code>TOP_WAIT</code>, the <code>system_done</code> wire from <code>create_system</code> is checked. If it
					is high, the
					FSM moves
					into the
					<code>TOP_DONE</code> state. If not, there are two conditions. If the <code>system_val</code> wire is low, the
					<code>top_rdy_reg</code>
					is set high,
					and the FSM stays in <code>TOP_WAIT</code>. If <code>system_val</code> is high, <code>top_rdy_reg</code> is
					set low,
					<code>system_output_string_reg</code> is set
					based on the <code>system_output_string</code> wire from <code>create_system</code>, and the FSM moves into
					<code>TOP_SETUP</code>.
				</p>
				<p>
					The <code>TOP_SETUP</code> state is used to make sure all relevant registers have the most updated values. In
					particular,
					<code>top_char_reg</code> is set to <code>system_output_string_reg</code>, so that graphing rules can be
					applied to this character in
					the following state. The FSM then moves on to <code>TOP_TARGET</code>.
				</p>
				<p>In <code>TOP_TARGET</code>, either the target pixels (<code>targetx_reg</code> and <code>targety_reg</code>)
					or the
					direction of drawing (<code>angle_reg</code>)
					are set based on what <code>top_char_reg</code> is. For the drawing characters (F and A),
					<code>targetx_reg</code> and
					<code>targety_reg</code> are
					set based on <code>angle_reg</code>; If <code>angle_reg</code> is 0 or 180 (vertical) or 90 or 270
					(horizontal), either <code>targetx_reg</code> or
					<code>targety_reg</code> are incremented by <code>length</code>. If <code>angle_reg</code> is 60, 120, 240, or
					300, a
					diagonal line is needed, and
					the target coordinates are instead incremented using the step sizes calculated using the
					<code>signed_mult</code> module
					(<code>x_triangle_length</code> and <code>y_triangle_length</code>). If <code>top_char_reg</code> is either +
					or -, <code>angle_reg</code> is incremented or
					decremented by the <code>angle_increment</code> value set in <code>TOP_RESET</code>. In cases where the
					resulting angle would be set to
					360, it is reset to 0 for ease in future calculations. Next, the FSM goes into <code>TOP_BOUND_CHECK</code>.
				</p>
				<p><code>TOP_BOUND_CHECK</code> chooses which graphing state to go to based on what <code>lsystem</code> is. It
					also chooses
					to skip the
					graphing states if the target coordinates are outside of the screen, and go directly to
					<code>TOP_SHIFT</code>.
				</p>
				<p>
					All three graphing states do an additional check on the bounds, and set the write enable,
					<code>vga_sram_write</code> low
					in the case of an offscreen pixel. This allows for a line with target coordinates outside the graphing region
					to draw up until the edges of the screen.
				</p>
				<p><code>TOP_GRAPH_DRAGON</code> is named after our first successfully implemented <code>lsystem</code>, the
					dragon curve,
					and is the
					graphing state for purely horizontal and vertical lines. In this state, either <code>x_reg</code> or
					<code>y_reg</code> is
					incremented
					in each cycle until the graphed coordinates match the target coordinates. To graph to the screen,
					<code>vga_sram_address</code> is set to the desired coordinates, <code>vga_sram_writedata</code> is set to the
					color chosen
					by the user,
					and <code>vga_sram_write</code> is set high. Once the coordinates match, the FSM will move on to
					<code>TOP_SHIFT</code>.
					However, if
					either the <code>x_reg</code> or <code>y_reg</code> value exceeds (2^32)-1 (the maximum value that can be held
					in the 32 bit addresses),
					the FSM will immediately enter <code>TOP_DONE</code>.
				</p>
				<p><code>TOP_GRAPH_TRIANGLE_X</code> and <code>TOP_GRAPH_TRIANGLE_Y</code> are the graphing states used for
					L-Systems that require
					diagonal lines. These states cycle between each other to graph 2 pixels horizontally and 5 pixels vertically,
					and move on to <code>TOP_SHIFT</code> once the graphed coordinates has passed or is equal to the target
					coordinates. This
					is a limiting way to graph diagonal lines, as it requires that the minimum side length is at least 7 to result
					in a line that is reasonably diagonal. However, constrained by the pixels on the screen, we found this to be a
					fairly accurate way to draw lines with our desired slope.</p>
				<p>The <code>TOP_SHIFT</code> state sets the <code>top_graphing_reg</code> to 2. This is a wire checked by
					<code>create_system</code> before
					incrementing <code>iterations_counter_reg</code>. After this state, the FSM returns to <code>TOP_WAIT</code>.
				</p>
				<p>The final state in the top level graphing FSM is <code>TOP_DONE</code>. At this point, all graphing for the
					inputted
					L-System has been completed, and the final value of <code>timer_counter_reg</code> is used for the timing
					calculations. The
					FSM will stay in this state until the <code>reset</code> signal is sent by the HPS to bring the FSM back to
					<code>TOP_RESET</code>.
				</p>
				<h3>User Interface</h3>
				<p>As previously mentioned, the HPS handles user inputs as well as printing valuable information to the terminal
					window. This code can be found in <code>graphics.c</code>. Here is an overview of the PIO ports and the
					associated actions
					done by the HPS.</p>
				<p><code>lsystem</code>: before asking for a user input for this 3-bit output PIO port, the HPS prints out the
					available
					L-Systems and the numbers associated with them. If the user enters an invalid character, the prompt is
					replayed.</p>
				<p><code>axiom</code>: Once a valid L-System has been chosen, the HPS asks for a user input for the 32-bit
					output PIO port,
					axiom. Before asking for it, however, the HPS prints some key information to enhance usability, including: the
					default axiom for the chosen L-System, the rule-making characters in that L-System, which characters enable
					drawing for that L-System, and finally, all available characters for use in the axiom. This information allows
					the user to either input the default axiom (without having to look it up), or create their own unique axiom.
				</p>
				<p><code>iterations</code>: This 4-bit output PIO port holds the user inputted value for the number of
					iterations. Table 3
					shows our results for the largest number of iterations for each curve that can be supported by our design.</p>
				<img src="images/max_iterations.png" style="display:block;margin: 0 auto;">
				<br>
				<p><code>length</code>: This 5-bit output PIO port holds the user inputted value for the length of each line.
					This value’s
					bounds are checked before moving on to the next user input. The maximum value of length is limited by the size
					of the PIO port, so it must be less than 31. While that is the maximum allowed, the user must be cognizant
					that lower values are often needed to project the curve within the graphable region of the screen. The minimum
					length varies based on the chosen <code>lsystem</code>. For L-Systems that rely on purely horizontal and
					vertical lines,
					the minimum length is 3, in order to properly visualize squares. For L-Systems that contain diagonal lines,
					the minimum length is 7, in order to properly visualize the slope of the diagonals.</p>
				<p><code>color</code>: This 8-bit output PIO port holds the user inputted value for the color of the L-System.
					The HPS prints
					out the available 8-colors that have been hardcoded. If the user input does not match any of the options, the
					system defaults to white (0xff).</p>
				<p><code>start_x</code> and <code>start_y</code>: These are 10-bit output PIO ports that hold the initial
					coordinates for graphing.
					<code>start_x</code> is the horizontal coordinate, and is bounded by the left and right sides of the screen (1
					to 638).
					<code>start_y</code> is the vertical coordinate, and is bounded by the top and bottom of the screen (1 to
					478).
				</p>
				<p><code>reset</code>: this 1-bit output PIO port allows the <code>reset</code> signal to be sent to the ARM.
					Once the screen
					is cleared,
					the user can press any key to toggle this signal and begin the graphing process.</p>
				<p><code>timer_counter</code>: This 32-bit input PIO Port receives this value, which was incremented during
					every cycle of
					the top level FSM (except during the states <code>TOP_WAIT</code> and <code>TOP_DONE</code>). This value is
					then scaled from the number
					of cycles of the 50MHz clock to a recognizable time in seconds, which is printed to the terminal screen.</p>
				<p>Once the L-System has been graphed, the user is given the option to either zoom in, zoom out, pan to new
					coordinates, or begin a new L-System. The first three options modify either the <code>length</code> or the
					starting
					coordinates on the C-side of the program, and send the new values to the ARM, where the modified curve is
					re-calculated and graphed again.</p>
			</section>
		</div>
		<br id="testing">
		<div class="box container">
			<section>
				<h2>Testing</h2>
				<p>In the past we’ve suffered from biting off more than what we can chew, aka building a large chunk of the
					project before testing. This wasn’t a trap we’d be able to fall into this time, especially considering that
					this project is our own ideation—there’s no reference code to rely on when debugging. With this in mind, we
					worked through every module carefully and tested thoroughly along the way. We also initially focused our
					efforts on solely the dragon curve, as the 90 degree increments made for more straightforward graphing.
				</p>
				<p>The first hurdle was the <code>rules</code> module. There were multiple ways to structure it: one module per
					L-System to house
					all of its specific rules, one module per character that would select between rules for each L-System, one
					all-encompassing module with every single rule for every single L-System. Ultimately we chose the last design,
					as we realized that it only required a single input wire to be able to toggle between rule implementations for
					different L-Systems. Once that had been decided, we implemented the module as a case statement outputting to a
					statically-sized register. Though we knew we wanted to utilize M10Ks for their storage capabilities, we’ve had
					bad experiences with them in the past and therefore wanted to hammer down our core functionality before
					complicating it with reading/writing to memory.</p>
				<p>We used ModelSim to verify the outputs and intermediate values. The output register was simple to verify as
					it simply needed to be compared to the expected output string of the L-System rule. This result wasn’t being
					sent byte-by-byte either, so there were no timing issues to consider. We did run into the issue of the
					characters not being accepted by the case conditions and instead falling into the default case, a behavior we
					noted through displaying the <code>rule_done</code> signal (which, rather than being a single bit value to
					toggle between
					zero and one, was a two bit signal that was set to a different value in every case). This was solved by
					defining the ASCII codes for each character as strict eight-bit localparams and constraining the module to
					only accept a single character byte at a time.</p>
				<p><code>create_system</code> was originally broken into two modules: <code>create_system</code> and
					<code>process_string</code>. Much
					like the
					baseline code, these separate modules iterated over a string and performed multiple iterations on a string,
					respectively. We decided to combine them into a single module once we began to tackle the issue of graphing
					via the top level. It wouldn’t be feasible to send over the entire result string from
					<code>process_string</code> to the
					top level because we wouldn’t know how large it was. Sending the result string byte by byte, with the top
					level graphing at the same time as the computations, was a viable option, but it would be redundant for both
					<code>create_system</code> and <code>process_string</code> to be handling strings byte by byte. Even more
					critically, we needed to be
					reading and writing to the M10Ks with every iteration, but we weren’t sure about how to have multiple modules
					safely interact with the same M10Ks in parallel. Therefore, we combined the two, resulting in a rat’s nest of
					FSM states and signal wires that we had to debug in ModelSim.
				</p>
				<p>Before the M10Ks were in use, the result string of the overall system was limited to two bytes, hardly enough
					to graph a robust L-System. While our code was operational with those limitations, there was no telling what
					could happen once we allowed it to perform multiple iterations on a larger axiom. Writing to the M10Ks takes
					multiple cycles per character since we have to write each byte to its own individual address, and reading from
					the M10Ks requires at least three clock cycles as a buffer. ModelSim was extremely useful when debugging the
					<code>WRITE_M10K_A/B</code>, <code>INCREMENT_A/B</code>, and <code>READ_M10K</code> states because we could
					not only see what data was being
					read/written but also the address at which this was occurring. Being able to see these signals informed us
					that we didn’t need a separate buffer state for reading, as well as what logic should go into the transitions
					out of <code>WRITE_M10K_A/B</code>.
				</p>
				<p>Initially the axiom was hardcoded in the Verilog to not have to worry about how the terminal serial input was
					being sent over the PIO ports to the FPGA. After we began to connect the C code with the Verilog, a few
					confusing bugs arose. First was the issue of the order of characters in the axiom: when hardcoded, we treated
					the axiom as a normal English string and processed it from left to right, but when looking at the output
					signals in ModelSim we realized that they were flipped with respect to our expected values. Somehow the 32
					bits of the axiom are reversed before the FPGA starts its calculations (we’re still unsure as to why this
					happens, but attribute it potentially to the way memory mapping happens in the C code). In the interest of
					time, we didn’t dig into the root of this problem but instead patched it by grabbing the least significant
					byte of the axiom and shifting each byte out to the right, effectively reading the character string from right
					to left. Another fun behavior to debug was the appearance of unexpected ones in our <code>axiom</code>
					register as we
					shifted out bytes. At first we thought it could be the way we were shifting, so we concatenated a zero byte to
					a substring of the register, but that didn’t fix it. Upon closer inspection of the binary values, we realized
					that the ENTER presses needed to send the serial input was being included in any input string shorter than
					four bytes (the maximum length, as dictated by the PIO ports), and these enter presses didn’t have an ASCII
					code of zero. Our solution was to initialize the character pointer for the axiom to four bytes of ASCII code
					zero (equivalent to four spaces) so that if a byte wasn’t overwritten by the serial input, it wouldn’t affect
					the register’s overall ability to be equal to zero (key in most of our transitions).
				</p>
				<p>At the start of development, the modular nature of our system made it conducive to testing since all of the
					signals were separated from each other and provided a good deal of information gain on their own. The
					introduction of the val/rdy interface between the top level and <code>rules.v</code> complicated our ability
					to use
					ModelSim for debugging purposes since the wire values were held for too long. In the context of our full
					system, ModelSim was useful for debugging the small issues that arose in individual modules but wasn’t a
					viable tool when the system required more than one iteration on the string.</p>
				<p>This is when we pivoted to SignalTap as our primary debugging tool. Though it was disadvantaged in the sense
					that a full compile of the Verilog was needed before SIgnalTap would read the corresponding signals, it was
					able to show the waveform behavior of the real system, including the Verilog and the C code. A caveat with
					this is the space required to store all of the hardware signals. Our design uses a good deal of memory through
					the M10Ks, so there’s a limit to how many data samples SignalTap can acquire. This was a detriment when
					testing multiple iterations, so we had to use shorter axioms and a smaller number of iterations. The
					discrepancies in string generation ended up stemming from smaller issues within the modules (such as the ASCII
					code problem) but not being able to see all of the clock cycles for more than four or five iterations made
					debugging more difficult.</p>
				<p>This was especially relevant for M10K debugging, as there was a time when it seemed as though the string
					being written to memory was much longer than the expected string, a problem that was exacerbated in higher
					iterations. We weren't sure if it was a problem with our M10K states or M10K memory being cleared. After
					noticing that this appeared on L-Systems after the first one (so not immediately after the entire board was
					reset), we moved our <code>CLEAR_M10KS</code> state from the end of the FSM (after the <code>DONE</code>
					state) to the beginning.
					Additionally, we realized that as we grew the M10Ks we didn’t adjust the last address to which the M10K needed
					to be cleared, so <code>CLEAR_M10KS</code> was only clearing part of memory (a pretty big problem since the
					number of
					iterations is incremented when an address holding a zero is reached in the M10Ks). This is a problem we had
					throughout our usage of the M10Ks, as originally they were coded to have 256 memory address (meaning each
					address needed eight bits) and when we expanded them to 512, 1024, and eventually 8192 we didn’t always adjust
					the bit widths of the read/write memory addresses.</p>
				<p>In regard to the top level, we were able to use the printouts to the VGA screen to debug our graphing;
					particularly, this was helpful as we began to implement diagonal lines. We had decided that we would use
					fixed-point signed multiplication to calculate our target pixel, and use incremented horizontal and vertical
					pixels in an approximate ratio to draw lines that would appear diagonal. Our setup included separate states
					for horizontal and vertical drawing, and they would alternate between each other based on a counter variable
					(<code>xcounter</code> and <code>ycounter</code>). Other than a brief stint where we were accidently assigning
					50-bits to one of our
					32-bit fixed point variables (which caused diagonal lines to wrap all across the screen), this was mostly
					smooth sailing. Eventually, we realized that our lines were not exactly the right slope for a 60° line, and
					determined that we had swapped the bound check for <code>xcounter</code> and <code>ycounter</code>. </p>
				<p>Overall, the focus on developing modular functionality made debugging a more approachable task. ModelSim and
					SignalTap also made looking closely at every single input, output, and intermediate value only slightly
					frustrating.</p>
			</section>
		</div>
		<br id="future">
		<div class="box container">
			<section>
				<h2>Future Work</h2>
				<p>There are several things that could be improved or expanded upon in future implementations of this project.
					First and foremost, we would refactor the top level coordinate calculations to include signed rather than
					unsigned variables. While graphing to the screen only requires positive pixel values, we found that
					calculations outside of the range of the screen would increase graphing robustness, as it would allow for the
					fractal to return to the screen if it curves back into the graphable region. Currently, our implementation
					supports calculations involving positive pixels outside the graphable region (i.e. the bottom and right side
					of the screen), but we encounter overflow for pixels in the negative direction (i.e. the left side and top of
					the screen).</p>
				<p>Furthermore, in order to graph more robust diagonal lines, Bresenham’s line algorithm could be implemented.
					This algorithm would create smooth diagonal lines, and allow us to explore more L-systems based on different
					angle turns (such as 45° or 36°). </p>
				<img src="images/levy.png" style="display:block;margin: 0 auto; width: 60%;height: 60%;">
				<br>
				<img src="images/pentaplexity.png" style="display:block;margin: 0 auto;width: 60%;height: 60%;">
				<br>
				<p>We would also be interested in exploring further user-customization of L-Systems. While the current system
					allows for customizable axioms, this could be expanded to allow users to create unique L-Systems with custom
					rules and customizable angle turns. This would provide ease for researchers (or other people interested in
					fractals) to develop new L-Systems.</p>
			</section>
		</div>
		<br id="results">
		<div class="box container">
			<section>
				<h2>Results</h2>
				<p>The following are some of the performance metrics of our system. Across the board, the FPGA exhibits a faster
					computation time than the baseline Python script. For the maximum number of iterations on each of our 6
					L-systems, the worst speedup was 5.1x, and the best was 77.8x with an average of about 20.04x. This is due to
					a number of factors including the line length and growth rate.</p>
				<img src="images/Tessellated Triangle (2).png" style="display:block;margin: 0 auto;">
				<br>
				<p>Let’s take a <a href="images/look_at_this_graph.gif">look at this graph</a> above. This chart shows the
					execution time per character for the Python and
					FPGA calculating the tessellated triangle. It appears that for the FPGA, there is some initial overhead with
					the first few iterations. This overhead is nullified by the law of large numbers at higher iterations,
					allowing the FPGA to settle to around 200 us per character for both the length 7 and length 10 versions.
					However, this does not appear to be the case for the Python code. The length 7 code takes about 3.6 ms per
					character, while the length 10 code takes 17ms. Additionally, although this is merely an observation,
					generally, the less iterations it takes to fill up the M10K blocks, i.e. a higher growth rate, the larger the
					disparity between the Python and FPGA.
				</p>
				<img src="images/Dragon Curve.png" style="display:block;margin: 0 auto;">
				<br>
				<img src="images/Sierpinski Arrowhead (1).png" style="display:block;margin: 0 auto;">
				<br>
				<img src="images/Cross.png" style="display:block;margin: 0 auto;">
				<br>
				<img src="images/Koch Snowflake.png" style="display:block;margin: 0 auto;">
				<br>
				<img src="images/Koch Snowflake.png" style="display:block;margin: 0 auto;">
				<br>
				<img src="images/Tessellated Triangle.png" style="display:block;margin: 0 auto;">
				<br>
				<p>The M10K blocks are a limiting factor in our generation of L-Systems. As shown in these graphs, not all
					L-Systems are equal in terms of how fast they grow. The maximum number of characters is 8192. However, due to
					exponential growth, some of the largest systems we can generate are significantly less than this threshold.
					Additionally, we are sometimes inhibited by the negative value computation difficulty mentioned earlier. Below
					is a chart of the L-Systems and their maximum size on our system. Generally, there are few differences between
					the FPGA for edges of length 7 and length 10. For the python, it takes longer to generate the length 10 versus
					length 7 images. Within the results, there is only one instance of the negative values causing the FPGA to
					have a lower number of iterations for the length 10 graph than the length 7 graph. In all other cases, the max
					number of iterations is set by the M10K blocks.
				</p>
				<img src="images/compute_times.png" style="display:block;margin: 0 auto;">
				<br>
				<p>A full working demo of our entire system can be found below: </p>
				<iframe style="display:block;margin: 0 auto;" width="560" height="315"
					src="https://www.youtube.com/embed/NIYnzu1di3o" frameborder="0"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
					allowfullscreen></iframe>
			</section>
		</div>
		<br id="conclusion">
		<div class="box container">
			<section>
				<h2>Conclusion</h2>
			</section>
		</div>
		<br id="appendix">
		<div class="box container">
			<section>
				<h2>Appendices</h2>

				<h3>Team</h3>
				<a href="images/baby_yoda_drinking_tea.gif"><img src="images/priya_headshot.JPG"
						style="display:block;margin: 0 auto; width:30%; height: 30%;"></a>
				<h4>Priya Kattapurath</h4>
				<p style="text-align: center;"><i>ECE '20, MEng '21</i></p>
				<br>

				<a href="images/sleepy_duck.gif"><img src="images/priya_headshot.JPG"
						style="display:block;margin: 0 auto; width:30%; height: 30%;"></a>
				<h4>Michael Rivera</h4>
				<p style="text-align: center;"><i>ECE '20, MEng '20</i></p>
				<br>

				<a href="images/eggdog.gif"><img src="images/caitlin.jpg"
						style="display:block;margin: 0 auto; width:30%; height: 30%;"></a>
				<h4>Caitlin Stanton</h4>
				<p style="text-align: center;"><i>ECE '20, MEng '21</i></p>
				<br>

				<h3>Appendix A: Permissions</h3>
				<p>The group approves this report for inclusion on the course website.
					The group approves the video for inclusion on the course YouTube channel.
				</p>
				<h3>Appendix B: Work Distribution</h3>
				<p>All members contributed to the development, debugging, and demoing of the baseline and full-system designs.
				</p>
				<ul>

					<li>Introduction - Caitlin</li>
					<li>High-Level Design - Caitlin</li>
					<li>Baseline Design - Caitlin</li>
					<li>Full System Design - Priya, Caitlin, Michael</li>
					<li>Testing - Caitlin, Priya</li>
					<li>Future Work - Priya</li>
					<li>Results - Michael</li>
					<li>Conclusion - Michael</li>
					<li>Commented Code - Caitlin</li>
					<li>Diagrams - Priya</li>
					<li>Graphs - Caitlin, Michael</li>
				</ul>
				<h3>Appendix C: References</h3>
				<ul>
					<li><a href="https://en.wikipedia.org/wiki/L-system">Wikipedia: L-System</a></li>
					<li><a href="https://mathworld.wolfram.com/LindenmayerSystem.html">Wolfram Alpha: Lindenmayer Systems</a></li>
					<li><a href="https://fractalfoundation.org/resources/what-are-fractals/">What are Fractals?</a></li>
					<li><a href="https://breaksome.tech/coding-a-dragon-curve-in-p5js/">Coding a Dragon Curve</a></li>
					<li><a href="https://breaksome.tech/coding-a-fractal-plant-in-p5js-using-l-systems/">Coding a Fractal
							Plant</a></li>
					<li><a href="https://en.wikipedia.org/wiki/Dragon_curve">Wikipedia: Dragon curve</a></li>
					<li><a href="https://medium.com/@hhtun21/l-systems-draw-your-first-fractals-139ed0bfcac2">Drawing nice
							L-Systems</a></li>
					<li><a href="https://medium.com/@hhtun21/l-systems-draw-a-stochastic-plant-ii-f322df2ea3c5">Drawing nice
							stochastic plants</a></li>
					<li><a href="https://people.ece.cornell.edu/land/courses/ece5760/DE2/indexVGA.html">ECE 5760: VGA examples</a>
					</li>
					<li><a href="https://www.beyond-circuits.com/wordpress/2009/01/recursive-modules/">Recursive Modules</a></li>
					<li><a
							href="https://people.ece.cornell.edu/land/courses/ece5760/DE1_SOC/HPS_peripherials/Bus_master_slave_index.html">Avalon
							Bus Master</a></li>
					<li></li>
					<li></li>
				</ul>
				<h3>Appendix D: Code</h3>
				<h4>rules.v</h4>
				<h4>DE1_SoC_Computer.v</h4>
				<h4>graphics.c</h4>
			</section>
		</div>

	</div>

	<!-- Footer -->
	<div id="footer">
		<div class="container medium">

			<header class="major last">
				<h2>Questions or comments?</h2>
			</header>

			<p>Vitae natoque dictum etiam semper magnis enim feugiat amet curabitur tempor
				orci penatibus. Tellus erat mauris ipsum fermentum etiam vivamus.</p>

			<form method="post" action="#">
				<div class="row">
					<div class="col-6 col-12-mobilep">
						<input type="text" name="name" placeholder="Name" />
					</div>
					<div class="col-6 col-12-mobilep">
						<input type="email" name="email" placeholder="Email" />
					</div>
					<div class="col-12">
						<textarea name="message" placeholder="Message" rows="6"></textarea>
					</div>
					<div class="col-12">
						<ul class="actions special">
							<li><input type="submit" value="Send Message" /></li>
						</ul>
					</div>
				</div>
			</form>

			<ul class="icons">
				<li><a href="#" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>
				<li><a href="#" class="icon brands fa-facebook-f"><span class="label">Facebook</span></a></li>
				<li><a href="#" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
				<li><a href="#" class="icon brands fa-github"><span class="label">Github</span></a></li>
				<li><a href="#" class="icon brands fa-dribbble"><span class="label">Dribbble</span></a></li>
			</ul>

			<ul class="copyright">
				<li>&copy; Untitled. All rights reserved.</li>
				<li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
			</ul>

		</div>
	</div>

	<!-- Scripts -->
	<script src="assets/js/jquery.min.js"></script>
	<script src="assets/js/browser.min.js"></script>
	<script src="assets/js/breakpoints.min.js"></script>
	<script src="assets/js/util.js"></script>
	<script src="assets/js/main.js"></script>

</body>

</html>